import type { Finding } from '../commands/audit.js';
import type { ParsedIdl } from '../parsers/idl.js';
import type { ParsedRust } from '../parsers/rust.js';

/**
 * SOL241: Pump.fun-style Employee Exploit
 * Detects insider threat patterns and privileged access abuse
 * Reference: Pump.fun exploit (2024) - Employee used position to drain $1.9M
 */
export function checkPumpFunExploit(idl: ParsedIdl | null, rust: ParsedRust | null): Finding[] {
  const findings: Finding[] = [];

  if (rust) {
    for (const fn of rust.functions) {
      const content = fn.body.toLowerCase();

      // Check for single admin key patterns
      if (content.includes('admin') || content.includes('authority') || content.includes('owner')) {
        if (!content.includes('multisig') && !content.includes('multi_sig') && 
            !content.includes('threshold') && !content.includes('signers')) {
          if (content.includes('withdraw') || content.includes('transfer') || 
              content.includes('drain') || content.includes('migrate')) {
            findings.push({
              id: 'SOL241',
              severity: 'high',
              title: 'Single Admin Can Withdraw',
              description: 'Single admin key can withdraw funds. Insider threats (like Pump.fun) exploit single points of failure.',
              location: `Function: ${fn.name}`,
              recommendation: 'Require multi-sig (2/3 or 3/5) for all withdrawal operations. Implement timelocks.',
            });
          }
        }
      }

      // Check for flash loan protection bypass potential
      if (content.includes('flash_loan') || content.includes('borrow')) {
        if (content.includes('fee') && !content.includes('protocol_fee') && !content.includes('immutable')) {
          findings.push({
            id: 'SOL241',
            severity: 'medium',
            title: 'Modifiable Flash Loan Fee',
            description: 'Flash loan fee can be modified. Insider could set fee to zero to enable exploitation.',
            location: `Function: ${fn.name}`,
            recommendation: 'Make protocol fees immutable or require timelock + governance to change.',
          });
        }
      }

      // Check for privileged operations without timelock
      if (content.includes('set_') || content.includes('update_') || content.includes('change_')) {
        if (content.includes('admin') || content.includes('fee') || content.includes('param')) {
          if (!content.includes('timelock') && !content.includes('delay') && !content.includes('queue')) {
            findings.push({
              id: 'SOL241',
              severity: 'medium',
              title: 'Privileged Update Without Timelock',
              description: 'Admin can change parameters instantly. Timelocks give users time to react to malicious changes.',
              location: `Function: ${fn.name}`,
              recommendation: 'Add 24-48h timelock for parameter changes. Emit events for pending changes.',
            });
          }
        }
      }

      // Check for emergency functions
      if (content.includes('emergency') || content.includes('panic') || content.includes('circuit_break')) {
        if (!content.includes('multisig') && !content.includes('governance')) {
          findings.push({
            id: 'SOL241',
            severity: 'high',
            title: 'Emergency Function Without Multi-sig',
            description: 'Emergency functions can be triggered by single key. Could be abused by insider.',
            location: `Function: ${fn.name}`,
            recommendation: 'Require multi-sig for emergency functions, or implement auto-triggered circuit breakers.',
          });
        }
      }

      // Check for upgrade authority patterns
      if (content.includes('upgrade') || content.includes('migrate') || content.includes('set_program')) {
        if (!content.includes('governance') && !content.includes('dao') && !content.includes('vote')) {
          findings.push({
            id: 'SOL241',
            severity: 'high',
            title: 'Centralized Upgrade Authority',
            description: 'Program can be upgraded without governance. Malicious insider could deploy backdoored code.',
            location: `Function: ${fn.name}`,
            recommendation: 'Transfer upgrade authority to governance/DAO. Consider making program immutable after audit.',
          });
        }
      }

      // Check for fee recipient patterns
      if (content.includes('fee_recipient') || content.includes('treasury') || content.includes('protocol_wallet')) {
        if (!content.includes('const') && !content.includes('immutable') && !content.includes('governance')) {
          findings.push({
            id: 'SOL241',
            severity: 'medium',
            title: 'Mutable Fee Recipient',
            description: 'Fee recipient address can be changed. Insider could redirect fees to their wallet.',
            location: `Function: ${fn.name}`,
            recommendation: 'Make fee recipients immutable or require governance vote to change.',
          });
        }
      }

      // Check for bonding curve manipulation by insiders
      if (content.includes('bonding_curve') || content.includes('curve') && content.includes('price')) {
        if (content.includes('set_') || content.includes('update_')) {
          findings.push({
            id: 'SOL241',
            severity: 'high',
            title: 'Modifiable Bonding Curve',
            description: 'Bonding curve parameters can be modified. Pump.fun-style exploits manipulate curves for profit.',
            location: `Function: ${fn.name}`,
            recommendation: 'Lock bonding curve parameters after initialization. Use immutable math.',
          });
        }
      }

      // Check for key rotation without safeguards
      if (content.includes('rotate') || content.includes('new_authority') || content.includes('set_authority')) {
        if (!content.includes('delay') && !content.includes('timelock') && !content.includes('previous')) {
          findings.push({
            id: 'SOL241',
            severity: 'high',
            title: 'Instant Authority Rotation',
            description: 'Authority can be rotated instantly without delay or previous authority consent.',
            location: `Function: ${fn.name}`,
            recommendation: 'Add rotation delay. Require both old and new authority signatures during transition.',
          });
        }
      }
    }
  }

  if (idl) {
    // Check for dangerous privileged instructions
    const privilegedPatterns = ['admin', 'owner', 'upgrade', 'withdraw', 'emergency', 'migrate'];
    
    for (const instruction of idl.instructions) {
      const name = instruction.name.toLowerCase();
      const isPrivileged = privilegedPatterns.some(p => name.includes(p));
      
      if (isPrivileged) {
        // Check if multi-sig is required
        const hasMultisig = instruction.accounts.some(acc => 
          acc.name.toLowerCase().includes('multisig') ||
          acc.name.toLowerCase().includes('signer') && instruction.accounts.filter(a => 
            a.name.toLowerCase().includes('signer')
          ).length > 1
        );

        if (!hasMultisig) {
          findings.push({
            id: 'SOL241',
            severity: 'high',
            title: 'Privileged Instruction Without Multi-sig',
            description: `${instruction.name} is privileged but doesn't require multi-sig. Single insider could abuse.`,
            location: `Instruction: ${instruction.name}`,
            recommendation: 'Add multi-sig requirement for all privileged instructions.',
          });
        }
      }
    }
  }

  return findings;
}
