import type { Finding } from '../commands/audit.js';
import type { PatternInput } from './index.js';

/**
 * SOL301: Candy Machine Exploit Detection
 * Detects vulnerabilities in NFT minting machines
 * Real-world: Solens candy machine smashing exploit
 */
export function checkCandyMachineExploit(input: PatternInput): Finding[] {
  const findings: Finding[] = [];

  if (input.rust?.content) {
    const content = input.rust.content;
    const lines = content.split('\n');

    // Detect candy machine / minting patterns
    const isMintingProgram = /candy_machine|mint_nft|create_mint|nft_minter/i.test(content);

    if (isMintingProgram) {
      // Check for #[account(zero)] vs proper initialization
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Missing zero constraint on new accounts
        if (line.includes('#[account(') && line.includes('init') && !line.includes('zero')) {
          if (lines.slice(Math.max(0, i - 3), i + 3).some(l => /UncheckedAccount|AccountInfo/.test(l))) {
            findings.push({
              id: 'SOL301',
              title: 'Candy Machine Account Init Vulnerability',
              severity: 'critical',
              description: 'Account initialization without zero constraint allows pre-initialized account injection.',
              location: { file: input.path, line: i + 1 },
              suggestion: 'Use #[account(zero)] to ensure account is empty: #[account(init, payer = payer, space = 8 + CandyMachine::INIT_SPACE)]',
              cwe: 'CWE-665',
            });
            break;
          }
        }
      }

      // Check for config line validation
      if (content.includes('config_line') || content.includes('ConfigLine')) {
        if (!content.includes('validate_config') && !content.includes('check_config')) {
          findings.push({
            id: 'SOL301',
            title: 'Missing Config Line Validation',
            severity: 'high',
            description: 'Config lines must be validated before minting to prevent malicious metadata injection.',
            location: { file: input.path, line: 1 },
            suggestion: 'Add validation: validate_config_line(&config_line)?; before processing',
            cwe: 'CWE-20',
          });
        }
      }

      // Check for mint limit bypass
      if (content.includes('mint_limit') || content.includes('max_supply')) {
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes('mint_limit') && !lines.slice(i, i + 10).join('').includes('checked_')) {
            findings.push({
              id: 'SOL301',
              title: 'Mint Limit Bypass Risk',
              severity: 'high',
              description: 'Mint limits must be checked atomically with minting to prevent race conditions.',
              location: { file: input.path, line: i + 1 },
              suggestion: 'Use atomic check-and-increment: candy_machine.items_redeemed = candy_machine.items_redeemed.checked_add(1).ok_or(ErrorCode::MathOverflow)?',
              cwe: 'CWE-362',
            });
            break;
          }
        }
      }

      // Check for bot protection bypass
      if (!content.includes('bot_tax') && !content.includes('gatekeeper') && !content.includes('captcha')) {
        findings.push({
          id: 'SOL301',
          title: 'No Bot Protection',
          severity: 'medium',
          description: 'Candy machines without bot protection are vulnerable to automated minting attacks.',
          location: { file: input.path, line: 1 },
          suggestion: 'Add gatekeeper or bot tax: #[account(constraint = gatekeeper_network.check_gateway_token(&gateway_token))]',
          cwe: 'CWE-799',
        });
      }

      // Check for whitelist validation
      if (content.includes('whitelist') || content.includes('allowlist')) {
        if (!content.includes('merkle') && !content.includes('proof')) {
          findings.push({
            id: 'SOL301',
            title: 'Inefficient Whitelist Implementation',
            severity: 'medium',
            description: 'On-chain whitelists are expensive. Use Merkle proofs for gas-efficient validation.',
            location: { file: input.path, line: 1 },
            suggestion: 'Use Merkle tree: verify_proof(&proof, &root, &leaf)?',
            cwe: 'CWE-400',
          });
        }
      }
    }
  }

  return findings;
}
