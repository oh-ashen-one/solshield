import type { Finding } from '../commands/audit.js';
import type { PatternInput } from './index.js';

/**
 * SOL310: Exploit Chaining Detection
 * Detects combinations of minor issues that can be chained into critical exploits
 * Real-world: Schrodinger's NFT royal flush attack (samczsun methodology)
 */
export function checkExploitChaining(input: PatternInput): Finding[] {
  const findings: Finding[] = [];

  if (input.rust?.content) {
    const content = input.rust.content;
    const lines = content.split('\n');

    // Track individual weaknesses for chaining analysis
    const weaknesses: {
      type: string;
      line: number;
      severity: 'low' | 'medium';
    }[] = [];

    // Scan for individual low/medium issues
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Weakness 1: Unchecked account
      if (line.includes('UncheckedAccount') || line.includes('AccountInfo')) {
        if (!lines.slice(i, Math.min(i + 5, lines.length)).join('').includes('CHECK')) {
          weaknesses.push({ type: 'unchecked_account', line: i + 1, severity: 'low' });
        }
      }

      // Weakness 2: Missing constraint
      if (line.includes('#[account(') && !line.includes('constraint') && !line.includes('has_one')) {
        if (line.includes('mut')) {
          weaknesses.push({ type: 'missing_constraint', line: i + 1, severity: 'low' });
        }
      }

      // Weakness 3: External call without validation
      if (line.includes('invoke') && !line.includes('invoke_signed')) {
        weaknesses.push({ type: 'external_call', line: i + 1, severity: 'medium' });
      }

      // Weakness 4: State read without freshness check
      if (line.includes('.load()') || line.includes('.try_borrow')) {
        if (!lines.slice(Math.max(0, i - 3), i).join('').includes('reload')) {
          weaknesses.push({ type: 'stale_read', line: i + 1, severity: 'low' });
        }
      }

      // Weakness 5: Arithmetic without checks
      if ((line.includes(' + ') || line.includes(' - ') || line.includes(' * ')) && 
          !line.includes('checked_') && !line.includes('//')) {
        weaknesses.push({ type: 'unchecked_math', line: i + 1, severity: 'low' });
      }

      // Weakness 6: Missing owner check
      if (line.includes('token_account') || line.includes('TokenAccount')) {
        if (!lines.slice(i, Math.min(i + 5, lines.length)).join('').includes('owner')) {
          weaknesses.push({ type: 'missing_owner_check', line: i + 1, severity: 'medium' });
        }
      }
    }

    // Analyze for dangerous chains
    const chainPatterns = [
      {
        requires: ['unchecked_account', 'external_call'],
        name: 'Account Injection + CPI Chain',
        description: 'Unchecked accounts combined with external calls enable arbitrary CPI attacks.',
        severity: 'critical' as const,
      },
      {
        requires: ['missing_constraint', 'unchecked_math'],
        name: 'Constraint Bypass + Overflow Chain',
        description: 'Missing constraints combined with unchecked math can drain funds via overflow.',
        severity: 'critical' as const,
      },
      {
        requires: ['stale_read', 'external_call'],
        name: 'TOCTOU + External Call Chain',
        description: 'Stale state reads before external calls create time-of-check-time-of-use vulnerabilities.',
        severity: 'high' as const,
      },
      {
        requires: ['missing_owner_check', 'unchecked_account'],
        name: 'Ownership Confusion Chain',
        description: 'Missing owner checks with unchecked accounts allow using attacker-controlled accounts.',
        severity: 'critical' as const,
      },
      {
        requires: ['unchecked_math', 'external_call'],
        name: 'Overflow + CPI Drain Chain',
        description: 'Arithmetic overflow before CPI can cause over-transfer of funds.',
        severity: 'critical' as const,
      },
    ];

    // Check each chain pattern
    for (const chain of chainPatterns) {
      const matchedWeaknesses = chain.requires.map(req => 
        weaknesses.find(w => w.type === req)
      ).filter(Boolean);

      if (matchedWeaknesses.length === chain.requires.length) {
        findings.push({
          id: 'SOL310',
          title: chain.name,
          severity: chain.severity,
          description: `${chain.description} Found at lines: ${matchedWeaknesses.map(w => w?.line).join(', ')}`,
          location: { file: input.path, line: matchedWeaknesses[0]?.line || 1 },
          suggestion: 'Fix ALL weaknesses in this chain. Individual low-severity issues become critical when combined.',
          cwe: 'CWE-691',
        });
      }
    }

    // Report weakness density
    if (weaknesses.length >= 5) {
      findings.push({
        id: 'SOL310',
        title: 'High Weakness Density',
        severity: 'medium',
        description: `Found ${weaknesses.length} individual weaknesses. High density increases exploit chaining risk.`,
        location: { file: input.path, line: 1 },
        suggestion: 'Reduce attack surface by fixing all low-severity issues. Each is a potential chain link.',
        cwe: 'CWE-693',
      });
    }

    // Check for flash loan susceptibility (enables many chains)
    if (content.includes('transfer') && !content.includes('flash_loan_guard') && 
        !content.includes('same_slot') && !content.includes('reentrancy')) {
      if (weaknesses.length >= 2) {
        findings.push({
          id: 'SOL310',
          title: 'Flash Loan Chain Enabler',
          severity: 'high',
          description: 'Multiple weaknesses without flash loan protection creates amplified exploit potential.',
          location: { file: input.path, line: 1 },
          suggestion: 'Add flash loan protection: require!(ctx.accounts.clock.slot != last_interaction_slot, FlashLoanDetected)',
          cwe: 'CWE-362',
        });
      }
    }
  }

  return findings;
}
