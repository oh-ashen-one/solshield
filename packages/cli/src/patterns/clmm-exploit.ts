import type { Finding } from '../commands/audit.js';
import type { PatternInput } from './index.js';

/**
 * SOL140: CLMM/AMM Exploit
 * Detects concentrated liquidity and AMM vulnerabilities
 * Real-world: Crema Finance ($8.8M), Raydium ($4.4M)
 */
export function checkClmmExploit(input: PatternInput): Finding[] {
  const findings: Finding[] = [];

  if (input.rust?.content) {
    const content = input.rust.content;
    const lines = content.split('\n');

    // Check for CLMM/AMM patterns
    const ammPatterns = [
      /concentrated_liquidity|clmm/i,
      /liquidity_pool|amm|swap/i,
      /tick_array|position|range/i,
      /add_liquidity|remove_liquidity/i,
    ];

    const hasAmm = ammPatterns.some(p => p.test(content));

    if (hasAmm) {
      // Check for tick account validation
      if (content.includes('tick') && !content.includes('tick_array.load')) {
        findings.push({
          id: 'SOL140',
          title: 'Unvalidated Tick Array',
          severity: 'critical',
          description: 'Tick arrays must be properly validated to prevent fake tick injection.',
          location: { file: input.path, line: 1 },
          suggestion: 'Validate tick array: require!(tick_array.pool == pool.key(), InvalidTickArray)',
          cwe: 'CWE-345',
        });
      }

      // Check for fee account validation (Crema attack vector)
      if (content.includes('fee') && !content.includes('fee_account ==')) {
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].match(/collect.*fee|claim.*fee|fee.*transfer/i)) {
            findings.push({
              id: 'SOL140',
              title: 'Fee Account Validation Missing',
              severity: 'critical',
              description: 'Fee collection must validate the fee account to prevent theft.',
              location: { file: input.path, line: i + 1 },
              suggestion: 'Validate fee account: require!(fee_account.key() == pool.fee_account, InvalidFeeAccount)',
              cwe: 'CWE-284',
            });
            break;
          }
        }
      }

      // Check for price impact limits
      if (content.includes('swap') && !content.includes('slippage') && !content.includes('price_limit')) {
        findings.push({
          id: 'SOL140',
          title: 'No Price Impact Protection',
          severity: 'high',
          description: 'Swaps should have slippage/price impact limits to protect users.',
          location: { file: input.path, line: 1 },
          suggestion: 'Add slippage protection: require!(actual_price <= expected_price * (1 + slippage), ExcessiveSlippage)',
          cwe: 'CWE-20',
        });
      }

      // Check for flash loan callback validation
      if (content.includes('flash') && !content.includes('callback_data')) {
        findings.push({
          id: 'SOL140',
          title: 'Flash Loan Callback Unvalidated',
          severity: 'critical',
          description: 'Flash loan operations must validate callback data integrity.',
          location: { file: input.path, line: 1 },
          suggestion: 'Validate callback: require!(callback_data.initiator == expected_caller, InvalidCallback)',
          cwe: 'CWE-345',
        });
      }

      // Check for position NFT validation
      if (content.includes('position') && content.includes('nft')) {
        if (!content.includes('position.mint') && !content.includes('nft_mint')) {
          findings.push({
            id: 'SOL140',
            title: 'Position NFT Not Validated',
            severity: 'high',
            description: 'LP position NFTs must be validated to ensure ownership of liquidity.',
            location: { file: input.path, line: 1 },
            suggestion: 'Validate position NFT: require!(position.nft_mint == nft_account.mint, InvalidPositionNFT)',
            cwe: 'CWE-284',
          });
        }
      }
    }
  }

  return findings;
}
