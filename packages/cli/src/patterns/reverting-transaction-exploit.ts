import type { Finding } from '../commands/audit.js';
import type { ParsedRust } from '../parsers/rust.js';

/**
 * Reverting Transaction Exploit Detection
 * Based on: Cope Roulette exploit pattern
 * 
 * Attackers can exploit transaction reverting to gain unfair advantages
 * in gambling/lottery programs by repeatedly trying until they win.
 * 
 * Attack pattern:
 * 1. Start transaction
 * 2. Execute action (e.g., spin roulette)
 * 3. Check result
 * 4. If unfavorable, intentionally fail transaction (revert)
 * 5. Repeat until favorable outcome
 */
export function checkRevertingTransactionExploit(parsed: ParsedRust): Finding[] {
  const findings: Finding[] = [];
  const content = parsed.content;

  // Detect gambling/lottery patterns vulnerable to revert exploitation
  const gamblingPatterns = [
    /random.*?result|lottery|roulette|spin|bet|wager|gamble/gi,
    /clock.*?slot.*?as.*?seed|timestamp.*?random/gi,
    /invoke_signed.*?transfer.*?prize|payout.*?winner/gi,
  ];

  for (const pattern of gamblingPatterns) {
    const matches = content.match(pattern);
    if (matches) {
      // Check if there's commit-reveal scheme
      const hasCommitReveal = /commit.*?reveal|reveal.*?after.*?commit|two.*?phase/i.test(content);
      const hasVRF = /vrf|verifiable.*?random|switchboard.*?vrf|chainlink.*?vrf/i.test(content);
      const hasSlotCommitment = /slot.*?commitment|committed.*?slot/i.test(content);

      if (!hasCommitReveal && !hasVRF && !hasSlotCommitment) {
        findings.push({
          severity: 'critical',
          category: 'reverting-transaction',
          title: 'Gambling Logic Vulnerable to Transaction Revert Exploitation',
          description: `Detected gambling/lottery pattern "${matches[0]}" without commit-reveal scheme or VRF. ` +
            'Attackers can revert unfavorable transactions and retry until they win.',
          recommendation: 'Implement commit-reveal scheme: user commits to choice in one transaction, ' +
            'random result generated in next transaction after commitment. ' +
            'Alternatively, use Switchboard VRF for tamper-proof randomness.',
          location: parsed.path,
        });
      }
    }
  }

  // Detect single-transaction randomness patterns
  const singleTxRandom = [
    /clock::get\(\).*?slot.*?transfer/s,
    /recent_slothashes.*?payout/s,
    /random.*?same.*?instruction|instant.*?payout/gi,
  ];

  for (const pattern of singleTxRandom) {
    if (pattern.test(content)) {
      findings.push({
        severity: 'high',
        category: 'reverting-transaction',
        title: 'Single-Transaction Randomness with Payout',
        description: 'Randomness generation and payout occur in the same transaction, ' +
          'allowing attackers to simulate transactions and only broadcast winning ones.',
        recommendation: 'Separate randomness commitment from payout into different transactions. ' +
          'Use delay between commit and reveal phases.',
        location: parsed.path,
      });
    }
  }

  // Check for simulation detection bypass
  if (/simulate|preflight/i.test(content) && !/simulation.*?detected|reject.*?simulation/i.test(content)) {
    const hasRandomnessPayouts = /random|prize|payout|winner/i.test(content);
    if (hasRandomnessPayouts) {
      findings.push({
        severity: 'medium',
        category: 'reverting-transaction',
        title: 'Missing Simulation Detection for Randomness Operations',
        description: 'Programs with randomness-based payouts should detect and reject simulated transactions ' +
          'to prevent attackers from previewing outcomes.',
        recommendation: 'Add simulation detection or use commit-reveal pattern to prevent preview attacks.',
        location: parsed.path,
      });
    }
  }

  return findings;
}
