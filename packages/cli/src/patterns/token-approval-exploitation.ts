import type { Finding } from '../commands/audit.js';
import type { ParsedRust } from '../parsers/rust.js';

/**
 * Token Approval Exploitation Patterns
 * Based on: SPL Token Approve instruction vulnerabilities
 * 
 * Token approvals can be exploited in several ways:
 * 1. Approval not revoked after use
 * 2. Unlimited approval amounts
 * 3. Approval to malicious delegates
 * 4. Front-running approval transactions
 */
export function checkTokenApprovalExploitation(parsed: ParsedRust): Finding[] {
  const findings: Finding[] = [];
  const content = parsed.content;

  // Detect approve without corresponding revoke
  const approvePattern = /token::approve|Approve\s*\{|approve_checked|spl_token.*?approve/gi;
  const revokePattern = /token::revoke|Revoke\s*\{|revoke_checked|spl_token.*?revoke/gi;

  const approveMatches = content.match(approvePattern) || [];
  const revokeMatches = content.match(revokePattern) || [];

  if (approveMatches.length > 0 && revokeMatches.length === 0) {
    findings.push({
      severity: 'high',
      category: 'token-approval',
      title: 'Token Approval Without Corresponding Revoke',
      description: 'Token approval is set but never explicitly revoked. ' +
        'Delegates retain spending power indefinitely, creating permanent risk.',
      recommendation: 'Always revoke approval after the intended operation completes. ' +
        'Consider using one-time approval patterns with immediate revocation.',
      location: parsed.path,
    });
  }

  // Detect unlimited approval amounts (u64::MAX)
  const unlimitedApproval = /approve.*?u64::MAX|approve.*?18446744073709551615|unlimited.*?approval/gi;
  if (unlimitedApproval.test(content)) {
    findings.push({
      severity: 'critical',
      category: 'token-approval',
      title: 'Unlimited Token Approval Amount',
      description: 'Approving u64::MAX tokens creates severe risk. ' +
        'If delegate is compromised, entire token balance can be drained.',
      recommendation: 'Approve only the exact amount needed for the operation. ' +
        'Implement incremental approval patterns for recurring operations.',
      location: parsed.path,
    });
  }

  // Detect approval without delegate validation
  const approvalWithoutValidation = /approve\s*\{[^}]*delegate[^}]*\}/s;
  if (approvalWithoutValidation.test(content)) {
    const hasValidation = /constraint\s*=.*?delegate|delegate.*?==|verify.*?delegate/i.test(content);
    if (!hasValidation) {
      findings.push({
        severity: 'high',
        category: 'token-approval',
        title: 'Token Approval Delegate Not Validated',
        description: 'Approval delegate address is not validated against expected program or authority. ' +
          'Attackers could approve tokens to malicious addresses.',
        recommendation: 'Validate delegate address against whitelist or expected program addresses. ' +
          'Consider requiring multi-sig approval for delegate changes.',
        location: parsed.path,
      });
    }
  }

  // Detect approval in CPIs (potential for malicious delegate injection)
  if (/invoke.*?approve|CpiContext.*?approve/i.test(content)) {
    findings.push({
      severity: 'medium',
      category: 'token-approval',
      title: 'Token Approval in CPI Context',
      description: 'Token approval occurring in CPI context. ' +
        'Ensure invoked program cannot manipulate delegate address.',
      recommendation: 'Verify delegate address after CPI returns. ' +
        'Consider approving before CPI and revoking after.',
      location: parsed.path,
    });
  }

  // Detect missing approval amount checks
  if (/approve.*?amount/i.test(content) && !/amount\s*[<>=]/i.test(content)) {
    findings.push({
      severity: 'medium',
      category: 'token-approval',
      title: 'Approval Amount Not Bounded',
      description: 'Token approval amount is not checked against reasonable bounds. ' +
        'Large approvals increase risk if delegate is compromised.',
      recommendation: 'Implement maximum approval limits. ' +
        'Consider time-bound approvals that expire automatically.',
      location: parsed.path,
    });
  }

  return findings;
}
