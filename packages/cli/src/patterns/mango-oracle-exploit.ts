import type { Finding } from '../commands/audit.js';
import type { ParsedIdl } from '../parsers/idl.js';
import type { ParsedRust } from '../parsers/rust.js';

/**
 * SOL239: Mango Markets-style Oracle Exploitation
 * Detects oracle manipulation patterns used in the $116M Mango Markets exploit
 * Reference: Mango Markets hack (October 2022) - Avraham Eisenberg
 */
export function checkMangoOracleExploit(idl: ParsedIdl | null, rust: ParsedRust | null): Finding[] {
  const findings: Finding[] = [];

  if (rust) {
    for (const fn of rust.functions) {
      const content = fn.body.toLowerCase();

      // Check for single-source oracle pricing
      if (content.includes('oracle') || content.includes('price')) {
        if (!content.includes('median') && !content.includes('aggregate') && !content.includes('multiple')) {
          if (content.includes('borrow') || content.includes('collateral') || content.includes('leverage')) {
            findings.push({
              id: 'SOL239',
              severity: 'critical',
              title: 'Single-Source Oracle for Lending',
              description: 'Lending/borrowing uses single oracle source. Mango-style attacks manipulate one market to inflate collateral value.',
              location: `Function: ${fn.name}`,
              recommendation: 'Aggregate prices from multiple oracles (Pyth, Switchboard, DEX TWAPs). Use median to resist manipulation.',
            });
          }
        }
      }

      // Check for unrestricted position sizing
      if (content.includes('position') || content.includes('perp')) {
        if (!content.includes('max_position') && !content.includes('limit') && !content.includes('cap')) {
          if (content.includes('leverage') || content.includes('margin')) {
            findings.push({
              id: 'SOL239',
              severity: 'high',
              title: 'Unbounded Position Size',
              description: 'No position size limits detected. Attackers can build massive leveraged positions to manipulate markets.',
              location: `Function: ${fn.name}`,
              recommendation: 'Implement position size limits relative to market liquidity and open interest.',
            });
          }
        }
      }

      // Check for self-trading/wash trading
      if (content.includes('order') || content.includes('trade')) {
        if (!content.includes('self_trade') && !content.includes('wash_trade') && !content.includes('same_owner')) {
          findings.push({
            id: 'SOL239',
            severity: 'medium',
            title: 'No Self-Trade Prevention',
            description: 'No self-trade prevention detected. Attackers can wash trade to manipulate prices.',
            location: `Function: ${fn.name}`,
            recommendation: 'Implement self-trade prevention: reject orders that would match against same owner.',
          });
        }
      }

      // Check for instant collateral value updates
      if (content.includes('collateral') || content.includes('equity')) {
        if (content.includes('price') && !content.includes('delay') && !content.includes('twap')) {
          findings.push({
            id: 'SOL239',
            severity: 'high',
            title: 'Instant Collateral Valuation',
            description: 'Collateral valued at spot price without delay. Attackers can inflate collateral value and borrow against it instantly.',
            location: `Function: ${fn.name}`,
            recommendation: 'Use time-weighted collateral values. Add delay between price updates and borrowing capacity changes.',
          });
        }
      }

      // Check for unrestricted withdrawal after borrowing
      if (content.includes('withdraw') || content.includes('transfer_out')) {
        if (content.includes('borrow') || content.includes('loan')) {
          if (!content.includes('cooldown') && !content.includes('delay') && !content.includes('timelock')) {
            findings.push({
              id: 'SOL239',
              severity: 'high',
              title: 'Immediate Withdrawal After Borrowing',
              description: 'Borrowed funds can be withdrawn immediately. Attacker can manipulate price, borrow, withdraw, then let price crash.',
              location: `Function: ${fn.name}`,
              recommendation: 'Add withdrawal cooldown after borrowing. Consider requiring collateral to remain locked for a period.',
            });
          }
        }
      }

      // Check for perpetual funding rate manipulation
      if (content.includes('funding') || content.includes('funding_rate')) {
        if (!content.includes('cap') && !content.includes('max_rate') && !content.includes('limit')) {
          findings.push({
            id: 'SOL239',
            severity: 'medium',
            title: 'Unbounded Funding Rate',
            description: 'Funding rate has no cap. Attackers can create extreme rate imbalances through position manipulation.',
            location: `Function: ${fn.name}`,
            recommendation: 'Cap funding rates. Add circuit breakers for extreme rate changes.',
          });
        }
      }

      // Check for unrestricted leverage
      if (content.includes('leverage') || content.includes('margin_ratio')) {
        if (content.match(/leverage\s*[=<>]\s*\d{2,}/) || content.includes('100x') || content.includes('50x')) {
          findings.push({
            id: 'SOL239',
            severity: 'high',
            title: 'Extreme Leverage Allowed',
            description: 'Very high leverage (>20x) detected. High leverage amplifies oracle manipulation attacks.',
            location: `Function: ${fn.name}`,
            recommendation: 'Limit maximum leverage based on asset liquidity and oracle reliability.',
          });
        }
      }

      // Check for insurance fund drainage
      if (content.includes('insurance') || content.includes('insurance_fund')) {
        if (!content.includes('cap') && !content.includes('limit') && !content.includes('max_claim')) {
          findings.push({
            id: 'SOL239',
            severity: 'high',
            title: 'Unrestricted Insurance Claims',
            description: 'Insurance fund has no per-claim limits. A single exploit could drain the entire fund.',
            location: `Function: ${fn.name}`,
            recommendation: 'Cap single claims as percentage of insurance fund. Implement claim review delays.',
          });
        }
      }
    }
  }

  if (idl) {
    // Check for leverage/margin instructions
    for (const instruction of idl.instructions) {
      const name = instruction.name.toLowerCase();
      
      if (name.includes('leverage') || name.includes('borrow') || name.includes('margin')) {
        // Check for oracle account
        const hasOracle = instruction.accounts.some(acc => 
          acc.name.toLowerCase().includes('oracle') ||
          acc.name.toLowerCase().includes('price')
        );
        
        const hasMultipleOracles = instruction.accounts.filter(acc => 
          acc.name.toLowerCase().includes('oracle')
        ).length > 1;

        if (hasOracle && !hasMultipleOracles) {
          findings.push({
            id: 'SOL239',
            severity: 'high',
            title: 'Single Oracle in Leveraged Instruction',
            description: `${instruction.name} uses single oracle. Multi-oracle aggregation needed for manipulation resistance.`,
            location: `Instruction: ${instruction.name}`,
            recommendation: 'Add multiple oracle accounts and aggregate their prices.',
          });
        }
      }
    }
  }

  return findings;
}
