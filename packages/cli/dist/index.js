#!/usr/bin/env node

// src/index.ts
import { Command } from "commander";

// src/parsers/rust.ts
import { readFileSync } from "fs";
async function parseRustFiles(filePaths) {
  const files = [];
  const functions = [];
  const structs = [];
  const implBlocks = [];
  let allContent = "";
  for (const filePath of filePaths) {
    try {
      const content = readFileSync(filePath, "utf-8");
      const lines = content.split("\n");
      allContent += content + "\n";
      files.push({ path: filePath, content, lines });
      const funcRegex = /(?:pub\s+)?fn\s+(\w+)\s*\(([^)]*)\)/g;
      let match;
      while ((match = funcRegex.exec(content)) !== null) {
        const lineNum = content.substring(0, match.index).split("\n").length;
        functions.push({
          name: match[1],
          file: filePath,
          line: lineNum,
          visibility: match[0].includes("pub") ? "public" : "private",
          params: match[2].split(",").map((p) => p.trim()).filter(Boolean),
          body: extractFunctionBody(content, match.index)
        });
      }
      const structRegex = /((?:#\[[^\]]+\]\s*)*)?(?:pub\s+)?struct\s+(\w+)/g;
      while ((match = structRegex.exec(content)) !== null) {
        const lineNum = content.substring(0, match.index).split("\n").length;
        structs.push({
          name: match[2],
          file: filePath,
          line: lineNum,
          fields: extractStructFields(content, match.index),
          attributes: match[1] ? match[1].split("#").filter(Boolean).map((a) => "#" + a.trim()) : []
        });
      }
      const implRegex = /impl(?:\s*<[^>]*>)?\s+(\w+)/g;
      while ((match = implRegex.exec(content)) !== null) {
        const lineNum = content.substring(0, match.index).split("\n").length;
        implBlocks.push({
          name: match[1],
          file: filePath,
          line: lineNum,
          methods: extractImplMethods(content, match.index)
        });
      }
    } catch (error) {
      console.warn(`Failed to parse ${filePath}: ${error}`);
    }
  }
  return {
    files,
    functions,
    structs,
    implBlocks,
    content: allContent,
    filePath: filePaths[0] || ""
  };
}
function extractFunctionBody(content, startIndex) {
  let braceCount = 0;
  let started = false;
  let bodyStart = startIndex;
  for (let i = startIndex; i < content.length; i++) {
    if (content[i] === "{") {
      if (!started) {
        started = true;
        bodyStart = i;
      }
      braceCount++;
    } else if (content[i] === "}") {
      braceCount--;
      if (started && braceCount === 0) {
        return content.substring(bodyStart, i + 1);
      }
    }
  }
  return "";
}
function extractStructFields(content, startIndex) {
  const fields = [];
  let braceCount = 0;
  let started = false;
  let fieldSection = "";
  for (let i = startIndex; i < content.length; i++) {
    if (content[i] === "{") {
      started = true;
      braceCount++;
    } else if (content[i] === "}") {
      braceCount--;
      if (started && braceCount === 0) {
        break;
      }
    } else if (started && braceCount === 1) {
      fieldSection += content[i];
    }
  }
  const fieldRegex = /(?:pub\s+)?(\w+)\s*:\s*([^,}]+)/g;
  let match;
  while ((match = fieldRegex.exec(fieldSection)) !== null) {
    fields.push({ name: match[1], type: match[2].trim() });
  }
  return fields;
}
function extractImplMethods(content, startIndex) {
  const methods = [];
  let braceCount = 0;
  let started = false;
  let implBlock = "";
  for (let i = startIndex; i < content.length; i++) {
    if (content[i] === "{") {
      started = true;
      braceCount++;
    } else if (content[i] === "}") {
      braceCount--;
      if (started && braceCount === 0) {
        break;
      }
    }
    if (started) {
      implBlock += content[i];
    }
  }
  const methodRegex = /(?:pub\s+)?fn\s+(\w+)/g;
  let match;
  while ((match = methodRegex.exec(implBlock)) !== null) {
    methods.push(match[1]);
  }
  return methods;
}

// src/patterns/sec3-2025-business-logic.ts
function checkSec32025BusinessLogic(input) {
  const findings = [];
  if (input.rust?.content) {
    const content = input.rust.content;
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const context = lines.slice(Math.max(0, i - 5), Math.min(lines.length, i + 10)).join("\n");
      if ((line.includes("state =") || line.includes("status =")) && line.includes("::") && !context.includes("require!") && !context.includes("assert!") && !context.includes("match state")) {
        findings.push({
          id: "SEC3-BL001",
          title: "State Transition Without Validation",
          severity: "high",
          description: "State changes without validating allowed transitions. Attackers can skip intermediate states.",
          location: { file: input.path, line: i + 1 },
          suggestion: "Add state machine validation: require!(current_state == AllowedPreviousState, InvalidTransition)",
          cwe: "CWE-840"
        });
      }
      if ((line.includes("/ 100") || line.includes("/ 10000") || line.includes("/ 10_000")) && !line.includes("checked_")) {
        if (!context.includes("saturating") && !context.includes("checked_div")) {
          findings.push({
            id: "SEC3-BL002",
            title: "Percentage Calculation Without Safe Math",
            severity: "medium",
            description: "Percentage/basis point calculations should use checked math to prevent rounding exploits.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Use checked_mul then checked_div, or dedicated percentage math library.",
            cwe: "CWE-682"
          });
        }
      }
      if (line.includes("pub fn process_order") || line.includes("fn execute_order") || line.includes("fn fill_order")) {
        if (!context.includes("expired") && !context.includes("expiry") && !context.includes("deadline")) {
          findings.push({
            id: "SEC3-BL003",
            title: "Order Processing Without Expiry Check",
            severity: "high",
            description: "Order execution without expiry validation allows stale order exploitation.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Always check: require!(order.expiry > clock.unix_timestamp, OrderExpired)",
            cwe: "CWE-613"
          });
        }
      }
      if ((line.includes("pub fn withdraw") || line.includes("fn withdraw")) && !line.includes("//")) {
        if (!context.includes("cooldown") && !context.includes("lock_") && !context.includes("timelock") && !context.includes("unlock_time")) {
          findings.push({
            id: "SEC3-BL004",
            title: "Withdrawal Without Timelock Check",
            severity: "medium",
            description: "Withdrawal function without timelock/cooldown validation.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Consider adding withdrawal cooldowns: require!(clock.unix_timestamp > user.last_deposit + COOLDOWN)",
            cwe: "CWE-362"
          });
        }
      }
      if ((line.includes("reward") || line.includes("yield")) && (line.includes(" * ") || line.includes(" / "))) {
        if (!context.includes("last_update") && !context.includes("accumulated") && !context.includes("per_share")) {
          findings.push({
            id: "SEC3-BL005",
            title: "Reward Calculation Without Time Normalization",
            severity: "high",
            description: "Reward calculations should track time since last update to prevent manipulation.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Track rewards_per_share and last_update_timestamp for correct distribution.",
            cwe: "CWE-682"
          });
        }
      }
      if (line.includes("liquidat") && !line.includes("//")) {
        if (!context.includes("health_factor") && !context.includes("collateral_ratio") && !context.includes("ltv") && !context.includes("margin")) {
          findings.push({
            id: "SEC3-BL006",
            title: "Liquidation Without Health Factor",
            severity: "critical",
            description: "Liquidation logic without clear health factor calculation is exploitable.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Always compute health_factor = collateral_value * ltv / debt_value",
            cwe: "CWE-682"
          });
        }
      }
      if (line.includes("fee") && (line.includes(" = 0") || line.includes("= 0u"))) {
        findings.push({
          id: "SEC3-BL007",
          title: "Fee Set to Zero Detected",
          severity: "medium",
          description: "Hardcoded zero fee may indicate missing fee logic or potential bypass.",
          location: { file: input.path, line: i + 1 },
          suggestion: "Ensure fees cannot be bypassed. Consider minimum fee requirements.",
          cwe: "CWE-20"
        });
      }
      if ((line.includes("vote_weight") || line.includes("voting_power")) && !line.includes("//")) {
        if (!context.includes("snapshot") && !context.includes("checkpoint") && !context.includes("lock_time")) {
          findings.push({
            id: "SEC3-BL008",
            title: "Vote Weight Without Snapshot",
            severity: "high",
            description: "Voting power calculations without snapshots enable flash loan governance attacks.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Use snapshot-based voting: vote_weight = get_weight_at_snapshot(proposal.snapshot_slot)",
            cwe: "CWE-362"
          });
        }
      }
      if ((line.includes("pub fn stake") || line.includes("pub fn unstake")) && !line.includes("//")) {
        if (!context.includes("epoch") && !context.includes("warmup") && !context.includes("cooldown")) {
          findings.push({
            id: "SEC3-BL009",
            title: "Staking Without Epoch Boundaries",
            severity: "medium",
            description: "Stake/unstake without epoch boundaries allows reward gaming.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Align staking changes with epoch boundaries or add warmup/cooldown periods.",
            cwe: "CWE-682"
          });
        }
      }
      if ((line.includes("open_position") || line.includes("increase_position")) && !line.includes("//")) {
        if (!context.includes("max_position") && !context.includes("position_limit") && !context.includes("max_size")) {
          findings.push({
            id: "SEC3-BL010",
            title: "Position Opening Without Size Limits",
            severity: "high",
            description: "Trading positions without size limits can destabilize the protocol.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Enforce position limits: require!(new_size <= max_position_size, PositionTooLarge)",
            cwe: "CWE-770"
          });
        }
      }
    }
  }
  return findings;
}

// src/patterns/sec3-2025-input-validation.ts
function checkSec32025InputValidation(input) {
  const findings = [];
  if (input.rust?.content) {
    const content = input.rust.content;
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const context = lines.slice(Math.max(0, i - 5), Math.min(lines.length, i + 10)).join("\n");
      if (line.includes("instruction_data") || line.includes("data: &[u8]")) {
        if (!context.includes(".len()") && !context.includes("size_of")) {
          findings.push({
            id: "SEC3-IV001",
            title: "Instruction Data Size Not Validated",
            severity: "high",
            description: "Instruction data should have size validation before deserialization.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Check: require!(data.len() >= MIN_SIZE && data.len() <= MAX_SIZE, InvalidDataLength)",
            cwe: "CWE-20"
          });
        }
      }
      if ((line.includes("String") || line.includes("Vec<u8>")) && line.includes("pub ") && !line.includes("//")) {
        if (!context.includes("max_len") && !context.includes("MAX_") && !context.includes("#[max_len")) {
          findings.push({
            id: "SEC3-IV002",
            title: "Unbounded String/Bytes Field",
            severity: "medium",
            description: "String or byte vector without maximum length constraint can cause DoS.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add Anchor constraint: #[max_len(256)] or validate length manually.",
            cwe: "CWE-400"
          });
        }
      }
      if ((line.includes("amount") || line.includes("quantity") || line.includes("price")) && line.includes(": u") && !line.includes("//")) {
        if (!context.includes("> 0") && !context.includes("!= 0") && !context.includes("require!") && !context.includes("assert!")) {
          findings.push({
            id: "SEC3-IV003",
            title: "Numeric Input Without Range Validation",
            severity: "medium",
            description: "Numeric inputs should be validated for acceptable ranges.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add validation: require!(amount > 0 && amount <= MAX_AMOUNT, InvalidAmount)",
            cwe: "CWE-20"
          });
        }
      }
      if ((line.includes("timestamp") || line.includes("expiry") || line.includes("deadline")) && !line.includes("clock.unix_timestamp")) {
        if (line.includes(": i64") || line.includes(": u64")) {
          findings.push({
            id: "SEC3-IV004",
            title: "Timestamp Input Not Clock-Validated",
            severity: "high",
            description: "User-provided timestamps should be validated against on-chain clock.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Compare to clock: require!(timestamp > clock.unix_timestamp, TimestampInPast)",
            cwe: "CWE-20"
          });
        }
      }
      if (line.includes("Vec<Pubkey>") && !context.includes("max_len") && !context.includes("MAX_")) {
        findings.push({
          id: "SEC3-IV005",
          title: "Unbounded Pubkey Array",
          severity: "medium",
          description: "Arrays of pubkeys without bounds can cause compute exhaustion.",
          location: { file: input.path, line: i + 1 },
          suggestion: "Limit array size: require!(accounts.len() <= MAX_ACCOUNTS, TooManyAccounts)",
          cwe: "CWE-400"
        });
      }
      if (line.includes("decimals") && (line.includes("9") || line.includes("6"))) {
        if (!context.includes("mint.decimals") && !context.includes(".decimals")) {
          findings.push({
            id: "SEC3-IV006",
            title: "Hardcoded Decimal Assumption",
            severity: "high",
            description: "Hardcoded decimal values instead of reading from mint. Different tokens have different decimals.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Always read decimals from mint account: let decimals = ctx.accounts.mint.decimals;",
            cwe: "CWE-682"
          });
        }
      }
      if (line.includes("seeds") && line.includes("&[")) {
        if (context.includes("as &[u8]") && !context.includes("validate") && !context.includes(".len()")) {
          findings.push({
            id: "SEC3-IV007",
            title: "PDA Seed Input Not Sanitized",
            severity: "high",
            description: "User-provided PDA seeds should be length-validated to prevent collision attacks.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Validate seed length: require!(seed.len() <= 32, SeedTooLong)",
            cwe: "CWE-20"
          });
        }
      }
      if (line.includes("as u8") && context.includes("enum") && !context.includes("TryFrom")) {
        findings.push({
          id: "SEC3-IV008",
          title: "Enum Cast Without Bounds Check",
          severity: "medium",
          description: "Casting integers to enums should use TryFrom to validate variants.",
          location: { file: input.path, line: i + 1 },
          suggestion: "Use TryFrom: let variant = MyEnum::try_from(value).map_err(|_| InvalidVariant)?;",
          cwe: "CWE-20"
        });
      }
      if ((line.includes("try_from_slice") || line.includes("deserialize")) && !context.includes(".len()") && !context.includes("size_of")) {
        findings.push({
          id: "SEC3-IV009",
          title: "Deserialization Without Size Validation",
          severity: "high",
          description: "Deserializing account data without size check can cause panics or read garbage.",
          location: { file: input.path, line: i + 1 },
          suggestion: "Check size before deserializing: require!(data.len() >= std::mem::size_of::<T>())",
          cwe: "CWE-502"
        });
      }
      if ((line.includes("slippage") || line.includes("min_out") || line.includes("max_in")) && !context.includes("require!") && !context.includes("assert!")) {
        findings.push({
          id: "SEC3-IV010",
          title: "Slippage Parameter Not Enforced",
          severity: "high",
          description: "Slippage parameters must be enforced to protect users from sandwich attacks.",
          location: { file: input.path, line: i + 1 },
          suggestion: "Enforce: require!(actual_output >= min_output, SlippageExceeded)",
          cwe: "CWE-20"
        });
      }
    }
  }
  return findings;
}

// src/patterns/sec3-2025-access-control.ts
function checkSec32025AccessControl(input) {
  const findings = [];
  if (input.rust?.content) {
    const content = input.rust.content;
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const context = lines.slice(Math.max(0, i - 5), Math.min(lines.length, i + 10)).join("\n");
      if ((line.includes("pub fn admin") || line.includes("pub fn set_") || line.includes("pub fn update_") || line.includes("pub fn pause")) && !line.includes("//")) {
        if (!context.includes("has_one") && !context.includes("constraint =") && !context.includes("authority") && !context.includes("admin")) {
          findings.push({
            id: "SEC3-AC001",
            title: "Admin Function Without Authority Constraint",
            severity: "critical",
            description: "Administrative function lacks authority validation.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add Anchor constraint: #[account(has_one = authority @ UnauthorizedAdmin)]",
            cwe: "CWE-862"
          });
        }
      }
      if ((line.includes("upgrade") || line.includes("withdraw_all") || line.includes("emergency") || line.includes("migrate")) && !line.includes("//")) {
        if (!context.includes("multisig") && !context.includes("multi_sig") && !context.includes("threshold") && !context.includes("signers")) {
          findings.push({
            id: "SEC3-AC002",
            title: "Critical Operation Without Multi-Sig",
            severity: "high",
            description: "Critical operations should require multi-signature authorization.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Implement multi-sig: require!(approved_signers >= threshold, InsufficientSigners)",
            cwe: "CWE-287"
          });
        }
      }
      if (line.includes("pub fn") && (line.includes("_admin") || line.includes("_operator") || line.includes("_manager"))) {
        if (!context.includes("role") && !context.includes("permission") && !context.includes("is_authorized")) {
          findings.push({
            id: "SEC3-AC003",
            title: "Role-Based Function Without Role Check",
            severity: "high",
            description: "Function implies role-based access but lacks explicit role verification.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Verify role: require!(user.role == Role::Admin, UnauthorizedRole)",
            cwe: "CWE-285"
          });
        }
      }
      if (line.includes("invoke") && !line.includes("invoke_signed")) {
        if (!context.includes("is_signer") && !context.includes("Signer<")) {
          findings.push({
            id: "SEC3-AC004",
            title: "CPI Without Signer Verification",
            severity: "high",
            description: "Cross-program invocation without verifying the signer authority.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Verify signer: require!(authority.is_signer, MissingSigner)",
            cwe: "CWE-863"
          });
        }
      }
      if (line.includes("delegate") && !line.includes("//")) {
        if (!context.includes("max_amount") && !context.includes("expiry") && !context.includes("allowed_operations")) {
          findings.push({
            id: "SEC3-AC005",
            title: "Delegation Without Scope Limits",
            severity: "medium",
            description: "Delegated authority should have amount limits and expiry.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Scope delegation: delegate.max_amount, delegate.expiry, delegate.allowed_ops",
            cwe: "CWE-269"
          });
        }
      }
      if ((line.includes("transfer_ownership") || line.includes("new_owner") || line.includes("pending_owner")) && !line.includes("//")) {
        if (!context.includes("accept_ownership") && !context.includes("confirm") && !context.includes("two_step")) {
          findings.push({
            id: "SEC3-AC006",
            title: "Ownership Transfer Without 2-Step Confirmation",
            severity: "high",
            description: "Ownership transfers should use 2-step process to prevent accidental loss.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Use pending_owner pattern: set_pending_owner() -> accept_ownership()",
            cwe: "CWE-269"
          });
        }
      }
      if ((line.includes("mint_authority") || line.includes("freeze_authority")) && !context.includes("PDA") && !context.includes("find_program_address") && !context.includes("seeds")) {
        findings.push({
          id: "SEC3-AC007",
          title: "Token Authority Not PDA",
          severity: "medium",
          description: "Token authorities should be PDAs for programmatic control.",
          location: { file: input.path, line: i + 1 },
          suggestion: 'Derive authority from PDA: seeds = [b"mint_authority", mint.key().as_ref()]',
          cwe: "CWE-269"
        });
      }
      if ((line.includes("pub fn crank") || line.includes("pub fn update_price") || line.includes("pub fn liquidate")) && !line.includes("//")) {
        if (!context.includes("reward") && !context.includes("fee") && !context.includes("incentive")) {
          findings.push({
            id: "SEC3-AC008",
            title: "Permissionless Crank Without Incentive",
            severity: "low",
            description: "Permissionless functions should incentivize crankers to ensure liveness.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add cranker rewards to incentivize timely execution.",
            cwe: "CWE-400"
          });
        }
      }
      if (line.includes("close =") || line.includes("close_account")) {
        if (!context.includes("authority") && !context.includes("has_one") && !context.includes("owner")) {
          findings.push({
            id: "SEC3-AC009",
            title: "Account Close Without Authority Check",
            severity: "critical",
            description: "Account closure must verify the closer has authority.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add constraint: #[account(close = authority, has_one = authority)]",
            cwe: "CWE-862"
          });
        }
      }
      if (line.includes("timelock") && !line.includes("//")) {
        if (!context.includes("min_delay") && !context.includes("MIN_DELAY") && !context.includes("TIMELOCK_DURATION")) {
          findings.push({
            id: "SEC3-AC010",
            title: "Timelock Without Minimum Delay",
            severity: "high",
            description: "Timelocks should have a minimum delay that cannot be bypassed.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Enforce minimum: require!(delay >= MIN_TIMELOCK_DELAY, DelayTooShort)",
            cwe: "CWE-269"
          });
        }
      }
    }
  }
  return findings;
}

// src/patterns/sec3-2025-data-integrity.ts
function checkSec32025DataIntegrity(input) {
  const findings = [];
  if (input.rust?.content) {
    const content = input.rust.content;
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const context = lines.slice(Math.max(0, i - 5), Math.min(lines.length, i + 10)).join("\n");
      if (line.includes(" / ") && !line.includes("//")) {
        if ((line.includes("u64") || line.includes("u128")) && !context.includes("checked_div") && !context.includes("saturating")) {
          if (line.includes(" * ") && line.indexOf(" / ") > line.indexOf(" * ")) {
            findings.push({
              id: "SEC3-DI001",
              title: "Division Before Multiplication",
              severity: "high",
              description: "Division before multiplication can cause precision loss. Always multiply first.",
              location: { file: input.path, line: i + 1 },
              suggestion: "Reorder: (a * b) / c instead of (a / c) * b",
              cwe: "CWE-682"
            });
          }
        }
      }
      if ((line.includes("as u64") || line.includes("as u128")) && (context.includes(" / ") || context.includes("div"))) {
        if (!context.includes("floor") && !context.includes("ceil") && !context.includes("round") && !context.includes("direction")) {
          findings.push({
            id: "SEC3-DI002",
            title: "Implicit Rounding Direction",
            severity: "medium",
            description: "Integer division implicitly floors. Specify rounding direction explicitly.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Use explicit rounding: floor for protocol benefit, ceil for user protection.",
            cwe: "CWE-682"
          });
        }
      }
      if ((line.includes(".save()") || line.includes("serialize")) && !line.includes("//")) {
        if (!context.includes("atomic") && !context.includes("transaction") && !context.includes("all_or_nothing")) {
          const stateUpdates = (context.match(/\.\s*\w+\s*=/g) || []).length;
          if (stateUpdates >= 3) {
            findings.push({
              id: "SEC3-DI003",
              title: "Non-Atomic Multi-State Update",
              severity: "high",
              description: "Multiple state updates without atomic transaction can leave inconsistent state on failure.",
              location: { file: input.path, line: i + 1 },
              suggestion: "Group related state changes atomically. Consider using a state machine.",
              cwe: "CWE-362"
            });
          }
        }
      }
      if ((line.includes("shares") || line.includes("share_price")) && (line.includes(" / ") || line.includes(" * "))) {
        if (!context.includes("virtual") && !context.includes("OFFSET") && !context.includes("MIN_DEPOSIT")) {
          findings.push({
            id: "SEC3-DI004",
            title: "Share Calculation Without Inflation Protection",
            severity: "critical",
            description: "Share calculations without virtual offset are vulnerable to first-depositor inflation attack.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add virtual shares offset: shares = (deposit + 1) * TOTAL_SHARES / (totalAssets + 1)",
            cwe: "CWE-682"
          });
        }
      }
      if (line.includes("other_account") || line.includes("related_account")) {
        if (!context.includes("reload") && !context.includes("refresh") && !context.includes("re-fetch")) {
          findings.push({
            id: "SEC3-DI005",
            title: "Cross-Account Data Without Refresh",
            severity: "medium",
            description: "Reading from related accounts without refresh may use stale data.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Reload related account data: account.reload()?",
            cwe: "CWE-662"
          });
        }
      }
      if (line.includes("merkle") && (line.includes("verify") || line.includes("proof"))) {
        if (!context.includes("index") && !context.includes("leaf_index") && !context.includes("position")) {
          findings.push({
            id: "SEC3-DI006",
            title: "Merkle Proof Missing Index Validation",
            severity: "high",
            description: "Merkle proofs should verify the leaf index to prevent replay at different positions.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Include leaf index in hash: hash(index || leaf_data)",
            cwe: "CWE-354"
          });
        }
      }
      if ((line.includes("balance") || line.includes("amount")) && (line.includes("+=") || line.includes("-="))) {
        if (!context.includes("total") && !context.includes("sum") && !context.includes("invariant")) {
          findings.push({
            id: "SEC3-DI007",
            title: "Balance Update Without Invariant Check",
            severity: "high",
            description: "Balance updates should verify total invariants (sum of parts = whole).",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add invariant: require!(user_balances.sum() == total_balance, InvariantViolation)",
            cwe: "CWE-682"
          });
        }
      }
      if (line.includes("nonce") && (line.includes("+= 1") || line.includes("+ 1"))) {
        if (!context.includes("checked_add") && !context.includes("wrapping")) {
          findings.push({
            id: "SEC3-DI008",
            title: "Nonce Increment Without Overflow Check",
            severity: "medium",
            description: "Nonce increment should handle overflow (wrap or reject).",
            location: { file: input.path, line: i + 1 },
            suggestion: "Use: nonce = nonce.checked_add(1).ok_or(NonceOverflow)?",
            cwe: "CWE-190"
          });
        }
      }
      if ((line.includes("epoch") || line.includes("period")) && (line.includes(" / ") || line.includes("div"))) {
        if (!context.includes("boundary") && !context.includes("start_time") && !context.includes("end_time")) {
          findings.push({
            id: "SEC3-DI009",
            title: "Epoch Calculation Without Boundary Handling",
            severity: "medium",
            description: "Epoch calculations should handle boundary conditions explicitly.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Define epoch_start and epoch_end, handle edge cases at boundaries.",
            cwe: "CWE-682"
          });
        }
      }
      if (line.includes("10_u128.pow") || line.includes("10u128.pow") || line.includes("PRECISION") || line.includes("SCALE")) {
        if (!context.includes("DECIMALS") && !context.includes("decimal_places")) {
          findings.push({
            id: "SEC3-DI010",
            title: "Fixed-Point Math Without Decimal Tracking",
            severity: "medium",
            description: "Fixed-point operations should track decimal places to prevent precision errors.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Document precision: /// Price is stored with 6 decimal places (PRICE_DECIMALS = 6)",
            cwe: "CWE-682"
          });
        }
      }
    }
  }
  return findings;
}

// src/patterns/sec3-2025-dos-liveness.ts
function checkSec32025DosLiveness(input) {
  const findings = [];
  if (input.rust?.content) {
    const content = input.rust.content;
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const context = lines.slice(Math.max(0, i - 5), Math.min(lines.length, i + 10)).join("\n");
      if ((line.includes("for ") || line.includes(".iter()")) && !line.includes("// bounded") && !line.includes("// SAFETY")) {
        if (context.includes("Vec<") && !context.includes("MAX_") && !context.includes(".take(") && !context.includes("limit")) {
          findings.push({
            id: "SEC3-DOS001",
            title: "Unbounded Loop Over Dynamic Collection",
            severity: "high",
            description: "Iterating over unbounded collections can exhaust compute budget.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Bound iteration: for item in items.iter().take(MAX_ITEMS)",
            cwe: "CWE-400"
          });
        }
      }
      if ((line.includes("pub fn") || line.includes("fn process")) && !line.includes("//")) {
        if (content.includes("for ") && !content.includes("compute_budget") && !content.includes("ComputeBudget")) {
          findings.push({
            id: "SEC3-DOS002",
            title: "No Compute Budget Management",
            severity: "medium",
            description: "Complex operations should track compute budget to fail gracefully.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add early exit if running low on compute units.",
            cwe: "CWE-400"
          });
        }
      }
      if ((line.includes("while ") || line.includes("loop {")) && !context.includes("break") && !context.includes("return")) {
        if (!context.includes("max_iter") && !context.includes("timeout") && !context.includes("deadline")) {
          findings.push({
            id: "SEC3-DOS003",
            title: "Potentially Infinite Loop",
            severity: "critical",
            description: "Loop without clear termination condition can hang transaction.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add iteration limit: while condition && iterations < MAX_ITER",
            cwe: "CWE-835"
          });
        }
      }
      if ((line.includes("oracle") || line.includes("price_feed")) && !line.includes("//")) {
        if (!context.includes("fallback") && !context.includes("backup") && !context.includes("stale_price")) {
          findings.push({
            id: "SEC3-DOS004",
            title: "Oracle Dependency Without Fallback",
            severity: "high",
            description: "Oracle failures can DOS the protocol. Have fallback pricing.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add fallback: let price = oracle.get_price().or_else(|| backup_oracle.get_price())?",
            cwe: "CWE-754"
          });
        }
      }
      if (line.includes("realloc") && !line.includes("//")) {
        if (!context.includes("MAX_SIZE") && !context.includes("max_size") && !context.includes("limit")) {
          findings.push({
            id: "SEC3-DOS005",
            title: "Unbounded Account Reallocation",
            severity: "high",
            description: "Account reallocation without size limit can cause DOS.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Set maximum: require!(new_size <= MAX_ACCOUNT_SIZE, AccountTooLarge)",
            cwe: "CWE-400"
          });
        }
      }
      if (line.includes("invoke") && context.includes("self") && !context.includes("depth") && !context.includes("MAX_DEPTH")) {
        findings.push({
          id: "SEC3-DOS006",
          title: "Recursive CPI Without Depth Limit",
          severity: "high",
          description: "Self-referencing CPI can cause stack overflow or compute exhaustion.",
          location: { file: input.path, line: i + 1 },
          suggestion: "Track and limit CPI depth: require!(depth < MAX_CPI_DEPTH)",
          cwe: "CWE-674"
        });
      }
      if ((line.includes("pub fn mint") || line.includes("pub fn create") || line.includes("pub fn register")) && !line.includes("//")) {
        if (!context.includes("rate_limit") && !context.includes("cooldown") && !context.includes("last_action")) {
          findings.push({
            id: "SEC3-DOS007",
            title: "No Rate Limiting on Creation",
            severity: "medium",
            description: "Account/token creation without rate limits enables spam attacks.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Add rate limiting: require!(clock.unix_timestamp > user.last_create + COOLDOWN)",
            cwe: "CWE-770"
          });
        }
      }
      if ((line.includes("borsh::") || line.includes("BorshDeserialize")) && context.includes("Vec<") && !context.includes("max_len")) {
        findings.push({
          id: "SEC3-DOS008",
          title: "Unbounded Deserialization",
          severity: "high",
          description: "Deserializing unbounded vectors can exhaust memory.",
          location: { file: input.path, line: i + 1 },
          suggestion: "Use bounded types or validate length before deserializing.",
          cwe: "CWE-502"
        });
      }
      if (line.includes("invoke") && !line.includes("token_program") && !line.includes("system_program") && !line.includes("//")) {
        if (!context.includes("program_id ==") && !context.includes("whitelist")) {
          findings.push({
            id: "SEC3-DOS009",
            title: "CPI to Unvalidated Program",
            severity: "high",
            description: "CPI to unvalidated program could invoke malicious code.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Validate CPI target: require!(target_program.key() == KNOWN_PROGRAM_ID)",
            cwe: "CWE-829"
          });
        }
      }
      if ((line.includes("emit!") || line.includes("msg!")) && (context.includes("for ") || context.includes("loop"))) {
        if (!context.includes("limit") && !context.includes("MAX_")) {
          findings.push({
            id: "SEC3-DOS010",
            title: "Event Emission in Loop",
            severity: "low",
            description: "Emitting events in unbounded loops wastes compute and bloats logs.",
            location: { file: input.path, line: i + 1 },
            suggestion: "Emit summary event after loop instead of per-iteration events.",
            cwe: "CWE-400"
          });
        }
      }
    }
  }
  return findings;
}

// src/patterns/helius-2024-2025-deep.ts
function findLineNumber(content, match) {
  const lines = content.substring(0, match.index || 0).split("\n");
  return lines.length;
}
function getSnippet(content, line) {
  const lines = content.split("\n");
  const start = Math.max(0, line - 2);
  const end = Math.min(lines.length, line + 2);
  return lines.slice(start, end).join("\n").substring(0, 200);
}
function checkHelius2024DeepPatterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const path = input.path;
  if (!content) return findings;
  const patterns = [
    // DEXX $30M Private Key Leak (Nov 2024)
    {
      id: "HELIUS-DEXX-001",
      name: "Private Key Server Storage",
      severity: "critical",
      pattern: /private_key|secret_key|keypair[\s\S]{0,50}(?:store|save|persist|db|database|redis|cache)/i,
      description: "DEXX-style vulnerability: Storing private keys on servers enables mass theft if compromised.",
      recommendation: "Never store user private keys. Use hardware wallets or client-side encryption only.",
      exploit: "DEXX stored user private keys server-side, enabling $30M theft",
      loss: "$30M"
    },
    {
      id: "HELIUS-DEXX-002",
      name: "Centralized Key Management",
      severity: "critical",
      pattern: /export_private_key|get_private_key|fetch_keypair|decrypt_key[\s\S]{0,50}(?:api|endpoint|route)/i,
      description: "Centralized key management creates single point of failure for user funds.",
      recommendation: "Implement non-custodial architecture where only users control their keys.",
      exploit: "DEXX centralized key management led to mass wallet drains",
      loss: "$30M"
    },
    // Loopscale $5.8M Admin Exploit (Apr 2025)
    {
      id: "HELIUS-LOOP-001",
      name: "Admin Bypass - Collateral Manipulation",
      severity: "critical",
      pattern: /admin|owner|authority[\s\S]{0,100}collateral[\s\S]{0,50}(?:set|update|modify|change)/i,
      description: "Loopscale-style: Admin can manipulate collateral pricing to drain pools.",
      recommendation: "Use timelocks and multi-sig for any collateral parameter changes.",
      exploit: "Loopscale admin manipulated collateral pricing to drain $5.8M",
      loss: "$5.8M"
    },
    {
      id: "HELIUS-LOOP-002",
      name: "Undercollateralized Position Creation",
      severity: "critical",
      pattern: /create_position|open_loan|borrow[\s\S]{0,100}(?![\s\S]{0,50}collateral_ratio|[\s\S]{0,50}health_check)/i,
      description: "Position creation without collateral ratio validation enables undercollateralized loans.",
      recommendation: "Always verify collateral ratio >= minimum threshold before position creation.",
      exploit: "Loopscale positions created with insufficient collateral backing",
      loss: "$5.8M"
    },
    // Pump.fun Insider Attack ($1.9M May 2024)
    {
      id: "HELIUS-PUMP-001",
      name: "Bonding Curve Parameter Access",
      severity: "critical",
      pattern: /bonding_curve[\s\S]{0,100}(?:withdraw|drain|transfer)[\s\S]{0,50}(?:admin|employee|internal)/i,
      description: "Pump.fun-style: Insider access to bonding curve funds before migration.",
      recommendation: "Use time-locked, multi-sig controlled bonding curves with withdrawal delays.",
      exploit: "Pump.fun employee drained bonding curves using privileged access",
      loss: "$1.9M"
    },
    {
      id: "HELIUS-PUMP-002",
      name: "Early Withdrawal from Bonding Curve",
      severity: "high",
      pattern: /withdraw[\s\S]{0,50}bonding[\s\S]{0,50}(?![\s\S]{0,30}migration_complete|[\s\S]{0,30}locked)/i,
      description: "Withdrawal from bonding curve before migration period completes.",
      recommendation: "Lock bonding curve funds until migration threshold is reached.",
      exploit: "Funds withdrawn before migration to Raydium completed",
      loss: "$1.9M"
    },
    // Thunder Terminal MongoDB Attack ($240K Dec 2023)
    {
      id: "HELIUS-THUNDER-001",
      name: "Session Token Exposure",
      severity: "critical",
      pattern: /session_token|auth_token|jwt[\s\S]{0,50}(?:export|expose|leak|log)/i,
      description: "Thunder Terminal-style: Session tokens stored insecurely enable account takeover.",
      recommendation: "Encrypt session tokens, implement rotation, and never log sensitive tokens.",
      exploit: "MongoDB connection URL compromised session tokens",
      loss: "$240K"
    },
    {
      id: "HELIUS-THUNDER-002",
      name: "Third-Party DB Connection String Exposure",
      severity: "critical",
      pattern: /mongodb|postgres|mysql|redis[\s\S]{0,30}(?:url|uri|connection|string)[\s\S]{0,30}(?:env|config)/i,
      description: "Database connection strings can be exposed through misconfigurations.",
      recommendation: "Use secret managers, rotate credentials, and audit third-party access.",
      exploit: "Third-party MongoDB service exposed connection URLs",
      loss: "$240K"
    },
    // Banana Gun Bot Exploit ($1.4M Sep 2024)
    {
      id: "HELIUS-BANANA-001",
      name: "Trading Bot Transfer Manipulation",
      severity: "critical",
      pattern: /bot[\s\S]{0,50}transfer[\s\S]{0,50}(?:message|telegram|oracle)/i,
      description: "Banana Gun-style: Telegram oracle manipulation in trading bots.",
      recommendation: "Implement message signing and verification for bot commands.",
      exploit: "Telegram message system vulnerability enabled unauthorized transfers",
      loss: "$1.4M"
    },
    {
      id: "HELIUS-BANANA-002",
      name: "Bot Command Injection",
      severity: "critical",
      pattern: /parse_command|execute_command|bot_instruction[\s\S]{0,50}(?![\s\S]{0,30}sanitize|[\s\S]{0,30}validate)/i,
      description: "Bot commands executed without proper validation enable fund theft.",
      recommendation: "Sanitize all bot inputs, require signatures for transfers.",
      exploit: "Malicious commands injected into trading bot",
      loss: "$1.4M"
    },
    // Cypher Insider Theft ($317K 2024)
    {
      id: "HELIUS-CYPHER-001",
      name: "Insider Treasury Access",
      severity: "critical",
      pattern: /treasury|vault[\s\S]{0,50}(?:admin|manager|employee)[\s\S]{0,30}(?:withdraw|transfer|drain)/i,
      description: "Cypher-style: Former employees with unrevoced treasury access.",
      recommendation: "Implement immediate access revocation for departing employees.",
      exploit: "Former contractor retained backend access, drained remaining funds",
      loss: "$317K"
    },
    {
      id: "HELIUS-CYPHER-002",
      name: "Credential Persistence After Termination",
      severity: "high",
      pattern: /employee|contractor|staff[\s\S]{0,50}(?:credential|access|permission)[\s\S]{0,30}(?:remove|revoke|expire)/i,
      description: "Credentials not properly revoked when employees leave.",
      recommendation: "Automate credential revocation upon employee departure.",
      exploit: "Hoak retained access months after leaving Cypher",
      loss: "$317K"
    },
    // NoOnes MongoDB Attack (Jan 2025)
    {
      id: "HELIUS-NOONES-001",
      name: "Withdrawal Processing Exploit",
      severity: "critical",
      pattern: /withdrawal[\s\S]{0,50}process[\s\S]{0,50}(?:batch|queue|pending)/i,
      description: "NoOnes-style: Withdrawal processing system compromised.",
      recommendation: "Multi-signature withdrawal processing with manual review for large amounts.",
      exploit: "Hot wallet drained through compromised withdrawal system",
      loss: "$8.5M"
    },
    // Web3.js Supply Chain (Dec 2024)
    {
      id: "HELIUS-WEB3JS-001",
      name: "NPM Dependency Backdoor",
      severity: "critical",
      pattern: /@solana\/web3\.js[\s\S]{0,50}(?:1\.95\.5|1\.95\.6|1\.95\.7)/i,
      description: "Web3.js supply chain attack: Malicious versions exfiltrated private keys.",
      recommendation: "Lock dependencies, use npm audit, verify package integrity.",
      exploit: "Compromised npm account pushed malicious @solana/web3.js versions",
      loss: "$160K+"
    },
    {
      id: "HELIUS-WEB3JS-002",
      name: "Dependency Key Exfiltration",
      severity: "critical",
      pattern: /import[\s\S]{0,30}@solana[\s\S]{0,30}(?:keypair|wallet|account)[\s\S]{0,100}fetch|axios|http/i,
      description: "Dependencies making network requests with key material.",
      recommendation: "Audit dependency network calls, use CSP, monitor outbound traffic.",
      exploit: "Malicious web3.js sent private keys to attacker server",
      loss: "$160K+"
    },
    // Solareum Employee Attack (Jan 2024)
    {
      id: "HELIUS-SOLAR-001",
      name: "Developer Wallet Drain",
      severity: "critical",
      pattern: /developer|dev[\s\S]{0,30}wallet[\s\S]{0,50}(?:access|control|manage)/i,
      description: "Solareum-style: Rogue developer with wallet access.",
      recommendation: "Implement separation of duties, multi-sig for dev wallets.",
      exploit: "Developer with wallet access drained all funds",
      loss: "$468K"
    },
    // io.net GPU Exploit (Apr 2024)
    {
      id: "HELIUS-IONET-001",
      name: "User Metadata SQL Injection",
      severity: "high",
      pattern: /user[\s\S]{0,30}metadata[\s\S]{0,50}(?:query|sql|insert|select)/i,
      description: "io.net-style: User metadata endpoint vulnerable to injection.",
      recommendation: "Parameterize all queries, sanitize user inputs.",
      exploit: "SQL injection in user metadata API",
      loss: "Service disruption"
    },
    // Synthetify DAO Attack (Oct 2023)
    {
      id: "HELIUS-SYNTH-001",
      name: "DAO Proposal Notification Bypass",
      severity: "high",
      pattern: /proposal[\s\S]{0,50}(?:create|submit)[\s\S]{0,50}(?![\s\S]{0,30}notify|[\s\S]{0,30}alert|[\s\S]{0,30}announce)/i,
      description: "Synthetify-style: Malicious proposals submitted without community notice.",
      recommendation: "Implement mandatory proposal announcement periods.",
      exploit: "Attack proposal went unnoticed, passed without opposition",
      loss: "$230K"
    },
    {
      id: "HELIUS-SYNTH-002",
      name: "Governance Timelock Too Short",
      severity: "high",
      pattern: /timelock[\s\S]{0,30}(?:hours|days)[\s\S]{0,20}(?:[0-2]|24|48)/i,
      description: "Governance timelock under 3 days allows rushed malicious proposals.",
      recommendation: "Set minimum 3-7 day timelock for governance actions.",
      exploit: "Short timelock allowed attack to execute before detection",
      loss: "$230K"
    },
    // SVT Token Signature Bypass (Feb 2024)
    {
      id: "HELIUS-SVT-001",
      name: "Signature Account Validation Bypass",
      severity: "critical",
      pattern: /signature[\s\S]{0,50}(?:verify|check)[\s\S]{0,50}(?![\s\S]{0,30}account_owner|[\s\S]{0,30}program_id)/i,
      description: "SVT-style: Signature verification without validating signer account ownership.",
      recommendation: "Verify signer account owner matches expected program.",
      exploit: "Attacker forged signatures using fake signer accounts",
      loss: "$1M"
    },
    // Saga DAO Proposal Injection (Dec 2023)
    {
      id: "HELIUS-SAGA-001",
      name: "Governance Instruction Injection",
      severity: "critical",
      pattern: /governance[\s\S]{0,50}instruction[\s\S]{0,50}(?:arbitrary|custom|external)/i,
      description: "Saga DAO-style: Arbitrary instruction injection in governance proposals.",
      recommendation: "Whitelist allowed instruction types for governance execution.",
      exploit: "Malicious proposal executed arbitrary token transfer instructions",
      loss: "$1.5M"
    },
    // Parcl Frontend Phishing (Mar 2024)
    {
      id: "HELIUS-PARCL-001",
      name: "Frontend Deployment Compromise",
      severity: "critical",
      pattern: /cdn|cloudflare|vercel|netlify[\s\S]{0,50}(?:deploy|publish|update)/i,
      description: "Parcl-style: Frontend deployment compromised to inject malicious code.",
      recommendation: "Use deployment signing, CSP headers, and integrity checks.",
      exploit: "Compromised frontend redirected transaction approvals",
      loss: "$4K"
    },
    // Raydium Admin Key Compromise ($4.4M Dec 2022)
    {
      id: "HELIUS-RAY-001",
      name: "Pool Admin Key Single Point of Failure",
      severity: "critical",
      pattern: /pool[\s\S]{0,30}admin[\s\S]{0,30}(?:key|authority|owner)[\s\S]{0,30}(?!multi|threshold)/i,
      description: "Raydium-style: Single admin key for pool operations.",
      recommendation: "Use multi-sig admin keys with threshold signing.",
      exploit: "Compromised admin key drained liquidity pools",
      loss: "$4.4M"
    },
    {
      id: "HELIUS-RAY-002",
      name: "Withdraw Authority Without Timelock",
      severity: "critical",
      pattern: /withdraw[\s\S]{0,30}authority[\s\S]{0,50}(?![\s\S]{0,30}timelock|[\s\S]{0,30}delay|[\s\S]{0,30}cooldown)/i,
      description: "Withdrawal authority can drain pools instantly.",
      recommendation: "Add timelock delay for large withdrawals.",
      exploit: "Immediate withdrawal capability enabled rapid pool drain",
      loss: "$4.4M"
    },
    // Aurory NFT Bridge Exploit (Aug 2024)
    {
      id: "HELIUS-AURORY-001",
      name: "Cross-Chain Message Replay",
      severity: "critical",
      pattern: /bridge[\s\S]{0,50}message[\s\S]{0,50}(?![\s\S]{0,30}nonce|[\s\S]{0,30}unique|[\s\S]{0,30}replay)/i,
      description: "Aurory-style: Bridge messages can be replayed.",
      recommendation: "Include unique nonces and track processed messages.",
      exploit: "Bridge message replayed to mint duplicate NFTs",
      loss: "$830K"
    },
    // UXD Protocol Oracle Manipulation (Nov 2022)
    {
      id: "HELIUS-UXD-001",
      name: "Stale Oracle During Volatility",
      severity: "high",
      pattern: /oracle[\s\S]{0,50}price[\s\S]{0,50}(?![\s\S]{0,30}max_age|[\s\S]{0,30}staleness|[\s\S]{0,30}last_update)/i,
      description: "UXD-style: Stale oracle prices during high volatility.",
      recommendation: "Enforce maximum oracle age, use TWAP during volatility.",
      exploit: "Stale prices during FTX collapse enabled manipulation",
      loss: "$3.9M"
    },
    // Tulip Protocol Lending Manipulation (Oct 2022)
    {
      id: "HELIUS-TULIP-001",
      name: "Lending Rate Manipulation",
      severity: "high",
      pattern: /lending[\s\S]{0,30}rate[\s\S]{0,50}(?:utilization|borrow)[\s\S]{0,30}(?![\s\S]{0,20}cap|[\s\S]{0,20}limit)/i,
      description: "Tulip-style: Lending rates can be manipulated through utilization.",
      recommendation: "Cap maximum utilization rate, implement rate smoothing.",
      exploit: "Flash loan manipulated utilization to extract excess interest",
      loss: "$5.2M"
    },
    // Additional 2025 Patterns
    {
      id: "HELIUS-2025-001",
      name: "JIT Liquidity Sandwich",
      severity: "high",
      pattern: /jit[\s\S]{0,30}liquidity[\s\S]{0,50}(?:provide|add|inject)/i,
      description: "2025 MEV: JIT liquidity providers sandwiching user trades.",
      recommendation: "Use private mempools or MEV-protected submission.",
      exploit: "JIT liquidity extracting value from user swaps",
      loss: "Ongoing"
    },
    {
      id: "HELIUS-2025-002",
      name: "Tip Routing Manipulation",
      severity: "medium",
      pattern: /tip[\s\S]{0,30}(?:route|forward|relay)[\s\S]{0,30}(?:jito|block|validator)/i,
      description: "2025 MEV: Tip routing can be manipulated for extraction.",
      recommendation: "Verify tip destinations, use trusted relayers.",
      exploit: "Tips redirected to attacker validators",
      loss: "Ongoing"
    },
    // Solend 2022 Exploitation Patterns
    {
      id: "HELIUS-SOLEND-001",
      name: "Malicious Lending Market Creation",
      severity: "critical",
      pattern: /create[\s\S]{0,30}(?:market|pool|lending)[\s\S]{0,50}(?:permissionless|anyone|open)/i,
      description: "Solend 2022: Malicious markets created to bypass validation.",
      recommendation: "Whitelist allowed markets or require governance approval.",
      exploit: "Attacker created fake market to bypass auth checks",
      loss: "$2M at risk"
    },
    {
      id: "HELIUS-SOLEND-002",
      name: "Reserve Config Manipulation",
      severity: "critical",
      pattern: /reserve[\s\S]{0,30}config[\s\S]{0,50}(?:update|set|modify)[\s\S]{0,30}(?![\s\S]{0,20}auth|[\s\S]{0,20}admin)/i,
      description: "Reserve configuration can be manipulated without proper auth.",
      recommendation: "Require admin signature and timelock for config changes.",
      exploit: "UpdateReserveConfig bypassed by malicious market",
      loss: "$2M at risk"
    }
  ];
  for (const p of patterns) {
    const matches = content.matchAll(new RegExp(p.pattern.source, p.pattern.flags + "g"));
    for (const match of matches) {
      const line = findLineNumber(content, match);
      findings.push({
        id: p.id,
        title: `${p.name}${p.loss ? ` (${p.loss} exploit)` : ""}`,
        severity: p.severity,
        description: p.description,
        location: { file: path, line },
        recommendation: p.recommendation,
        code: getSnippet(content, line)
      });
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-53.ts
function findLine(content, idx) {
  return content.substring(0, idx).split("\n").length;
}
function getSnippet2(content, line) {
  const lines = content.split("\n");
  const start = Math.max(0, line - 2);
  const end = Math.min(lines.length, line + 2);
  return lines.slice(start, end).join("\n").substring(0, 200);
}
function checkBatch53Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const path = input.path;
  if (!content) return findings;
  const patterns = [
    // Business Logic Deep Patterns (SOL2001-SOL2020)
    {
      id: "SOL2001",
      name: "State Machine Skip",
      severity: "critical",
      regex: /state[\s\S]{0,30}transition[\s\S]{0,50}(?![\s\S]{0,30}require|[\s\S]{0,30}assert)/i,
      desc: "State transitions without validation allow skipping required states.",
      rec: "Validate current state before allowing transition to next state."
    },
    {
      id: "SOL2002",
      name: "Deadline Bypass",
      severity: "high",
      regex: /deadline|expiry|expire[\s\S]{0,50}(?:clock|timestamp)[\s\S]{0,30}(?![\s\S]{0,20}>=|[\s\S]{0,20}<=)/i,
      desc: "Deadline comparisons may allow edge-case bypasses.",
      rec: "Use strict comparisons and check both upper and lower bounds."
    },
    {
      id: "SOL2003",
      name: "Fee Calculation Precision Loss",
      severity: "high",
      regex: /fee[\s\S]{0,30}(?:\*|multiply)[\s\S]{0,30}(?:\/|divide)(?![\s\S]{0,20}checked)/i,
      desc: "Fee calculations may lose precision due to operation order.",
      rec: "Multiply before dividing to preserve precision."
    },
    {
      id: "SOL2004",
      name: "Reward Accumulation Drift",
      severity: "high",
      regex: /reward[\s\S]{0,30}(?:accumulate|accrue|earn)[\s\S]{0,50}(?:per_share|rate)/i,
      desc: "Reward accumulation may drift from expected values over time.",
      rec: "Use high-precision fixed-point math for reward calculations."
    },
    {
      id: "SOL2005",
      name: "Partial Fill Edge Case",
      severity: "medium",
      regex: /partial[\s\S]{0,20}(?:fill|execute)[\s\S]{0,50}(?:amount|quantity)[\s\S]{0,20}(?![\s\S]{0,15}min)/i,
      desc: "Partial fills without minimum amounts enable dust attacks.",
      rec: "Enforce minimum fill amounts to prevent dust exploitation."
    },
    {
      id: "SOL2006",
      name: "Slippage Off-by-One",
      severity: "medium",
      regex: /slippage[\s\S]{0,30}(?:>|<)[\s\S]{0,20}(?![\s\S]{0,10}=)/i,
      desc: "Slippage checks using strict comparison may miss boundary.",
      rec: "Use >= or <= for slippage comparisons."
    },
    {
      id: "SOL2007",
      name: "Cooldown Reset Exploit",
      severity: "high",
      regex: /cooldown[\s\S]{0,30}(?:set|update|reset)[\s\S]{0,50}(?![\s\S]{0,30}require|[\s\S]{0,30}assert)/i,
      desc: "Cooldowns can be reset without proper validation.",
      rec: "Verify cooldown has expired before allowing reset."
    },
    {
      id: "SOL2008",
      name: "Epoch Boundary Race",
      severity: "high",
      regex: /epoch[\s\S]{0,30}(?:boundary|transition|change)[\s\S]{0,50}(?:stake|unstake|claim)/i,
      desc: "Operations at epoch boundaries may have race conditions.",
      rec: "Add explicit epoch boundary checks and handle transitions safely."
    },
    {
      id: "SOL2009",
      name: "Liquidation Cascade",
      severity: "critical",
      regex: /liquidat[\s\S]{0,30}(?:loop|iterate|batch)[\s\S]{0,50}(?![\s\S]{0,30}limit)/i,
      desc: "Batch liquidations without limits can cascade failures.",
      rec: "Limit liquidations per transaction and add circuit breakers."
    },
    {
      id: "SOL2010",
      name: "Position Close During Settle",
      severity: "high",
      regex: /close[\s\S]{0,30}position[\s\S]{0,50}settl[\s\S]{0,30}(?![\s\S]{0,20}lock|[\s\S]{0,20}pending)/i,
      desc: "Positions closed during settlement can lose funds.",
      rec: "Lock positions during settlement period."
    },
    {
      id: "SOL2011",
      name: "Vault Share Inflation",
      severity: "critical",
      regex: /share[\s\S]{0,30}(?:mint|issue)[\s\S]{0,50}(?:deposit|balance)[\s\S]{0,30}(?![\s\S]{0,20}total)/i,
      desc: "Share minting without checking total supply enables inflation.",
      rec: "Always calculate shares relative to total supply."
    },
    {
      id: "SOL2012",
      name: "First Depositor Attack",
      severity: "critical",
      regex: /(?:first|initial)[\s\S]{0,20}deposit[\s\S]{0,50}(?![\s\S]{0,30}minimum|[\s\S]{0,30}seed)/i,
      desc: "First depositor can manipulate share price.",
      rec: "Require minimum initial deposit or seed the vault."
    },
    {
      id: "SOL2013",
      name: "Withdrawal Queue Jump",
      severity: "high",
      regex: /withdrawal[\s\S]{0,30}queue[\s\S]{0,50}(?:process|execute)[\s\S]{0,30}(?![\s\S]{0,20}fifo|[\s\S]{0,20}order)/i,
      desc: "Withdrawal queue can be bypassed without proper ordering.",
      rec: "Enforce FIFO ordering for withdrawal queues."
    },
    {
      id: "SOL2014",
      name: "Interest Compounding Gap",
      severity: "medium",
      regex: /interest[\s\S]{0,30}compound[\s\S]{0,50}(?![\s\S]{0,30}continuous|[\s\S]{0,30}per_second)/i,
      desc: "Interest compounding gaps allow timing exploitation.",
      rec: "Use continuous compounding or per-second accrual."
    },
    {
      id: "SOL2015",
      name: "Collateral Ratio Manipulation",
      severity: "critical",
      regex: /collateral[\s\S]{0,30}ratio[\s\S]{0,50}(?:flash|instant|atomic)/i,
      desc: "Collateral ratios can be manipulated in single transaction.",
      rec: "Use TWAP or delayed price for collateral calculations."
    },
    {
      id: "SOL2016",
      name: "Referral Fee Bypass",
      severity: "medium",
      regex: /referr[\s\S]{0,30}fee[\s\S]{0,50}(?:self|same)[\s\S]{0,20}(?![\s\S]{0,15}block|[\s\S]{0,15}prevent)/i,
      desc: "Users can refer themselves to capture referral fees.",
      rec: "Prevent self-referral by checking account relationships."
    },
    {
      id: "SOL2017",
      name: "Auction Sniping",
      severity: "high",
      regex: /auction[\s\S]{0,30}(?:end|close|finish)[\s\S]{0,50}(?![\s\S]{0,30}extension|[\s\S]{0,30}anti_snipe)/i,
      desc: "Auctions without extension mechanism enable sniping.",
      rec: "Add bid extension period to prevent last-second sniping."
    },
    {
      id: "SOL2018",
      name: "Vote Power Flash",
      severity: "critical",
      regex: /vote[\s\S]{0,30}(?:power|weight)[\s\S]{0,50}(?:balance|token)[\s\S]{0,30}(?![\s\S]{0,20}snapshot)/i,
      desc: "Vote power from current balance enables flash loan governance.",
      rec: "Use historical snapshots for voting power."
    },
    {
      id: "SOL2019",
      name: "Pool Imbalance Exploit",
      severity: "high",
      regex: /pool[\s\S]{0,30}(?:imbalance|ratio)[\s\S]{0,50}(?:swap|trade)[\s\S]{0,30}(?![\s\S]{0,20}limit)/i,
      desc: "Extreme pool imbalances can be exploited for profit.",
      rec: "Add imbalance limits and circuit breakers."
    },
    {
      id: "SOL2020",
      name: "Margin Call Timing",
      severity: "high",
      regex: /margin[\s\S]{0,30}call[\s\S]{0,50}(?:timestamp|clock)[\s\S]{0,30}(?![\s\S]{0,20}grace|[\s\S]{0,20}window)/i,
      desc: "Margin calls without grace period cause unfair liquidations.",
      rec: "Add grace period for margin calls."
    },
    // Input Validation Advanced (SOL2021-SOL2040)
    {
      id: "SOL2021",
      name: "Pubkey Zero Check",
      severity: "critical",
      regex: /pubkey[\s\S]{0,30}(?:=|==)[\s\S]{0,30}(?![\s\S]{0,20}system_program|[\s\S]{0,20}Pubkey::default)/i,
      desc: "Pubkey comparison without zero/default check.",
      rec: "Check for Pubkey::default() before comparisons."
    },
    {
      id: "SOL2022",
      name: "String Length DoS",
      severity: "high",
      regex: /String[\s\S]{0,30}(?:len|length)[\s\S]{0,30}(?![\s\S]{0,20}<|[\s\S]{0,20}<=|[\s\S]{0,20}max)/i,
      desc: "Unbounded string length enables DoS attacks.",
      rec: "Enforce maximum string length limits."
    },
    {
      id: "SOL2023",
      name: "Array Index Bounds",
      severity: "critical",
      regex: /\[[\s\S]{0,20}(?:index|idx|i)[\s\S]{0,10}\][\s\S]{0,30}(?![\s\S]{0,20}get\(|[\s\S]{0,20}bounds)/i,
      desc: "Array access without bounds checking.",
      rec: "Use .get() for safe array access."
    },
    {
      id: "SOL2024",
      name: "Decimal Truncation",
      severity: "high",
      regex: /as\s+u(?:8|16|32|64)[\s\S]{0,20}(?:decimal|price|amount)/i,
      desc: "Casting to smaller int truncates decimal precision.",
      rec: "Use appropriate integer sizes for decimal values."
    },
    {
      id: "SOL2025",
      name: "Negative Amount Cast",
      severity: "critical",
      regex: /as\s+i(?:8|16|32|64)[\s\S]{0,30}(?:amount|balance|quantity)/i,
      desc: "Casting unsigned to signed may produce negative values.",
      rec: "Validate values before casting to signed types."
    },
    {
      id: "SOL2026",
      name: "Timestamp Future Check",
      severity: "medium",
      regex: /timestamp[\s\S]{0,30}(?:>|>=)[\s\S]{0,30}clock[\s\S]{0,20}(?![\s\S]{0,15}<|[\s\S]{0,15}future)/i,
      desc: "Timestamp validation missing future check.",
      rec: "Reject timestamps too far in the future."
    },
    {
      id: "SOL2027",
      name: "Slot Overflow Risk",
      severity: "high",
      regex: /slot[\s\S]{0,30}(?:\+|add)[\s\S]{0,30}(?![\s\S]{0,20}checked|[\s\S]{0,20}saturating)/i,
      desc: "Slot arithmetic may overflow at high values.",
      rec: "Use checked arithmetic for slot calculations."
    },
    {
      id: "SOL2028",
      name: "Lamport Dust",
      severity: "low",
      regex: /lamports[\s\S]{0,30}(?:<|<=)[\s\S]{0,20}(?:1000|100|10|1)[\s\S]{0,10}(?![\s\S]{0,10}0)/i,
      desc: "Operations on dust lamport amounts waste compute.",
      rec: "Enforce minimum lamport thresholds."
    },
    {
      id: "SOL2029",
      name: "Base58 Decode Unchecked",
      severity: "medium",
      regex: /base58[\s\S]{0,30}decode[\s\S]{0,30}(?:unwrap|expect)/i,
      desc: "Base58 decode failure not properly handled.",
      rec: "Handle base58 decode errors gracefully."
    },
    {
      id: "SOL2030",
      name: "Instruction Data Size",
      severity: "high",
      regex: /instruction[\s\S]{0,30}data[\s\S]{0,50}(?:len|length)[\s\S]{0,20}(?![\s\S]{0,15}>=|[\s\S]{0,15}require)/i,
      desc: "Instruction data size not validated.",
      rec: "Validate instruction data length before parsing."
    },
    {
      id: "SOL2031",
      name: "Remaining Accounts Unbounded",
      severity: "high",
      regex: /remaining_accounts[\s\S]{0,50}(?:iter|for_each)[\s\S]{0,30}(?![\s\S]{0,20}take\(|[\s\S]{0,20}limit)/i,
      desc: "Remaining accounts iteration unbounded.",
      rec: "Limit remaining accounts iteration count."
    },
    {
      id: "SOL2032",
      name: "Seeds Length Validation",
      severity: "high",
      regex: /seeds[\s\S]{0,30}(?:len|length)[\s\S]{0,30}(?![\s\S]{0,20}<=\s*32|[\s\S]{0,20}MAX_SEED)/i,
      desc: "PDA seed length not validated against max.",
      rec: "Validate seed lengths <= 32 bytes each."
    },
    {
      id: "SOL2033",
      name: "Memo Injection",
      severity: "medium",
      regex: /memo[\s\S]{0,30}(?:data|content|message)[\s\S]{0,30}(?![\s\S]{0,20}sanitize|[\s\S]{0,20}escape)/i,
      desc: "Memo content not sanitized for display.",
      rec: "Sanitize memo content before display/logging."
    },
    {
      id: "SOL2034",
      name: "URL Validation",
      severity: "medium",
      regex: /url|uri[\s\S]{0,30}(?:http|https)[\s\S]{0,30}(?![\s\S]{0,20}validate|[\s\S]{0,20}whitelist)/i,
      desc: "URLs stored without validation.",
      rec: "Validate URLs against allowed protocols and domains."
    },
    {
      id: "SOL2035",
      name: "Bitmap Overflow",
      severity: "high",
      regex: /bitmap|bitset[\s\S]{0,30}(?:set|get|toggle)[\s\S]{0,30}(?![\s\S]{0,20}bounds|[\s\S]{0,20}<\s*\d)/i,
      desc: "Bitmap operations without bounds checking.",
      rec: "Validate bit index before bitmap operations."
    },
    {
      id: "SOL2036",
      name: "Enum Discriminant Check",
      severity: "high",
      regex: /enum[\s\S]{0,50}(?:from_u8|from_byte)[\s\S]{0,30}(?![\s\S]{0,20}match|[\s\S]{0,20}try)/i,
      desc: "Enum deserialization without discriminant validation.",
      rec: "Use try_from or match for enum deserialization."
    },
    {
      id: "SOL2037",
      name: "Float Precision",
      severity: "high",
      regex: /f32|f64[\s\S]{0,30}(?:price|amount|balance)/i,
      desc: "Floating point used for financial calculations.",
      rec: "Use fixed-point decimals for financial values."
    },
    {
      id: "SOL2038",
      name: "Hash Preimage",
      severity: "medium",
      regex: /hash[\s\S]{0,30}(?:preimage|reveal)[\s\S]{0,30}(?![\s\S]{0,20}commit|[\s\S]{0,20}timelock)/i,
      desc: "Hash reveal without commit-reveal scheme.",
      rec: "Use commit-reveal pattern for hash-based operations."
    },
    {
      id: "SOL2039",
      name: "Nonce Replay",
      severity: "critical",
      regex: /nonce[\s\S]{0,30}(?:use|consume)[\s\S]{0,30}(?![\s\S]{0,20}increment|[\s\S]{0,20}invalidate)/i,
      desc: "Nonce not invalidated after use.",
      rec: "Increment or invalidate nonces after each use."
    },
    {
      id: "SOL2040",
      name: "Version Compatibility",
      severity: "medium",
      regex: /version[\s\S]{0,30}(?:check|compare)[\s\S]{0,30}(?![\s\S]{0,20}>=|[\s\S]{0,20}compatible)/i,
      desc: "Version checking may miss compatibility issues.",
      rec: "Implement proper semantic version compatibility."
    },
    // Access Control Edge Cases (SOL2041-SOL2055)
    {
      id: "SOL2041",
      name: "Authority Downgrade",
      severity: "critical",
      regex: /authority[\s\S]{0,30}(?:downgrade|reduce|lower)[\s\S]{0,30}(?![\s\S]{0,20}require|[\s\S]{0,20}verify)/i,
      desc: "Authority can be downgraded without proper checks.",
      rec: "Require current authority signature for downgrades."
    },
    {
      id: "SOL2042",
      name: "Freeze Authority Transfer",
      severity: "high",
      regex: /freeze[\s\S]{0,30}authority[\s\S]{0,30}transfer[\s\S]{0,30}(?![\s\S]{0,20}verify|[\s\S]{0,20}require)/i,
      desc: "Freeze authority can be transferred unsafely.",
      rec: "Implement two-step freeze authority transfer."
    },
    {
      id: "SOL2043",
      name: "Delegate Scope Creep",
      severity: "high",
      regex: /delegate[\s\S]{0,30}(?:amount|scope|permission)[\s\S]{0,30}(?:update|increase)/i,
      desc: "Delegate permissions can be expanded without limit.",
      rec: "Cap delegate permissions at initial grant level."
    },
    {
      id: "SOL2044",
      name: "Emergency Admin Abuse",
      severity: "critical",
      regex: /emergency[\s\S]{0,30}admin[\s\S]{0,50}(?:drain|withdraw|transfer)[\s\S]{0,30}(?![\s\S]{0,20}timelock)/i,
      desc: "Emergency admin can drain without timelock.",
      rec: "Add timelock even for emergency operations."
    },
    {
      id: "SOL2045",
      name: "Pause Without Unpause",
      severity: "high",
      regex: /pause[\s\S]{0,50}(?![\s\S]{0,50}unpause|[\s\S]{0,50}resume)/i,
      desc: "Pause mechanism without corresponding unpause.",
      rec: "Implement unpause with appropriate controls."
    },
    {
      id: "SOL2046",
      name: "Role Hierarchy Bypass",
      severity: "high",
      regex: /role[\s\S]{0,30}(?:check|verify)[\s\S]{0,50}(?![\s\S]{0,30}hierarchy|[\s\S]{0,30}inherit)/i,
      desc: "Role checks may not respect hierarchy.",
      rec: "Implement proper role hierarchy checking."
    },
    {
      id: "SOL2047",
      name: "Session Key Scope",
      severity: "high",
      regex: /session[\s\S]{0,30}key[\s\S]{0,50}(?:sign|execute)[\s\S]{0,30}(?![\s\S]{0,20}scope|[\s\S]{0,20}limit)/i,
      desc: "Session keys without operation scope limits.",
      rec: "Limit session key permissions to specific operations."
    },
    {
      id: "SOL2048",
      name: "CPI Authority Escalation",
      severity: "critical",
      regex: /invoke[\s\S]{0,50}signer_seeds[\s\S]{0,30}(?:any|arbitrary|user)/i,
      desc: "CPI using arbitrary user-provided seeds.",
      rec: "Validate signer seeds against expected values."
    },
    {
      id: "SOL2049",
      name: "Token Metadata Authority",
      severity: "high",
      regex: /metadata[\s\S]{0,30}(?:update|modify)[\s\S]{0,30}authority[\s\S]{0,30}(?![\s\S]{0,20}verify)/i,
      desc: "Metadata update authority not verified.",
      rec: "Verify metadata update authority before changes."
    },
    {
      id: "SOL2050",
      name: "Collection Authority Spoof",
      severity: "critical",
      regex: /collection[\s\S]{0,30}(?:verify|sign)[\s\S]{0,30}(?![\s\S]{0,20}authority|[\s\S]{0,20}creator)/i,
      desc: "Collection verification without authority check.",
      rec: "Verify collection authority signature."
    },
    {
      id: "SOL2051",
      name: "Upgrade Authority Leak",
      severity: "critical",
      regex: /upgrade[\s\S]{0,30}authority[\s\S]{0,50}(?:pubkey|key)[\s\S]{0,30}(?:set|assign|change)/i,
      desc: "Program upgrade authority can be changed unsafely.",
      rec: "Make upgrade authority immutable or use multi-sig."
    },
    {
      id: "SOL2052",
      name: "Close Authority Missing",
      severity: "high",
      regex: /close[\s\S]{0,30}account[\s\S]{0,50}(?![\s\S]{0,30}authority|[\s\S]{0,30}owner)/i,
      desc: "Account closure without authority verification.",
      rec: "Verify close authority before account closure."
    },
    {
      id: "SOL2053",
      name: "Rent Payer Authority",
      severity: "medium",
      regex: /rent[\s\S]{0,30}payer[\s\S]{0,50}(?![\s\S]{0,30}signer|[\s\S]{0,30}verify)/i,
      desc: "Rent payer not verified as signer.",
      rec: "Require rent payer signature."
    },
    {
      id: "SOL2054",
      name: "Crank Permission",
      severity: "medium",
      regex: /crank[\s\S]{0,30}(?:execute|call)[\s\S]{0,50}(?:anyone|permissionless)/i,
      desc: "Permissionless cranking may enable extraction.",
      rec: "Add incentives or restrictions for cranking."
    },
    {
      id: "SOL2055",
      name: "Initializer Authority",
      severity: "high",
      regex: /init[\s\S]{0,30}(?:authority|admin)[\s\S]{0,50}(?:caller|signer)[\s\S]{0,30}(?![\s\S]{0,20}hardcode)/i,
      desc: "Initializer becomes authority by default.",
      rec: "Separate initialization from authority assignment."
    },
    // 2024-2025 Emerging Attack Vectors (SOL2056-SOL2070)
    {
      id: "SOL2056",
      name: "Blink Action Validation",
      severity: "high",
      regex: /blink|action[\s\S]{0,30}(?:url|endpoint)[\s\S]{0,30}(?![\s\S]{0,20}verify|[\s\S]{0,20}whitelist)/i,
      desc: "Blink action URLs not validated.",
      rec: "Whitelist allowed blink action endpoints."
    },
    {
      id: "SOL2057",
      name: "Compression Proof Spoofing",
      severity: "critical",
      regex: /compression[\s\S]{0,30}proof[\s\S]{0,50}(?:verify|check)[\s\S]{0,30}(?![\s\S]{0,20}root)/i,
      desc: "Compressed NFT proof verification incomplete.",
      rec: "Verify proof against current merkle root."
    },
    {
      id: "SOL2058",
      name: "Token-2022 Extension Abuse",
      severity: "high",
      regex: /token[\s\S]{0,10}2022[\s\S]{0,30}extension[\s\S]{0,30}(?![\s\S]{0,20}verify|[\s\S]{0,20}check)/i,
      desc: "Token-2022 extensions not properly validated.",
      rec: "Validate extension states before operations."
    },
    {
      id: "SOL2059",
      name: "Transfer Hook Reentrancy",
      severity: "critical",
      regex: /transfer[\s\S]{0,30}hook[\s\S]{0,50}(?:invoke|call)[\s\S]{0,30}(?![\s\S]{0,20}guard|[\s\S]{0,20}lock)/i,
      desc: "Transfer hooks may enable reentrancy.",
      rec: "Add reentrancy guards for transfer hooks."
    },
    {
      id: "SOL2060",
      name: "Confidential Transfer Leak",
      severity: "high",
      regex: /confidential[\s\S]{0,30}transfer[\s\S]{0,50}(?:log|emit|print)/i,
      desc: "Confidential transfer amounts may be leaked.",
      rec: "Never log confidential transfer details."
    },
    {
      id: "SOL2061",
      name: "Interest Bearing Manipulation",
      severity: "high",
      regex: /interest[\s\S]{0,30}bearing[\s\S]{0,50}rate[\s\S]{0,30}(?:set|update)/i,
      desc: "Interest bearing token rate can be manipulated.",
      rec: "Add timelock for interest rate changes."
    },
    {
      id: "SOL2062",
      name: "Permanent Delegate Abuse",
      severity: "critical",
      regex: /permanent[\s\S]{0,30}delegate[\s\S]{0,50}(?![\s\S]{0,30}revoke|[\s\S]{0,30}remove)/i,
      desc: "Permanent delegate cannot be revoked.",
      rec: "Avoid permanent delegates or add revocation."
    },
    {
      id: "SOL2063",
      name: "CPI Guard State",
      severity: "high",
      regex: /cpi[\s\S]{0,30}guard[\s\S]{0,50}(?:enable|disable)[\s\S]{0,30}(?![\s\S]{0,20}verify)/i,
      desc: "CPI guard state changes not verified.",
      rec: "Verify CPI guard state before sensitive operations."
    },
    {
      id: "SOL2064",
      name: "Memo Required Bypass",
      severity: "medium",
      regex: /memo[\s\S]{0,30}required[\s\S]{0,50}(?:skip|bypass|ignore)/i,
      desc: "Required memo can be bypassed.",
      rec: "Enforce memo requirement at protocol level."
    },
    {
      id: "SOL2065",
      name: "Non-Transferable Override",
      severity: "high",
      regex: /non[\s\S]{0,5}transferable[\s\S]{0,50}(?:override|bypass|exception)/i,
      desc: "Non-transferable tokens can be transferred.",
      rec: "Remove override capabilities for non-transferable."
    },
    {
      id: "SOL2066",
      name: "Default Account State Abuse",
      severity: "medium",
      regex: /default[\s\S]{0,30}account[\s\S]{0,30}state[\s\S]{0,30}(?:frozen|initialized)/i,
      desc: "Default account state can lock user funds.",
      rec: "Clearly document default account state behavior."
    },
    {
      id: "SOL2067",
      name: "Reallocate Without Check",
      severity: "high",
      regex: /realloc[\s\S]{0,50}(?:size|space)[\s\S]{0,30}(?![\s\S]{0,20}max|[\s\S]{0,20}limit)/i,
      desc: "Account reallocation without size limits.",
      rec: "Enforce maximum account size limits."
    },
    {
      id: "SOL2068",
      name: "Lookup Table Poison",
      severity: "critical",
      regex: /lookup[\s\S]{0,30}table[\s\S]{0,50}(?:extend|add)[\s\S]{0,30}(?![\s\S]{0,20}verify)/i,
      desc: "Address lookup tables can be poisoned.",
      rec: "Verify lookup table authority and contents."
    },
    {
      id: "SOL2069",
      name: "Durable Nonce Exploitation",
      severity: "high",
      regex: /durable[\s\S]{0,30}nonce[\s\S]{0,50}(?:advance|consume)[\s\S]{0,30}(?![\s\S]{0,20}verify)/i,
      desc: "Durable nonce state not properly verified.",
      rec: "Verify nonce account state and authority."
    },
    {
      id: "SOL2070",
      name: "Versioned Transaction Confusion",
      severity: "medium",
      regex: /version[\s\S]{0,30}transaction[\s\S]{0,50}(?:legacy|v0)[\s\S]{0,30}(?![\s\S]{0,20}check)/i,
      desc: "Transaction version handling may cause confusion.",
      rec: "Explicitly handle both legacy and versioned transactions."
    }
  ];
  for (const p of patterns) {
    const matches = content.matchAll(new RegExp(p.regex.source, p.regex.flags + "g"));
    for (const match of matches) {
      const line = findLine(content, match.index || 0);
      findings.push({
        id: p.id,
        title: p.name,
        severity: p.severity,
        description: p.desc,
        location: { file: path, line },
        recommendation: p.rec,
        code: getSnippet2(content, line)
      });
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-54.ts
var BATCH_54_PATTERNS = [
  // ========== Solend-style Auth Bypass (SOL2071-SOL2085) ==========
  {
    id: "SOL2071",
    name: "UpdateReserveConfig Auth Bypass",
    severity: "critical",
    pattern: /update.*reserve.*config|reserve.*update|config.*update/i,
    description: "Reserve config update without proper lending market ownership validation. An attacker can create their own lending market and pass it to bypass admin checks (Solend Aug 2021).",
    recommendation: "Verify lending market ownership before allowing reserve config updates. Use has_one constraint on lending_market authority."
  },
  {
    id: "SOL2072",
    name: "Lending Market Ownership Bypass",
    severity: "critical",
    pattern: /lending_market|LendingMarket[\s\S]{0,100}(?!has_one|owner\s*==)/i,
    description: "Lending market passed as account without verifying caller owns it. Attacker can substitute their own market.",
    recommendation: "Add has_one = lending_market constraint or verify lending_market.owner == authority.key()."
  },
  {
    id: "SOL2073",
    name: "Liquidation Threshold Manipulation",
    severity: "critical",
    pattern: /liquidation_threshold|ltv|loan_to_value[\s\S]{0,50}(?:=|update)/i,
    description: "Liquidation threshold can be modified without proper authorization (Solend exploit vector).",
    recommendation: "Require multisig or timelock for liquidation parameter changes."
  },
  {
    id: "SOL2074",
    name: "Liquidation Bonus Inflation",
    severity: "high",
    pattern: /liquidation_bonus|liquidator_bonus[\s\S]{0,50}(?:=|update|set)/i,
    description: "Liquidation bonus can be inflated to steal from liquidated positions.",
    recommendation: "Cap liquidation bonus at reasonable maximum (e.g., 15%) and require governance for changes."
  },
  {
    id: "SOL2075",
    name: "Reserve Configuration Race",
    severity: "high",
    pattern: /reserve(?:_config)?[\s\S]{0,100}(?:update|modify|set)[\s\S]{0,50}(?!timelock|delay)/i,
    description: "Reserve config changes take effect immediately, allowing front-run attacks.",
    recommendation: "Add timelock delay for configuration changes."
  },
  {
    id: "SOL2076",
    name: "Admin Lending Market Substitution",
    severity: "critical",
    pattern: /admin|authority[\s\S]{0,100}market(?:_account)?/i,
    description: "Admin can substitute lending market to bypass checks.",
    recommendation: "Hardcode or derive lending market address, never accept as input for admin functions."
  },
  {
    id: "SOL2077",
    name: "Borrowing Suspension Bypass",
    severity: "high",
    pattern: /borrow(?:ing)?[\s\S]{0,50}(?:suspend|pause|disable)[\s\S]{0,50}(?!require|assert)/i,
    description: "Borrowing suspension can be bypassed or may not be checked during borrows.",
    recommendation: "Check suspension status at the start of every borrow instruction."
  },
  {
    id: "SOL2078",
    name: "Bot Liquidator Privilege",
    severity: "medium",
    pattern: /liquidator(?:_bot)?|bot_liquidat/i,
    description: "Protocol liquidator bot may have undue privileges over user positions.",
    recommendation: "Ensure liquidator bots follow same rules as external liquidators."
  },
  {
    id: "SOL2079",
    name: "Reserve State Desync",
    severity: "high",
    pattern: /reserve[\s\S]{0,50}state[\s\S]{0,50}(?!refresh|reload|update)/i,
    description: "Reserve state not refreshed before critical operations.",
    recommendation: "Always refresh reserve state before reads in same transaction."
  },
  {
    id: "SOL2080",
    name: "Interest Rate Model Injection",
    severity: "high",
    pattern: /interest_rate|rate_model[\s\S]{0,50}(?:=|set|update)/i,
    description: "Interest rate model can be injected/changed maliciously.",
    recommendation: "Validate interest rate model address against allowlist."
  },
  {
    id: "SOL2081",
    name: "Collateral Factor Manipulation",
    severity: "critical",
    pattern: /collateral_factor|cf[\s\S]{0,30}(?:=|set|update)/i,
    description: "Collateral factor changes can make positions instantly liquidatable.",
    recommendation: "Require governance vote and delay for collateral factor changes."
  },
  {
    id: "SOL2082",
    name: "Lending Pool Admin Takeover",
    severity: "critical",
    pattern: /(?:lending_)?pool[\s\S]{0,50}admin[\s\S]{0,50}(?:=|transfer|set)/i,
    description: "Pool admin can be transferred without proper safeguards.",
    recommendation: "Require two-step admin transfer with acceptance confirmation."
  },
  {
    id: "SOL2083",
    name: "Reserve Withdraw Authority",
    severity: "high",
    pattern: /reserve[\s\S]{0,50}withdraw(?:_authority)?/i,
    description: "Reserve withdraw authority may allow unauthorized withdrawals.",
    recommendation: "Restrict reserve withdrawals to protocol PDAs only."
  },
  {
    id: "SOL2084",
    name: "Oracle Price Admin Override",
    severity: "critical",
    pattern: /(?:oracle|price)[\s\S]{0,50}admin[\s\S]{0,30}override/i,
    description: "Admin can override oracle prices, enabling manipulation.",
    recommendation: "Remove admin price override capability or require multisig + delay."
  },
  {
    id: "SOL2085",
    name: "Emergency Liquidation Mode",
    severity: "high",
    pattern: /emergency[\s\S]{0,50}liquidat/i,
    description: "Emergency liquidation mode may allow exploitative liquidations.",
    recommendation: "Cap emergency mode privileges, require timelock to activate."
  },
  // ========== Wormhole-style Signature Bypass (SOL2086-SOL2095) ==========
  {
    id: "SOL2086",
    name: "Guardian Signature Verification Bypass",
    severity: "critical",
    pattern: /guardian[\s\S]{0,100}(?:verify|signature|sign)[\s\S]{0,50}(?!require|assert|check)/i,
    description: "Guardian signatures not properly verified (Wormhole $326M exploit pattern).",
    recommendation: "Always verify guardian signatures against known guardian set with quorum."
  },
  {
    id: "SOL2087",
    name: "Signature Set Spoofing",
    severity: "critical",
    pattern: /signature_set|SignatureSet[\s\S]{0,100}(?!owner_check|verify_owner)/i,
    description: "Signature set account can be spoofed (Wormhole exploit pattern).",
    recommendation: "Verify signature set is owned by expected program and properly initialized."
  },
  {
    id: "SOL2088",
    name: "VAA Validation Incomplete",
    severity: "critical",
    pattern: /vaa|VAA[\s\S]{0,100}(?!verify_signatures|check_guardian)/i,
    description: "Verified Action Approval (VAA) not fully validated.",
    recommendation: "Verify all VAA fields including guardian signatures, timestamp, and sequence."
  },
  {
    id: "SOL2089",
    name: "Cross-Chain Message Forgery",
    severity: "critical",
    pattern: /cross_chain[\s\S]{0,50}message[\s\S]{0,50}(?!verify|validate)/i,
    description: "Cross-chain messages can be forged without proper attestation.",
    recommendation: "Require multiple independent attestations for cross-chain messages."
  },
  {
    id: "SOL2090",
    name: "Bridge Guardian Quorum",
    severity: "critical",
    pattern: /guardian[\s\S]{0,50}quorum[\s\S]{0,50}(?!>=|threshold)/i,
    description: "Guardian quorum not checked before accepting bridge messages.",
    recommendation: "Require 2/3+ guardian signatures for any bridge operation."
  },
  {
    id: "SOL2091",
    name: "Wrapped Token Mint Authority",
    severity: "critical",
    pattern: /wrapped[\s\S]{0,30}(?:token|mint)[\s\S]{0,50}authority/i,
    description: "Wrapped token mint authority may be compromised or bypassed.",
    recommendation: "Mint authority must be PDA derived from verified bridge program."
  },
  {
    id: "SOL2092",
    name: "Bridge Finality Check",
    severity: "high",
    pattern: /bridge[\s\S]{0,50}(?:transfer|deposit|withdraw)[\s\S]{0,50}(?!finality|confirm)/i,
    description: "Bridge operations without checking source chain finality.",
    recommendation: "Wait for sufficient block confirmations on source chain before minting."
  },
  {
    id: "SOL2093",
    name: "Relayer Trust Assumption",
    severity: "high",
    pattern: /relayer[\s\S]{0,50}(?:submit|relay|forward)/i,
    description: "Relayer is trusted to submit valid messages without verification.",
    recommendation: "Verify message content on-chain, never trust relayer-provided data."
  },
  {
    id: "SOL2094",
    name: "Guardian Set Update Race",
    severity: "critical",
    pattern: /guardian_set[\s\S]{0,50}(?:update|rotate|change)/i,
    description: "Guardian set update can race with pending operations.",
    recommendation: "Implement guardian set update delay and process pending ops first."
  },
  {
    id: "SOL2095",
    name: "Ed25519 Precompile Bypass",
    severity: "critical",
    pattern: /ed25519[\s\S]{0,50}(?:verify|check)[\s\S]{0,50}(?!precompile|native)/i,
    description: "Ed25519 signature verification not using native precompile.",
    recommendation: "Use Ed25519 native program for signature verification."
  },
  // ========== Cashio-style Mint Validation (SOL2096-SOL2105) ==========
  {
    id: "SOL2096",
    name: "Collateral Mint Whitelist Missing",
    severity: "critical",
    pattern: /collateral[\s\S]{0,50}mint[\s\S]{0,50}(?!whitelist|allowlist|verify)/i,
    description: "Collateral mint not validated against whitelist (Cashio $52M exploit).",
    recommendation: "Verify collateral mint is in approved whitelist before accepting."
  },
  {
    id: "SOL2097",
    name: "Saber LP Token Validation",
    severity: "critical",
    pattern: /saber[\s\S]{0,50}(?:lp|pool|swap)/i,
    description: "Saber LP token not properly validated for mint field.",
    recommendation: "Verify saber_swap.arrow mint field matches expected collateral."
  },
  {
    id: "SOL2098",
    name: "Root of Trust Missing",
    severity: "critical",
    pattern: /(?:collateral|backing|reserve)[\s\S]{0,100}(?!root_of_trust|chain_validation)/i,
    description: "Missing root of trust validation for collateral chain.",
    recommendation: "Establish and verify complete chain of trust for all collateral."
  },
  {
    id: "SOL2099",
    name: "Fake Account Substitution",
    severity: "critical",
    pattern: /(?:account|token_account)[\s\S]{0,50}(?:collateral|backing)/i,
    description: "Fake accounts can be substituted for real collateral.",
    recommendation: "Verify every account in the collateral chain against known PDAs."
  },
  {
    id: "SOL2100",
    name: "Infinite Mint Vulnerability",
    severity: "critical",
    pattern: /mint(?:_to)?[\s\S]{0,100}(?!balance_check|limit|cap)/i,
    description: "Minting without proper balance or cap checks enables infinite mint.",
    recommendation: "Verify backing ratio before minting, enforce supply caps."
  },
  {
    id: "SOL2101",
    name: "Stablecoin Peg Attack",
    severity: "critical",
    pattern: /stable(?:coin)?[\s\S]{0,50}(?:mint|redeem|swap)/i,
    description: "Stablecoin can be minted or redeemed to attack the peg.",
    recommendation: "Implement mint/redeem fees, rate limits, and oracle validation."
  },
  {
    id: "SOL2102",
    name: "Arrow Account Validation",
    severity: "high",
    pattern: /arrow[\s\S]{0,50}account/i,
    description: "Arrow/wrapper account not fully validated.",
    recommendation: "Verify all nested account fields in wrapper structures."
  },
  {
    id: "SOL2103",
    name: "LP Token Fake Mint",
    severity: "critical",
    pattern: /lp_mint|pool_mint[\s\S]{0,50}(?!==|verify|check)/i,
    description: "LP token mint can be faked if not verified against pool.",
    recommendation: "Derive LP mint address and verify it matches provided account."
  },
  {
    id: "SOL2104",
    name: "Nested Account Trust Chain",
    severity: "critical",
    pattern: /nested[\s\S]{0,30}account|account[\s\S]{0,30}chain/i,
    description: "Nested account structure breaks trust chain validation.",
    recommendation: "Validate each level of nested accounts independently."
  },
  {
    id: "SOL2105",
    name: "Worthless Collateral Deposit",
    severity: "critical",
    pattern: /deposit[\s\S]{0,50}collateral[\s\S]{0,50}(?!value_check|price_check)/i,
    description: "Worthless tokens can be deposited as collateral.",
    recommendation: "Verify collateral value via oracle before accepting deposits."
  },
  // ========== Crema-style Tick Spoofing (SOL2106-SOL2115) ==========
  {
    id: "SOL2106",
    name: "Tick Account Owner Bypass",
    severity: "critical",
    pattern: /tick(?:_account)?[\s\S]{0,50}(?!owner\s*==|has_one)/i,
    description: "Tick account ownership not verified (Crema $8.8M exploit).",
    recommendation: "Verify tick account is owned by expected pool program."
  },
  {
    id: "SOL2107",
    name: "CLMM Position Spoofing",
    severity: "critical",
    pattern: /(?:clmm|concentrated)[\s\S]{0,50}position[\s\S]{0,50}(?!verify|owner_check)/i,
    description: "CLMM position can be spoofed to claim excess fees.",
    recommendation: "Verify position ownership and tick range before fee claims."
  },
  {
    id: "SOL2108",
    name: "Fee Accumulator Manipulation",
    severity: "critical",
    pattern: /fee(?:_accumulator|_growth)?[\s\S]{0,50}(?:claim|collect|withdraw)/i,
    description: "Fee accumulator can be manipulated via fake tick accounts.",
    recommendation: "Recalculate fees from verified tick data, never trust stored values."
  },
  {
    id: "SOL2109",
    name: "Flash Loan + CLMM Attack",
    severity: "critical",
    pattern: /flash[\s\S]{0,50}(?:clmm|concentrated|tick)/i,
    description: "Flash loans combined with CLMM manipulation.",
    recommendation: "Add flash loan protection to CLMM fee calculation."
  },
  {
    id: "SOL2110",
    name: "Tick Range Validation",
    severity: "high",
    pattern: /tick(?:_lower|_upper|_range)[\s\S]{0,50}(?!validate|check|verify)/i,
    description: "Tick range not validated for positions.",
    recommendation: "Verify tick indices are within valid pool range."
  },
  {
    id: "SOL2111",
    name: "Liquidity Delta Overflow",
    severity: "high",
    pattern: /liquidity[\s\S]{0,30}(?:delta|change|add|remove)/i,
    description: "Liquidity delta calculation can overflow.",
    recommendation: "Use checked math for all liquidity calculations."
  },
  {
    id: "SOL2112",
    name: "Sqrt Price Manipulation",
    severity: "high",
    pattern: /sqrt_price|sqrtPrice[\s\S]{0,50}(?!bounds|validate)/i,
    description: "Square root price can be manipulated beyond bounds.",
    recommendation: "Validate sqrt price against tick bounds after operations."
  },
  {
    id: "SOL2113",
    name: "Pool Swap Fee Extraction",
    severity: "high",
    pattern: /swap_fee|pool_fee[\s\S]{0,50}(?:extract|claim|withdraw)/i,
    description: "Protocol fees can be extracted improperly.",
    recommendation: "Only allow fee extraction through verified admin functions."
  },
  {
    id: "SOL2114",
    name: "Observation Account Staleness",
    severity: "medium",
    pattern: /observation[\s\S]{0,50}(?:oracle|twap)/i,
    description: "Observation/oracle data may be stale.",
    recommendation: "Check observation timestamp before using TWAP data."
  },
  {
    id: "SOL2115",
    name: "Position NFT Authority",
    severity: "high",
    pattern: /position[\s\S]{0,30}(?:nft|token)[\s\S]{0,30}(?:authority|owner)/i,
    description: "Position NFT authority can be bypassed.",
    recommendation: "Verify NFT owner matches position authority on all operations."
  },
  // ========== Program Closure Risks (SOL2116-SOL2125) ==========
  {
    id: "SOL2116",
    name: "Accidental Program Close",
    severity: "critical",
    pattern: /solana\s+program\s+close|close.*program/i,
    description: "Program can be accidentally closed, locking all funds (OptiFi $661K).",
    recommendation: "Add deployment review process with multiple approvers."
  },
  {
    id: "SOL2117",
    name: "PDA Fund Recovery",
    severity: "high",
    pattern: /pda[\s\S]{0,50}(?:close|recovery|rescue)/i,
    description: "Funds in PDAs may be unrecoverable if program is closed.",
    recommendation: "Design escape hatches that work even if program is closed."
  },
  {
    id: "SOL2118",
    name: "Upgrade Authority Lock",
    severity: "high",
    pattern: /upgrade_authority[\s\S]{0,50}(?:=|set|revoke)/i,
    description: "Upgrade authority can be revoked, making bugs permanent.",
    recommendation: "Use multisig for upgrade authority, never fully revoke on mainnet."
  },
  {
    id: "SOL2119",
    name: "Program Data Account",
    severity: "medium",
    pattern: /program_data|ProgramData/i,
    description: "Program data account manipulation risks.",
    recommendation: "Verify program data account in deployment scripts."
  },
  {
    id: "SOL2120",
    name: "Buffer Account Cleanup",
    severity: "low",
    pattern: /buffer[\s\S]{0,30}(?:close|cleanup|recover)/i,
    description: "Buffer accounts not cleaned up after deployment.",
    recommendation: "Close buffer accounts after successful deployment to recover rent."
  },
  {
    id: "SOL2121",
    name: "Deployment Script Validation",
    severity: "high",
    pattern: /deploy[\s\S]{0,50}(?:script|mainnet)/i,
    description: "Deployment scripts may contain dangerous commands.",
    recommendation: "Review deployment scripts with multiple team members."
  },
  {
    id: "SOL2122",
    name: "Program Signer Seeds",
    severity: "medium",
    pattern: /program_signer|signer_seeds/i,
    description: "Program signer seeds must be consistent across upgrades.",
    recommendation: "Document and version all PDA seeds used by program."
  },
  {
    id: "SOL2123",
    name: "Close Authority Transfer",
    severity: "critical",
    pattern: /close_authority[\s\S]{0,50}(?:transfer|set|change)/i,
    description: "Close authority can be transferred to attacker.",
    recommendation: "Close authority should only be PDA or multisig."
  },
  {
    id: "SOL2124",
    name: "Immutable Program State",
    severity: "medium",
    pattern: /immutable[\s\S]{0,30}(?:state|config)/i,
    description: "Immutable state cannot be fixed if buggy.",
    recommendation: "Design state migration paths for critical data."
  },
  {
    id: "SOL2125",
    name: "Program Freeze Risk",
    severity: "high",
    pattern: /program[\s\S]{0,30}freeze|freeze[\s\S]{0,30}program/i,
    description: "Program can be frozen, halting all operations.",
    recommendation: "Implement emergency functions that work even when frozen."
  },
  // ========== 2025 DeFi Emerging Patterns (SOL2126-SOL2140) ==========
  {
    id: "SOL2126",
    name: "Intent-Based Order Manipulation",
    severity: "high",
    pattern: /intent[\s\S]{0,50}(?:order|swap|trade)/i,
    description: "Intent-based orders can be manipulated by solvers.",
    recommendation: "Validate solver execution against user intent parameters."
  },
  {
    id: "SOL2127",
    name: "Restaking Slash Cascade",
    severity: "critical",
    pattern: /restaking[\s\S]{0,50}(?:slash|penalty)/i,
    description: "Restaking slashing can cascade across protocols.",
    recommendation: "Implement slashing caps and circuit breakers."
  },
  {
    id: "SOL2128",
    name: "LRT Depeg Attack",
    severity: "high",
    pattern: /(?:lrt|liquid_restaking)[\s\S]{0,50}(?:price|peg|exchange)/i,
    description: "Liquid restaking tokens can depeg under stress.",
    recommendation: "Use oracle prices not DEX prices for LRT valuation."
  },
  {
    id: "SOL2129",
    name: "Points Manipulation",
    severity: "medium",
    pattern: /(?:points|airdrop)[\s\S]{0,50}(?:farm|accumulate|boost)/i,
    description: "Points/airdrop farming can be gamed.",
    recommendation: "Add anti-sybil measures and time-weighted calculations."
  },
  {
    id: "SOL2130",
    name: "NFT Lending Liquidation",
    severity: "high",
    pattern: /nft[\s\S]{0,50}(?:lending|borrow|collateral)[\s\S]{0,50}liquidat/i,
    description: "NFT lending liquidations can be manipulated via floor price.",
    recommendation: "Use TWAP floor price and multiple oracle sources for NFT valuations."
  },
  {
    id: "SOL2131",
    name: "Perpetual Funding Rate Attack",
    severity: "high",
    pattern: /funding(?:_rate)?[\s\S]{0,50}(?:manipulat|attack|exploit)/i,
    description: "Perpetual funding rate can be manipulated to extract value.",
    recommendation: "Cap funding rate changes and use time-weighted averages."
  },
  {
    id: "SOL2132",
    name: "Synthetic Asset Oracle Depeg",
    severity: "critical",
    pattern: /synthetic[\s\S]{0,50}(?:oracle|price|peg)/i,
    description: "Synthetic assets can depeg if oracle is manipulated.",
    recommendation: "Use circuit breakers and multiple price sources for synths."
  },
  {
    id: "SOL2133",
    name: "RWA Token Redemption",
    severity: "high",
    pattern: /rwa|real_world[\s\S]{0,50}(?:redeem|withdraw|claim)/i,
    description: "Real-world asset token redemption may not be honored.",
    recommendation: "Verify legal backing and maintain reserve attestations."
  },
  {
    id: "SOL2134",
    name: "Social Token Rugpull",
    severity: "high",
    pattern: /social[\s\S]{0,30}token[\s\S]{0,50}(?:mint|authority)/i,
    description: "Social/creator tokens can be rugged by creator.",
    recommendation: "Lock mint authority or use bonding curve with locked liquidity."
  },
  {
    id: "SOL2135",
    name: "Prediction Market Settlement",
    severity: "high",
    pattern: /prediction[\s\S]{0,50}(?:settle|resolve|outcome)/i,
    description: "Prediction market settlement can be manipulated.",
    recommendation: "Use decentralized oracle networks for settlement."
  },
  {
    id: "SOL2136",
    name: "Blink Action Validation",
    severity: "medium",
    pattern: /blink[\s\S]{0,50}action[\s\S]{0,50}(?!validate|verify)/i,
    description: "Solana Blink actions may not validate parameters.",
    recommendation: "Validate all blink action parameters server-side."
  },
  {
    id: "SOL2137",
    name: "Compressed NFT Proof",
    severity: "high",
    pattern: /cnft|compressed[\s\S]{0,30}nft[\s\S]{0,50}(?:proof|verify)/i,
    description: "Compressed NFT merkle proofs must be verified.",
    recommendation: "Always verify cNFT proofs against current merkle root."
  },
  {
    id: "SOL2138",
    name: "Token-2022 Extension Conflict",
    severity: "medium",
    pattern: /token_2022[\s\S]{0,50}extension[\s\S]{0,50}(?:conflict|incompatible)/i,
    description: "Token-2022 extension combinations may conflict.",
    recommendation: "Test all extension combinations for compatibility."
  },
  {
    id: "SOL2139",
    name: "Lookup Table Poisoning",
    severity: "high",
    pattern: /lookup_table|address_lookup[\s\S]{0,50}(?!verify|validate)/i,
    description: "Address lookup tables can be poisoned with malicious addresses.",
    recommendation: "Verify lookup table authority before use in transactions."
  },
  {
    id: "SOL2140",
    name: "Priority Fee Griefing",
    severity: "medium",
    pattern: /priority[\s\S]{0,30}fee[\s\S]{0,50}(?:bid|auction|spam)/i,
    description: "Priority fee bidding can be used to grief transactions.",
    recommendation: "Implement transaction bundles and private mempools."
  }
];
function checkBatch54Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_54_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-55.ts
var BATCH_55_PATTERNS = [
  // ========== arXiv Academic Findings (SOL2141-SOL2160) ==========
  {
    id: "SOL2141",
    name: "arXiv: Deprecated Library Usage",
    severity: "medium",
    pattern: /solana_program\s*=\s*"1\.[0-8]\./i,
    description: "Using deprecated solana_program version. arXiv:2504.07419 identifies outdated dependencies as common vulnerability source.",
    recommendation: "Upgrade to solana_program >= 1.14 for latest security fixes."
  },
  {
    id: "SOL2142",
    name: "arXiv: Soteria-Detectable Missing Signer",
    severity: "critical",
    pattern: /pub\s+authority\s*:\s*AccountInfo(?![\s\S]{0,30}Signer|[\s\S]{0,30}is_signer)/i,
    description: "Authority account without signer check. Soteria (SEC) tool from arXiv paper detects this pattern.",
    recommendation: "Use Signer<'info> type or manually verify is_signer."
  },
  {
    id: "SOL2143",
    name: "arXiv: Radar-Detectable Type Confusion",
    severity: "high",
    pattern: /try_from_slice[\s\S]{0,50}(?!discriminator|match|if\s+\w+\[\d+\])/i,
    description: "Deserializing account data without discriminator check. Radar tool from arXiv detects type confusion.",
    recommendation: "Verify 8-byte discriminator before deserialization."
  },
  {
    id: "SOL2144",
    name: "arXiv: Anchor Privilege Escalation",
    severity: "critical",
    pattern: /#\[account\([\s\S]{0,100}mut[\s\S]{0,100}\)\][\s\S]{0,200}(?!has_one|constraint)/i,
    description: "Mutable account in Anchor without relationship constraints. arXiv identifies privilege escalation risk.",
    recommendation: "Add has_one or constraint checks for mutable accounts."
  },
  {
    id: "SOL2145",
    name: "arXiv: Laminar Static Analysis Gap",
    severity: "high",
    pattern: /invoke(?:_signed)?[\s\S]{0,100}accounts[\s\S]{0,50}\[/i,
    description: "Dynamic account indexing in CPI calls bypasses static analysis tools like Laminar.",
    recommendation: "Use named account references instead of array indexing."
  },
  {
    id: "SOL2146",
    name: "arXiv: Solana eBPF Syscall Abuse",
    severity: "critical",
    pattern: /sol_invoke_signed_c|syscall|sol_log_|sol_sha256/i,
    description: "Direct syscall usage bypasses Anchor safety. arXiv notes syscall abuse in native programs.",
    recommendation: "Use high-level Anchor abstractions when possible."
  },
  {
    id: "SOL2147",
    name: "arXiv: Insufficient Program Verification",
    severity: "critical",
    pattern: /UncheckedAccount[\s\S]{0,100}invoke(?![\s\S]{0,50}program\.key\(\)\s*==)/i,
    description: "CPI with unchecked account and no program ID verification. arXiv Table 3 lists this.",
    recommendation: "Verify target program ID before CPI calls."
  },
  {
    id: "SOL2148",
    name: "arXiv: Arithmetic Wrapping in Release",
    severity: "high",
    pattern: /\+|\-|\*(?![\s\S]{0,20}checked_|saturating_|wrapping_)[\s\S]{0,50}(?:balance|amount|supply)/i,
    description: "Arithmetic on financial values. Rust release mode wraps on overflow (arXiv Section 3.1.4).",
    recommendation: "Use checked_add/sub/mul for all financial calculations."
  },
  {
    id: "SOL2149",
    name: "arXiv: SEC Tool False Negative Area",
    severity: "medium",
    pattern: /AccountInfo<'info>[\s\S]{0,200}(?:if|match|require!)[\s\S]{0,100}owner/i,
    description: "Complex ownership check that static analyzers may miss. arXiv notes SEC tool gaps.",
    recommendation: "Ensure ownership checks are explicit and early in function."
  },
  {
    id: "SOL2150",
    name: "arXiv: Cross-Contract Vulnerability",
    severity: "critical",
    pattern: /invoke[\s\S]{0,200}state[\s\S]{0,50}=[\s\S]{0,50}(?!reload|refresh)/i,
    description: "State mutation after CPI without reload. arXiv identifies cross-contract vulnerabilities.",
    recommendation: "Reload account state after any CPI call."
  },
  {
    id: "SOL2151",
    name: "arXiv: Missing Bump Canonicalization",
    severity: "high",
    pattern: /bump\s*:\s*u8[\s\S]{0,100}(?!find_program_address|canonical)/i,
    description: "Bump stored without canonicalization. arXiv Section 3.2.2 PDA vulnerabilities.",
    recommendation: "Always use canonical bump from find_program_address."
  },
  {
    id: "SOL2152",
    name: "arXiv: Rent Exemption Bypass",
    severity: "medium",
    pattern: /lamports[\s\S]{0,50}(?:transfer|sub)[\s\S]{0,100}(?!minimum_balance|rent_exempt)/i,
    description: "Lamport transfer without rent check. arXiv notes account eviction vulnerability.",
    recommendation: "Verify account remains rent-exempt after transfers."
  },
  {
    id: "SOL2153",
    name: "arXiv: Reinitialization Attack Vector",
    severity: "critical",
    pattern: /is_initialized\s*=\s*true[\s\S]{0,200}(?!require!.*is_initialized\s*==\s*false)/i,
    description: "Setting initialized without checking prior state. arXiv cross-instance reinit attack.",
    recommendation: "Check is_initialized == false before initialization."
  },
  {
    id: "SOL2154",
    name: "arXiv: Tool Detection Comparison Gap",
    severity: "medium",
    pattern: /#\[program\][\s\S]{0,500}(?:anchor_lang|solana_program)/i,
    description: "Program using both Anchor and native. arXiv shows tool coverage gaps at boundaries.",
    recommendation: "Use consistent framework throughout program."
  },
  {
    id: "SOL2155",
    name: "arXiv: EVM vs Solana Reentrancy Difference",
    severity: "high",
    pattern: /invoke[\s\S]{0,100}(?:transfer|send)[\s\S]{0,200}state[\s\S]{0,50}=/i,
    description: "Solana reentrancy differs from EVM. arXiv notes developers assume EVM patterns apply.",
    recommendation: "Update state before CPI, even though Solana prevents recursive calls."
  },
  {
    id: "SOL2156",
    name: "arXiv: Security Tool Coverage Gap",
    severity: "low",
    pattern: /#\[cfg\(test\)\][\s\S]{0,500}(?!fuzzing|property)/i,
    description: "Tests without fuzzing. arXiv Table 4 shows limited tool coverage for complex vulns.",
    recommendation: "Add property-based testing and fuzzing with Trident."
  },
  {
    id: "SOL2157",
    name: "arXiv: Solana vs Ethereum Account Model",
    severity: "medium",
    pattern: /msg\.sender|tx\.origin/i,
    description: "EVM patterns in Solana code. arXiv emphasizes account model differences.",
    recommendation: "Use Solana account model: explicit signers and PDAs."
  },
  {
    id: "SOL2158",
    name: "arXiv: Instruction Data Validation",
    severity: "high",
    pattern: /instruction_data[\s\S]{0,50}try_from_slice[\s\S]{0,100}(?!validate|check|require)/i,
    description: "Deserializing instruction data without validation. arXiv input validation category.",
    recommendation: "Validate all instruction data fields after deserialization."
  },
  {
    id: "SOL2159",
    name: "arXiv: Compute Budget Vulnerability",
    severity: "medium",
    pattern: /for[\s\S]{0,30}in[\s\S]{0,50}\.iter\(\)[\s\S]{0,200}(?!\.take\(|\.limit|MAX_)/i,
    description: "Unbounded iteration. arXiv notes compute budget exhaustion attacks.",
    recommendation: "Add iteration limits to prevent DoS attacks."
  },
  {
    id: "SOL2160",
    name: "arXiv: Tool Ecosystem Maturity Gap",
    severity: "low",
    pattern: /\/\/\s*(?:TODO|FIXME|HACK|XXX)[\s\S]{0,50}security/i,
    description: "Security-related TODO comments. arXiv notes Solana tooling less mature than Ethereum.",
    recommendation: "Address all security TODOs before deployment."
  },
  // ========== Sealevel Attack Patterns (SOL2161-SOL2175) ==========
  {
    id: "SOL2161",
    name: "Sealevel: Duplicate Mutable Accounts",
    severity: "critical",
    pattern: /#\[account\(mut\)\][\s\S]{0,300}#\[account\(mut\)\][\s\S]{0,100}(?!constraint\s*=.*!=)/i,
    description: "Two mutable accounts of same type without inequality constraint. Armani Sealevel attack #2.",
    recommendation: "Add constraint: constraint = account_a.key() != account_b.key()"
  },
  {
    id: "SOL2162",
    name: "Sealevel: Account Type Confusion",
    severity: "critical",
    pattern: /Account<[\s\S]{0,30}>[\s\S]{0,100}try_from[\s\S]{0,50}(?!discriminator)/i,
    description: "Account deserialization without type verification. Sealevel attack #3.",
    recommendation: "Use Anchor Account<T> type or verify discriminator manually."
  },
  {
    id: "SOL2163",
    name: "Sealevel: Sysvar Address Spoofing",
    severity: "critical",
    pattern: /(?:rent|clock|slot_hashes)[\s\S]{0,50}AccountInfo[\s\S]{0,100}(?!Sysvar::id\(\)|check_id)/i,
    description: "Sysvar passed as AccountInfo without address verification. Sealevel attack #4.",
    recommendation: "Use Sysvar<Rent> type or verify sysvar.key() == Sysvar::id()"
  },
  {
    id: "SOL2164",
    name: "Sealevel: Arbitrary Program CPI",
    severity: "critical",
    pattern: /invoke[\s\S]{0,100}program[\s\S]{0,50}\.key\(\)[\s\S]{0,100}(?!==|require!|assert!)/i,
    description: "CPI to program without address verification. Sealevel attack #5.",
    recommendation: "Hardcode expected program ID or verify against allowlist."
  },
  {
    id: "SOL2165",
    name: "Sealevel: PDA Not Verified",
    severity: "high",
    pattern: /seeds\s*=[\s\S]{0,100}(?!bump|find_program_address)/i,
    description: "PDA seeds without bump verification. Sealevel attack #6.",
    recommendation: "Store and verify canonical bump seed."
  },
  {
    id: "SOL2166",
    name: "Sealevel: Bump Seed Canonicalization",
    severity: "high",
    pattern: /bump\s*:\s*\d+|bump\s*=\s*(?!ctx\.bumps|bump_seed)/i,
    description: "Hardcoded bump seed instead of canonical. Sealevel attack #7.",
    recommendation: "Use find_program_address to get canonical bump."
  },
  {
    id: "SOL2167",
    name: "Sealevel: Close Account Resurrection",
    severity: "critical",
    pattern: /close\s*=[\s\S]{0,100}(?!zero_copy|memset|\.fill\(0\))/i,
    description: "Account closure without zeroing data. Sealevel attack #8.",
    recommendation: "Zero account data before closing to prevent resurrection."
  },
  {
    id: "SOL2168",
    name: "Sealevel: Missing Owner Check",
    severity: "critical",
    pattern: /AccountInfo[\s\S]{0,200}data[\s\S]{0,100}(?!owner\s*==|check_owner)/i,
    description: "Reading account data without owner verification. Sealevel attack #1.",
    recommendation: "Verify account.owner == expected_program before reading data."
  },
  {
    id: "SOL2169",
    name: "Sealevel: Token Account Verification",
    severity: "high",
    pattern: /TokenAccount[\s\S]{0,100}(?!token::mint\s*=|token::authority\s*=)/i,
    description: "Token account without mint/authority constraints. Armani tip.",
    recommendation: "Add token::mint and token::authority constraints."
  },
  {
    id: "SOL2170",
    name: "Sealevel: Associated Token Account",
    severity: "high",
    pattern: /associated_token_account|ata[\s\S]{0,100}(?!associated_token::)/i,
    description: "ATA without proper Anchor constraint. Creates confusion with other PDAs.",
    recommendation: "Use associated_token::mint and associated_token::authority."
  },
  {
    id: "SOL2171",
    name: "Sealevel: Init If Needed Race",
    severity: "high",
    pattern: /init_if_needed[\s\S]{0,200}(?!realloc::zero\s*=\s*true)/i,
    description: "init_if_needed without zero initialization. Race condition vulnerability.",
    recommendation: "Avoid init_if_needed or ensure proper initialization."
  },
  {
    id: "SOL2172",
    name: "Sealevel: Realloc Vulnerability",
    severity: "high",
    pattern: /realloc\s*=[\s\S]{0,100}(?!realloc::zero\s*=\s*true)/i,
    description: "Account realloc without zeroing new space. Data leak vulnerability.",
    recommendation: "Add realloc::zero = true to zero new space."
  },
  {
    id: "SOL2173",
    name: "Sealevel: Constraint Ordering",
    severity: "medium",
    pattern: /#\[account\([\s\S]{0,100}constraint[\s\S]{0,100}init/i,
    description: "Constraint before init. Anchor processes attributes in order.",
    recommendation: "Place init before constraint in account attributes."
  },
  {
    id: "SOL2174",
    name: "Sealevel: Seeds Constraint Missing",
    severity: "high",
    pattern: /seeds\s*=[\s\S]{0,100}(?!seeds::program)/i,
    description: "PDA seeds without program specification. Cross-program PDA confusion.",
    recommendation: "Add seeds::program = program_id for clarity."
  },
  {
    id: "SOL2175",
    name: "Sealevel: Account Constraint Error",
    severity: "medium",
    pattern: /constraint\s*=[\s\S]{0,100}(?!@\s*\w+Error)/i,
    description: "Constraint without custom error message. Debugging difficulty.",
    recommendation: "Add custom error: constraint = condition @ CustomError::Name"
  },
  // ========== Audit-Derived Patterns (SOL2176-SOL2195) ==========
  {
    id: "SOL2176",
    name: "Kudelski: Unvalidated Reference Accounts",
    severity: "high",
    pattern: /\/\/\/\s*CHECK[\s\S]{0,50}(?:reference|read|info)/i,
    description: "Reference-only account without validation. Kudelski Solana Program Security.",
    recommendation: "Verify reference accounts even if read-only."
  },
  {
    id: "SOL2177",
    name: "Neodyme: Rounding Direction Attack",
    severity: "critical",
    pattern: /(?:div|\/)\s*\d+[\s\S]{0,50}(?:mint|transfer|withdraw)/i,
    description: "Division before token operation. Neodyme $2.6B rounding vulnerability.",
    recommendation: "Use explicit floor/ceil and favor protocol in rounding."
  },
  {
    id: "SOL2178",
    name: "OtterSec: LP Oracle Manipulation",
    severity: "critical",
    pattern: /lp_token|liquidity_pool[\s\S]{0,100}price[\s\S]{0,100}(?!fair|twap|virtual)/i,
    description: "LP token price without fair pricing. OtterSec $200M oracle manipulation.",
    recommendation: "Use virtual reserves for LP token valuation."
  },
  {
    id: "SOL2179",
    name: "Sec3: Business Logic State Machine",
    severity: "high",
    pattern: /status|state[\s\S]{0,50}=[\s\S]{0,50}(?:active|pending|complete)(?![\s\S]{0,100}match|require)/i,
    description: "State transition without validation. Sec3 2025: 38.5% are business logic bugs.",
    recommendation: "Implement explicit state machine with valid transitions."
  },
  {
    id: "SOL2180",
    name: "Sec3: Economic Invariant Violation",
    severity: "critical",
    pattern: /(?:supply|balance|reserve)[\s\S]{0,100}(?:\+|\-|=)[\s\S]{0,100}(?!invariant|assert)/i,
    description: "Economic value change without invariant check. Sec3 business logic category.",
    recommendation: "Assert economic invariants after every value change."
  },
  {
    id: "SOL2181",
    name: "Zellic: Anchor Vulnerability Patterns",
    severity: "high",
    pattern: /#\[account\][\s\S]{0,100}pub[\s\S]{0,50}:[\s\S]{0,50}Account<[\s\S]{0,50}>(?![\s\S]{0,100}constraint|has_one)/i,
    description: "Anchor account without additional constraints. Zellic vulnerability research.",
    recommendation: "Add has_one, constraint, or other validation."
  },
  {
    id: "SOL2182",
    name: "Trail of Bits: DeFi Composability Risk",
    severity: "high",
    pattern: /invoke[\s\S]{0,200}invoke[\s\S]{0,200}invoke/i,
    description: "Multiple nested CPI calls. Trail of Bits DeFi composability concerns.",
    recommendation: "Limit CPI depth and verify all intermediate states."
  },
  {
    id: "SOL2183",
    name: "Halborn: Admin Key Compromise",
    severity: "critical",
    pattern: /admin|owner|authority[\s\S]{0,50}(?:transfer|set|update)[\s\S]{0,100}(?!multisig|timelock|governance)/i,
    description: "Single admin key can change critical parameters. Halborn audit finding.",
    recommendation: "Use multisig or timelock for admin operations."
  },
  {
    id: "SOL2184",
    name: "Bramah: Stable Swap Invariant",
    severity: "high",
    pattern: /stable_swap|curve[\s\S]{0,100}(?:swap|exchange)[\s\S]{0,100}(?!invariant|amplification)/i,
    description: "Stable swap without invariant verification. Bramah Saber audit.",
    recommendation: "Verify StableSwap invariant after every operation."
  },
  {
    id: "SOL2185",
    name: "Quantstamp: Reward Distribution Drift",
    severity: "medium",
    pattern: /reward[\s\S]{0,50}(?:per_token|rate|index)[\s\S]{0,100}(?!update|refresh|sync)/i,
    description: "Reward calculation without update. Quantstamp Quarry audit.",
    recommendation: "Update reward index before any staking operation."
  },
  {
    id: "SOL2186",
    name: "SlowMist: Oracle Freshness",
    severity: "high",
    pattern: /oracle|price[\s\S]{0,50}(?:get|fetch|read)[\s\S]{0,100}(?!staleness|age|timestamp)/i,
    description: "Oracle data without freshness check. SlowMist Larix audit.",
    recommendation: "Verify oracle data is within acceptable staleness window."
  },
  {
    id: "SOL2187",
    name: "HashCloak: ZK Proof Verification",
    severity: "critical",
    pattern: /zk|zero_knowledge|proof[\s\S]{0,100}(?:verify|check)[\s\S]{0,100}(?!require!|assert!)/i,
    description: "ZK proof verification without failure handling. HashCloak Light audit.",
    recommendation: "Always assert ZK proof verification succeeds."
  },
  {
    id: "SOL2188",
    name: "Certik: Reentrancy Guard Missing",
    severity: "high",
    pattern: /pub\s+fn\s+\w+[\s\S]{0,300}invoke[\s\S]{0,200}self[\s\S]{0,50}(?:state|data|balance)/i,
    description: "State modification after CPI without guard. Certik Francium audit.",
    recommendation: "Use reentrancy guard or update state before CPI."
  },
  {
    id: "SOL2189",
    name: "Opcodes: Vesting Cliff Bypass",
    severity: "high",
    pattern: /vesting|cliff[\s\S]{0,100}(?:withdraw|claim)[\s\S]{0,100}(?!timestamp|block|slot)/i,
    description: "Vesting withdrawal without time verification. Opcodes Streamflow audit.",
    recommendation: "Check cliff and vesting schedule before allowing withdrawals."
  },
  {
    id: "SOL2190",
    name: "MadShield: NFT Staking Duration",
    severity: "medium",
    pattern: /nft[\s\S]{0,50}(?:stake|lock)[\s\S]{0,100}(?:unstake|unlock)[\s\S]{0,100}(?!duration|period|cooldown)/i,
    description: "NFT unstaking without lockup period. MadShield Genopets audit.",
    recommendation: "Enforce minimum staking duration for NFTs."
  },
  {
    id: "SOL2191",
    name: "Ackee: Fuzzing Discovery Gap",
    severity: "medium",
    pattern: /#\[cfg\(test\)\][\s\S]{0,1000}#\[test\][\s\S]{0,500}(?!proptest|arbitrary|fuzz)/i,
    description: "Unit tests without property-based testing. Ackee audit methodology.",
    recommendation: "Add Trident fuzzing or proptest for comprehensive testing."
  },
  {
    id: "SOL2192",
    name: "Audit: Emergency Pause Missing",
    severity: "high",
    pattern: /pub\s+fn\s+(?:swap|transfer|withdraw|deposit)[\s\S]{0,200}(?!paused|emergency|frozen)/i,
    description: "Critical function without pause check. Common audit finding.",
    recommendation: "Add emergency pause capability to all critical functions."
  },
  {
    id: "SOL2193",
    name: "Audit: Fee Precision Loss",
    severity: "medium",
    pattern: /fee[\s\S]{0,50}(?:\*|\/)\s*\d+[\s\S]{0,50}(?!\d{4,}|1e|10000)/i,
    description: "Fee calculation with low precision. Audit precision loss finding.",
    recommendation: "Use basis points (10000) or higher precision for fees."
  },
  {
    id: "SOL2194",
    name: "Audit: Liquidation Threshold",
    severity: "high",
    pattern: /liquidat[\s\S]{0,50}(?:threshold|factor|ratio)[\s\S]{0,50}(?:=|:)[\s\S]{0,30}(?!require|assert|check)/i,
    description: "Liquidation threshold without bounds validation. Common lending audit.",
    recommendation: "Validate threshold is within safe bounds (e.g., 50-90%)."
  },
  {
    id: "SOL2195",
    name: "Audit: Collateral Factor Timelock",
    severity: "high",
    pattern: /collateral_factor|ltv[\s\S]{0,50}(?:set|update)[\s\S]{0,100}(?!timelock|delay|governance)/i,
    description: "Collateral factor change without timelock. Lending audit finding.",
    recommendation: "Add timelock for collateral factor changes."
  },
  // ========== 2025 Emerging Attack Vectors (SOL2196-SOL2210) ==========
  {
    id: "SOL2196",
    name: "2025: Jito Client Concentration Risk",
    severity: "medium",
    pattern: /validator|stake[\s\S]{0,100}(?:jito|mev)[\s\S]{0,100}(?!diversif|multiple)/i,
    description: "Jito client has 88% validator dominance. Sec3 2025 concentration risk.",
    recommendation: "Consider MEV client diversity for protocol resilience."
  },
  {
    id: "SOL2197",
    name: "2025: Hosting Provider Concentration",
    severity: "medium",
    pattern: /teraswitch|latitude[\s\S]{0,50}|hosting[\s\S]{0,50}provider/i,
    description: "43% stake on two hosting providers. Sec3 2025 infrastructure risk.",
    recommendation: "Diversify infrastructure providers for network resilience."
  },
  {
    id: "SOL2198",
    name: "2025: Token-2022 Confidential Leaks",
    severity: "high",
    pattern: /confidential_transfer|ElGamalCiphertext[\s\S]{0,100}(?!decrypt|verify_range)/i,
    description: "Token-2022 confidential transfers require proper range proofs.",
    recommendation: "Verify all range proofs in confidential transfer handling."
  },
  {
    id: "SOL2199",
    name: "2025: Transfer Hook Reentrancy",
    severity: "critical",
    pattern: /transfer_hook|TransferHook[\s\S]{0,200}(?:invoke|call)[\s\S]{0,100}(?!guard|lock)/i,
    description: "Token-2022 transfer hooks can enable reentrancy.",
    recommendation: "Add reentrancy guard when handling transfer hooks."
  },
  {
    id: "SOL2200",
    name: "2025: cNFT Merkle Proof Manipulation",
    severity: "high",
    pattern: /merkle_proof|compressed_nft[\s\S]{0,100}(?:verify|validate)[\s\S]{0,100}(?!canopy|root)/i,
    description: "Compressed NFT proof verification without canopy.",
    recommendation: "Verify merkle proofs against on-chain canopy or root."
  },
  {
    id: "SOL2201",
    name: "2025: Blink Action URL Injection",
    severity: "high",
    pattern: /blink|action_url|solana:[\s\S]{0,100}(?!sanitize|validate|whitelist)/i,
    description: "Solana Blink action URLs without validation.",
    recommendation: "Sanitize and whitelist Blink action URLs."
  },
  {
    id: "SOL2202",
    name: "2025: Lookup Table Poisoning",
    severity: "critical",
    pattern: /address_lookup_table|alt[\s\S]{0,100}(?:extend|create)[\s\S]{0,100}(?!authority)/i,
    description: "Address lookup table modification without authority check.",
    recommendation: "Verify ALT authority before extension operations."
  },
  {
    id: "SOL2203",
    name: "2025: Priority Fee Manipulation",
    severity: "medium",
    pattern: /priority_fee|compute_budget[\s\S]{0,100}set[\s\S]{0,100}(?!cap|max|limit)/i,
    description: "Priority fee setting without caps enables griefing.",
    recommendation: "Cap priority fees to prevent economic attacks."
  },
  {
    id: "SOL2204",
    name: "2025: Durable Nonce Replay",
    severity: "high",
    pattern: /durable_nonce|nonce_account[\s\S]{0,100}(?:advance|use)[\s\S]{0,100}(?!authority)/i,
    description: "Durable nonce without authority verification.",
    recommendation: "Verify nonce authority before advancing."
  },
  {
    id: "SOL2205",
    name: "2025: Versioned Transaction Confusion",
    severity: "medium",
    pattern: /VersionedTransaction|legacy[\s\S]{0,100}(?:convert|handle)[\s\S]{0,100}(?!version|check)/i,
    description: "Mixed legacy and versioned transaction handling.",
    recommendation: "Explicitly handle transaction versioning."
  },
  {
    id: "SOL2206",
    name: "2025: Restaking Slashing Cascade",
    severity: "high",
    pattern: /restake|liquid_staking[\s\S]{0,100}(?:slash|penalty)[\s\S]{0,100}(?!isolation|cap)/i,
    description: "Restaking protocols can cascade slashing events.",
    recommendation: "Isolate slashing risk and cap per-validator exposure."
  },
  {
    id: "SOL2207",
    name: "2025: AI Agent Wallet Security",
    severity: "critical",
    pattern: /agent|bot[\s\S]{0,50}(?:wallet|keypair)[\s\S]{0,100}(?!hardware|multisig|threshold)/i,
    description: "AI agent wallets without hardware security.",
    recommendation: "Use hardware wallets or MPC for agent key management."
  },
  {
    id: "SOL2208",
    name: "2025: Meme Coin Rug Detection",
    severity: "high",
    pattern: /pump\.fun|bonding_curve[\s\S]{0,100}(?:migration|graduate)[\s\S]{0,100}(?!lock|timelock)/i,
    description: "Meme coin launch without migration protection.",
    recommendation: "Add timelock or multisig for liquidity migration."
  },
  {
    id: "SOL2209",
    name: "2025: Flash Loan Oracle Window",
    severity: "critical",
    pattern: /flash_loan[\s\S]{0,200}(?:price|oracle)[\s\S]{0,100}(?!twap|window|delay)/i,
    description: "Flash loans can manipulate single-block prices.",
    recommendation: "Use TWAP oracles spanning multiple slots."
  },
  {
    id: "SOL2210",
    name: "2025: Cross-Program Invocation Depth",
    severity: "medium",
    pattern: /invoke[\s\S]{0,100}invoke[\s\S]{0,100}invoke[\s\S]{0,100}invoke/i,
    description: "Deep CPI nesting increases attack surface.",
    recommendation: "Limit CPI depth to 4 or fewer for security and compute."
  }
];
function checkBatch55Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_55_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_55_COUNT = BATCH_55_PATTERNS.length;

// src/patterns/solana-batched-patterns-56.ts
var BATCH_56_PATTERNS = [
  // ========== PoC Framework Patterns (SOL2211-SOL2230) ==========
  {
    id: "SOL2211",
    name: "PoC: Port Max Withdraw Bug",
    severity: "critical",
    pattern: /max_withdraw|withdraw_max[\s\S]{0,100}(?:calculate|compute)[\s\S]{0,100}(?!floor|ceil)/i,
    description: "Max withdraw calculation without rounding direction. Port Finance PoC.",
    recommendation: "Use floor for withdraw calculations to prevent overdraft."
  },
  {
    id: "SOL2212",
    name: "PoC: Jet Governance Token Lock",
    severity: "high",
    pattern: /governance[\s\S]{0,50}token[\s\S]{0,50}(?:lock|escrow)[\s\S]{0,100}(?!duration|until)/i,
    description: "Governance token locking without duration. Jet Governance PoC.",
    recommendation: "Enforce minimum lock duration for governance participation."
  },
  {
    id: "SOL2213",
    name: "PoC: Cashio Infinite Mint",
    severity: "critical",
    pattern: /collateral[\s\S]{0,100}(?:deposit|provide)[\s\S]{0,100}(?:mint|issue)[\s\S]{0,100}(?!verify_root|whitelist)/i,
    description: "Collateral deposit leading to mint without root verification. Cashio PoC.",
    recommendation: "Verify collateral is in trusted mint whitelist."
  },
  {
    id: "SOL2214",
    name: "PoC: SPL Token-Lending Rounding",
    severity: "critical",
    pattern: /(?:collateral|liquidity)[\s\S]{0,50}(?:ratio|value)[\s\S]{0,50}(?:div|\/)\s*\d+/i,
    description: "Collateral value division. Neodyme $2.6B rounding PoC.",
    recommendation: "Multiply before divide, use floor for protocol benefit."
  },
  {
    id: "SOL2215",
    name: "PoC: Cope Roulette Revert",
    severity: "medium",
    pattern: /roulette|random[\s\S]{0,100}(?:win|lose|outcome)[\s\S]{0,100}(?!commit|reveal)/i,
    description: "Random outcome without commit-reveal. Cope Roulette exploit.",
    recommendation: "Use commit-reveal scheme for random outcomes."
  },
  {
    id: "SOL2216",
    name: "PoC: Simulation Detection Bypass",
    severity: "high",
    pattern: /simulation|preflight[\s\S]{0,100}(?:detect|check)[\s\S]{0,100}(?!bank|slot)/i,
    description: "Simulation detection without bank context. Opcodes research.",
    recommendation: "Check bank state to detect simulation vs execution."
  },
  {
    id: "SOL2217",
    name: "PoC: Authority Delegation Chain",
    severity: "high",
    pattern: /delegate[\s\S]{0,50}authority[\s\S]{0,100}(?:chain|nested|recursive)/i,
    description: "Authority delegation allowing chains. Multi-hop vulnerability.",
    recommendation: "Limit delegation depth to prevent authority confusion."
  },
  {
    id: "SOL2218",
    name: "PoC: Token Approval Persistence",
    severity: "medium",
    pattern: /approve[\s\S]{0,50}delegate[\s\S]{0,100}(?!revoke|clear|reset)/i,
    description: "Token approval without revocation mechanism. Hana revoken research.",
    recommendation: "Provide clear approval revocation mechanism."
  },
  {
    id: "SOL2219",
    name: "PoC: Stake Pool Semantic Bug",
    severity: "high",
    pattern: /stake_pool[\s\S]{0,100}(?:deposit|withdraw)[\s\S]{0,100}(?!validator_list|stake_list)/i,
    description: "Stake pool operation without list verification. Sec3 Stake Pool PoC.",
    recommendation: "Verify stake account is in pool validator list."
  },
  {
    id: "SOL2220",
    name: "PoC: Lending Market Spoofing",
    severity: "critical",
    pattern: /lending_market[\s\S]{0,100}(?:create|init)[\s\S]{0,100}(?!authority|owner\s*==)/i,
    description: "Lending market creation without authority binding. Solend exploit.",
    recommendation: "Permanently bind lending market to authority at creation."
  },
  {
    id: "SOL2221",
    name: "PoC: Oracle Price Staleness",
    severity: "high",
    pattern: /price[\s\S]{0,50}(?:get|fetch)[\s\S]{0,100}(?:age|stale|fresh|timestamp)/i,
    description: "Price fetching with staleness check present but may be insufficient.",
    recommendation: "Use strict staleness bounds (e.g., 30 seconds for DeFi)."
  },
  {
    id: "SOL2222",
    name: "PoC: LP Token Manipulation",
    severity: "critical",
    pattern: /lp_token[\s\S]{0,100}(?:value|worth|price)[\s\S]{0,50}(?:total_supply|reserve)/i,
    description: "LP token value from reserves. OtterSec $200M manipulation PoC.",
    recommendation: "Use virtual reserves or geometric mean for LP pricing."
  },
  {
    id: "SOL2223",
    name: "PoC: Malicious Lending Market",
    severity: "critical",
    pattern: /malicious[\s\S]{0,50}(?:market|pool|reserve)|fake_(?:market|pool)/i,
    description: "Malicious market pattern. Solend Rooter disclosure.",
    recommendation: "Verify market authenticity via on-chain registry."
  },
  {
    id: "SOL2224",
    name: "PoC: Guardian Quorum Bypass",
    severity: "critical",
    pattern: /guardian[\s\S]{0,100}(?:verify|check)[\s\S]{0,100}(?:signature|quorum)[\s\S]{0,100}(?!\d+\s*\/\s*\d+|threshold)/i,
    description: "Guardian verification without quorum threshold. Wormhole pattern.",
    recommendation: "Enforce minimum guardian signature quorum (e.g., 13/19)."
  },
  {
    id: "SOL2225",
    name: "PoC: SignatureSet Fabrication",
    severity: "critical",
    pattern: /signature_set|SignatureSet[\s\S]{0,100}(?:create|init)[\s\S]{0,100}(?!verify|validate)/i,
    description: "SignatureSet creation without verification. Wormhole $326M exploit.",
    recommendation: "Verify all signatures before creating SignatureSet."
  },
  {
    id: "SOL2226",
    name: "PoC: CLMM Tick Manipulation",
    severity: "critical",
    pattern: /tick[\s\S]{0,50}(?:account|data)[\s\S]{0,100}(?:fee|liquidity)[\s\S]{0,100}(?!owner\s*==)/i,
    description: "Tick account access without ownership. Crema $8.8M exploit.",
    recommendation: "Verify tick account ownership before fee operations."
  },
  {
    id: "SOL2227",
    name: "PoC: Bonding Curve Flash Loan",
    severity: "critical",
    pattern: /bonding_curve[\s\S]{0,100}(?:buy|mint)[\s\S]{0,100}(?!flash_loan_check|same_block)/i,
    description: "Bonding curve without flash loan protection. Nirvana exploit.",
    recommendation: "Add flash loan detection or multi-block price averaging."
  },
  {
    id: "SOL2228",
    name: "PoC: Perp Mark Price Manipulation",
    severity: "critical",
    pattern: /mark_price|perp[\s\S]{0,100}(?:price|funding)[\s\S]{0,100}(?!oracle|twap|window)/i,
    description: "Perpetual mark price without oracle verification. Mango pattern.",
    recommendation: "Use oracle TWAP for mark price calculation."
  },
  {
    id: "SOL2229",
    name: "PoC: Self-Trading Detection",
    severity: "high",
    pattern: /(?:buy|sell|trade)[\s\S]{0,200}(?:buy|sell|trade)[\s\S]{0,100}(?!different_owner|anti_self)/i,
    description: "Trading without self-trade prevention. Mango Markets exploit.",
    recommendation: "Detect and prevent self-trading for price manipulation."
  },
  {
    id: "SOL2230",
    name: "PoC: Unrealized PnL Collateral",
    severity: "critical",
    pattern: /unrealized[\s\S]{0,50}(?:pnl|profit)[\s\S]{0,100}(?:collateral|borrow)/i,
    description: "Using unrealized PnL as collateral. Mango Markets attack vector.",
    recommendation: "Only use realized PnL for collateral calculations."
  },
  // ========== Protocol-Specific Exploits (SOL2231-SOL2255) ==========
  {
    id: "SOL2231",
    name: "Pyth: Confidence Interval Check",
    severity: "high",
    pattern: /pyth[\s\S]{0,100}(?:price|feed)[\s\S]{0,100}(?!conf|confidence|uncertainty)/i,
    description: "Pyth oracle without confidence interval check. Drift guardrails.",
    recommendation: "Reject prices with confidence > price * threshold."
  },
  {
    id: "SOL2232",
    name: "Switchboard: Aggregator Staleness",
    severity: "high",
    pattern: /switchboard[\s\S]{0,100}(?:aggregator|feed)[\s\S]{0,100}(?!latest_confirmed_round|staleness)/i,
    description: "Switchboard aggregator without staleness check.",
    recommendation: "Check latest_confirmed_round timestamp."
  },
  {
    id: "SOL2233",
    name: "Marinade: mSOL Pricing Attack",
    severity: "high",
    pattern: /msol|marinade[\s\S]{0,100}(?:price|rate)[\s\S]{0,100}(?!exchange_rate|virtual)/i,
    description: "mSOL pricing without exchange rate verification.",
    recommendation: "Use Marinade exchange rate from stake pool."
  },
  {
    id: "SOL2234",
    name: "Jupiter: Route Manipulation",
    severity: "high",
    pattern: /jupiter[\s\S]{0,100}(?:route|swap)[\s\S]{0,100}(?!slippage|min_out)/i,
    description: "Jupiter swap without slippage protection.",
    recommendation: "Always specify minimum output amount."
  },
  {
    id: "SOL2235",
    name: "Drift: Oracle Guard Rails",
    severity: "high",
    pattern: /drift[\s\S]{0,100}oracle[\s\S]{0,100}(?!guard|validity|too_volatile)/i,
    description: "Drift-style oracle without guard rails.",
    recommendation: "Implement oracle validity checks like Drift."
  },
  {
    id: "SOL2236",
    name: "Solend: Reserve Refresh",
    severity: "high",
    pattern: /reserve[\s\S]{0,100}(?:interest|rate)[\s\S]{0,100}(?!refresh|accrue|update)/i,
    description: "Reserve state without interest refresh.",
    recommendation: "Refresh reserve state before rate-sensitive operations."
  },
  {
    id: "SOL2237",
    name: "Port: Variable Rate Model",
    severity: "medium",
    pattern: /interest_rate[\s\S]{0,100}(?:model|curve)[\s\S]{0,100}(?!bounds|cap|floor)/i,
    description: "Interest rate model without bounds.",
    recommendation: "Cap interest rates at reasonable maximum."
  },
  {
    id: "SOL2238",
    name: "Jet: Margin Account Isolation",
    severity: "high",
    pattern: /margin[\s\S]{0,50}account[\s\S]{0,100}(?:position|collateral)[\s\S]{0,100}(?!isolation|separate)/i,
    description: "Margin accounts without position isolation.",
    recommendation: "Isolate positions to prevent cross-contamination."
  },
  {
    id: "SOL2239",
    name: "Orca: Whirlpool Tick Array",
    severity: "medium",
    pattern: /tick_array|whirlpool[\s\S]{0,100}(?:swap|trade)[\s\S]{0,100}(?!initialized|valid)/i,
    description: "Whirlpool swap without tick array validation.",
    recommendation: "Verify tick arrays are initialized and valid."
  },
  {
    id: "SOL2240",
    name: "Raydium: Pool Authority Leak",
    severity: "critical",
    pattern: /pool_authority|raydium[\s\S]{0,100}(?:admin|owner)[\s\S]{0,100}(?!multisig|timelock)/i,
    description: "Raydium-style pool without admin protection. $4.4M exploit.",
    recommendation: "Use multisig for pool administration."
  },
  {
    id: "SOL2241",
    name: "Saber: Stable Swap A Factor",
    severity: "medium",
    pattern: /amplification|a_factor[\s\S]{0,100}(?:set|update)[\s\S]{0,100}(?!ramp|gradual)/i,
    description: "Amplification factor change without ramp.",
    recommendation: "Gradually ramp A factor changes over time."
  },
  {
    id: "SOL2242",
    name: "Metaplex: Collection Authority",
    severity: "high",
    pattern: /collection[\s\S]{0,50}(?:verify|authority)[\s\S]{0,100}(?!update_authority|creator)/i,
    description: "NFT collection verification gap.",
    recommendation: "Verify collection authority matches expected."
  },
  {
    id: "SOL2243",
    name: "Magic Eden: Royalty Enforcement",
    severity: "medium",
    pattern: /royalt[\s\S]{0,50}(?:check|enforce)[\s\S]{0,100}(?!pnft|programmable)/i,
    description: "NFT royalty enforcement gap.",
    recommendation: "Use pNFTs for enforced royalties."
  },
  {
    id: "SOL2244",
    name: "Tensor: Compressed NFT Proof",
    severity: "high",
    pattern: /cnft|compressed[\s\S]{0,50}nft[\s\S]{0,100}(?:transfer|burn)[\s\S]{0,100}(?!proof|canopy)/i,
    description: "Compressed NFT operation without proof.",
    recommendation: "Verify merkle proof for all cNFT operations."
  },
  {
    id: "SOL2245",
    name: "Phoenix: Order Book Crossing",
    severity: "high",
    pattern: /order_book|orderbook[\s\S]{0,100}(?:match|cross)[\s\S]{0,100}(?!self_trade|wash)/i,
    description: "Order book without wash trading prevention.",
    recommendation: "Detect and prevent self-crossing orders."
  },
  {
    id: "SOL2246",
    name: "Zeta: Greeks Calculation",
    severity: "medium",
    pattern: /(?:delta|gamma|theta|vega)[\s\S]{0,100}(?:calculate|compute)[\s\S]{0,100}(?!black_scholes|model)/i,
    description: "Options greeks without proper model.",
    recommendation: "Use validated Black-Scholes or similar model."
  },
  {
    id: "SOL2247",
    name: "Friktion: Vault Epoch Transition",
    severity: "high",
    pattern: /vault[\s\S]{0,50}epoch[\s\S]{0,100}(?:transition|settle)[\s\S]{0,100}(?!lock|freeze)/i,
    description: "Vault epoch transition without locking.",
    recommendation: "Lock deposits during epoch transitions."
  },
  {
    id: "SOL2248",
    name: "Mango V4: Health Factor",
    severity: "high",
    pattern: /health[\s\S]{0,50}(?:factor|ratio)[\s\S]{0,100}(?:check|verify)[\s\S]{0,100}(?!before|prior)/i,
    description: "Health factor checked after operation.",
    recommendation: "Check health factor before allowing position changes."
  },
  {
    id: "SOL2249",
    name: "Tulip: Strategy Migration",
    severity: "high",
    pattern: /strategy[\s\S]{0,50}(?:migrate|upgrade)[\s\S]{0,100}(?!lock|pause|governance)/i,
    description: "Strategy migration without safeguards.",
    recommendation: "Require governance and lockup for migrations."
  },
  {
    id: "SOL2250",
    name: "UXD: Peg Mechanism",
    severity: "high",
    pattern: /peg|stablecoin[\s\S]{0,100}(?:mint|redeem)[\s\S]{0,100}(?!delta_neutral|hedge)/i,
    description: "Stablecoin without delta-neutral hedging.",
    recommendation: "Maintain delta-neutral position for peg stability."
  },
  {
    id: "SOL2251",
    name: "Hubble: Multi-Collateral CDP",
    severity: "high",
    pattern: /cdp|collateral_debt[\s\S]{0,100}(?:multiple|multi)[\s\S]{0,100}(?!correlation|risk)/i,
    description: "Multi-collateral CDP without correlation risk.",
    recommendation: "Account for collateral correlation in risk model."
  },
  {
    id: "SOL2252",
    name: "Hedge: Stability Pool Drain",
    severity: "high",
    pattern: /stability_pool[\s\S]{0,100}(?:withdraw|drain)[\s\S]{0,100}(?!cooldown|limit)/i,
    description: "Stability pool without withdrawal limits.",
    recommendation: "Add cooldown and rate limits for withdrawals."
  },
  {
    id: "SOL2253",
    name: "Invariant: Concentrated Liquidity",
    severity: "medium",
    pattern: /concentrated[\s\S]{0,50}liquidity[\s\S]{0,100}(?:position|range)[\s\S]{0,100}(?!fee_growth|fees_owed)/i,
    description: "Concentrated liquidity without fee tracking.",
    recommendation: "Track fee growth per tick for accurate rewards."
  },
  {
    id: "SOL2254",
    name: "Cropper: Fee Precision",
    severity: "medium",
    pattern: /fee[\s\S]{0,50}(?:numerator|rate)[\s\S]{0,50}(?:\/|div)\s*(?:denominator|\d+)/i,
    description: "Fee calculation precision loss.",
    recommendation: "Use high precision (1e9+) for fee calculations."
  },
  {
    id: "SOL2255",
    name: "Swim: Cross-Chain Token Mapping",
    severity: "high",
    pattern: /cross_chain[\s\S]{0,100}(?:token|mint)[\s\S]{0,100}(?:map|registry)[\s\S]{0,100}(?!verify|authentic)/i,
    description: "Cross-chain token without authenticity verification.",
    recommendation: "Verify token mapping in trusted registry."
  },
  // ========== Advanced DeFi Attack Vectors (SOL2256-SOL2280) ==========
  {
    id: "SOL2256",
    name: "Flash Loan Atomic Arbitrage",
    severity: "high",
    pattern: /flash_loan[\s\S]{0,200}(?:swap|exchange)[\s\S]{0,200}(?:repay)/i,
    description: "Flash loan arbitrage pattern detected.",
    recommendation: "Ensure flash loan repayment verification is atomic."
  },
  {
    id: "SOL2257",
    name: "Sandwich Attack Vector",
    severity: "high",
    pattern: /swap[\s\S]{0,100}(?:slippage|price_impact)[\s\S]{0,100}(?:tolerance|limit)/i,
    description: "Swap with slippage tolerance enables sandwiching.",
    recommendation: "Use private transactions or MEV protection."
  },
  {
    id: "SOL2258",
    name: "JIT Liquidity Attack",
    severity: "medium",
    pattern: /liquidity[\s\S]{0,50}(?:add|provide)[\s\S]{0,100}(?:same_tx|atomic)/i,
    description: "Just-in-time liquidity provision.",
    recommendation: "Add minimum liquidity duration requirements."
  },
  {
    id: "SOL2259",
    name: "Time-Bandit Reorganization",
    severity: "high",
    pattern: /(?:finality|confirmation)[\s\S]{0,100}(?:wait|require)[\s\S]{0,50}\d+/i,
    description: "Transaction finality assumption vulnerability.",
    recommendation: "Wait for sufficient confirmations for large values."
  },
  {
    id: "SOL2260",
    name: "Liquidation Auction Manipulation",
    severity: "high",
    pattern: /liquidation[\s\S]{0,50}(?:auction|bid)[\s\S]{0,100}(?!dutch|reserve)/i,
    description: "Liquidation auction without fair pricing.",
    recommendation: "Use Dutch auction with reserve price."
  },
  {
    id: "SOL2261",
    name: "Interest Rate Spike",
    severity: "high",
    pattern: /interest[\s\S]{0,50}rate[\s\S]{0,100}(?:utilization|borrow)[\s\S]{0,100}(?!max|cap|ceiling)/i,
    description: "Interest rate model without spike protection.",
    recommendation: "Cap maximum interest rate during high utilization."
  },
  {
    id: "SOL2262",
    name: "Governance Token Concentration",
    severity: "medium",
    pattern: /governance[\s\S]{0,50}(?:vote|power)[\s\S]{0,100}(?!delegation|decay)/i,
    description: "Governance without vote decay.",
    recommendation: "Implement vote decay or quadratic voting."
  },
  {
    id: "SOL2263",
    name: "Proposal Execution Delay",
    severity: "high",
    pattern: /proposal[\s\S]{0,50}(?:execute|enact)[\s\S]{0,100}(?!timelock|delay|queue)/i,
    description: "Proposal execution without delay.",
    recommendation: "Add timelock delay for governance execution."
  },
  {
    id: "SOL2264",
    name: "Vault Share Inflation",
    severity: "critical",
    pattern: /vault[\s\S]{0,50}(?:deposit|mint)[\s\S]{0,100}(?:first_deposit|initial)[\s\S]{0,100}(?!minimum|seed)/i,
    description: "First depositor can inflate vault shares.",
    recommendation: "Seed vault with minimum deposit or use dead shares."
  },
  {
    id: "SOL2265",
    name: "Donation Attack",
    severity: "high",
    pattern: /(?:balance|reserve)[\s\S]{0,100}(?:get|read)[\s\S]{0,100}(?!expected|tracked)/i,
    description: "Using balance instead of tracked reserves.",
    recommendation: "Track reserves internally, not from balance."
  },
  {
    id: "SOL2266",
    name: "Price Oracle TWAP Window",
    severity: "high",
    pattern: /twap[\s\S]{0,100}(?:window|period)[\s\S]{0,50}(?:\d+)/i,
    description: "TWAP window may be too short for security.",
    recommendation: "Use minimum 30-minute TWAP for DeFi pricing."
  },
  {
    id: "SOL2267",
    name: "Collateral Factor Manipulation",
    severity: "high",
    pattern: /collateral_factor[\s\S]{0,100}(?:volatile|risky)[\s\S]{0,100}(?!reduce|conservative)/i,
    description: "High collateral factor for volatile assets.",
    recommendation: "Use conservative collateral factors (< 70%)."
  },
  {
    id: "SOL2268",
    name: "Insurance Fund Depletion",
    severity: "critical",
    pattern: /insurance[\s\S]{0,50}fund[\s\S]{0,100}(?:withdraw|use)[\s\S]{0,100}(?!threshold|minimum)/i,
    description: "Insurance fund without minimum threshold.",
    recommendation: "Maintain minimum insurance fund coverage."
  },
  {
    id: "SOL2269",
    name: "Debt Ceiling Bypass",
    severity: "high",
    pattern: /debt[\s\S]{0,50}(?:ceiling|cap|limit)[\s\S]{0,100}(?!check|require|assert)/i,
    description: "Debt ceiling without enforcement.",
    recommendation: "Enforce debt ceiling on every borrow."
  },
  {
    id: "SOL2270",
    name: "Reserve Factor Abuse",
    severity: "medium",
    pattern: /reserve_factor[\s\S]{0,100}(?:set|update)[\s\S]{0,100}(?!governance|timelock)/i,
    description: "Reserve factor changes without governance.",
    recommendation: "Require governance for reserve factor changes."
  },
  {
    id: "SOL2271",
    name: "Lending Pool Isolation",
    severity: "high",
    pattern: /lending[\s\S]{0,50}pool[\s\S]{0,100}(?:share|cross)[\s\S]{0,100}(?!isolated|separate)/i,
    description: "Lending pools sharing risk.",
    recommendation: "Isolate high-risk lending pools."
  },
  {
    id: "SOL2272",
    name: "Yield Strategy Griefing",
    severity: "medium",
    pattern: /yield[\s\S]{0,50}strategy[\s\S]{0,100}(?:harvest|compound)[\s\S]{0,100}(?!threshold|profitable)/i,
    description: "Yield strategy vulnerable to griefing.",
    recommendation: "Add profitability check before harvest."
  },
  {
    id: "SOL2273",
    name: "Perpetual Funding Rate Spike",
    severity: "high",
    pattern: /funding[\s\S]{0,50}rate[\s\S]{0,100}(?:calculate|compute)[\s\S]{0,100}(?!cap|max|clamp)/i,
    description: "Funding rate without caps.",
    recommendation: "Cap funding rate to prevent extreme values."
  },
  {
    id: "SOL2274",
    name: "ADL Priority Manipulation",
    severity: "high",
    pattern: /adl|auto_deleverage[\s\S]{0,100}(?:priority|ranking)[\s\S]{0,100}(?!pnl|profit)/i,
    description: "ADL ranking without PnL consideration.",
    recommendation: "Rank ADL by unrealized PnL percentage."
  },
  {
    id: "SOL2275",
    name: "Position Limit Bypass",
    severity: "high",
    pattern: /position[\s\S]{0,50}(?:limit|max)[\s\S]{0,100}(?!aggregate|total)/i,
    description: "Position limits without aggregation.",
    recommendation: "Aggregate positions across all accounts."
  },
  {
    id: "SOL2276",
    name: "Staking Reward Dilution",
    severity: "medium",
    pattern: /reward[\s\S]{0,50}(?:rate|per_token)[\s\S]{0,100}(?!update_before|sync)/i,
    description: "Staking rewards without pre-update.",
    recommendation: "Update reward rate before stake changes."
  },
  {
    id: "SOL2277",
    name: "Unbonding Period Bypass",
    severity: "high",
    pattern: /unbond[\s\S]{0,100}(?:period|duration)[\s\S]{0,100}(?!enforce|check)/i,
    description: "Unbonding period without enforcement.",
    recommendation: "Strictly enforce unbonding cooldown."
  },
  {
    id: "SOL2278",
    name: "Validator Commission Change",
    severity: "medium",
    pattern: /commission[\s\S]{0,100}(?:change|update)[\s\S]{0,100}(?!delay|epoch)/i,
    description: "Validator commission instant change.",
    recommendation: "Add epoch delay for commission changes."
  },
  {
    id: "SOL2279",
    name: "Stake Pool Withdraw Authority",
    severity: "high",
    pattern: /stake_pool[\s\S]{0,100}(?:withdraw|unstake)[\s\S]{0,100}(?!authority|owner)/i,
    description: "Stake pool withdrawal without authority check.",
    recommendation: "Verify withdraw authority matches depositor."
  },
  {
    id: "SOL2280",
    name: "Delegation Authority Confusion",
    severity: "high",
    pattern: /delegation[\s\S]{0,100}(?:stake|vote)[\s\S]{0,100}(?!authorized|authority)/i,
    description: "Delegation without authority verification.",
    recommendation: "Verify delegation authority before stake operations."
  }
];
function checkBatch56Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_56_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_56_COUNT = BATCH_56_PATTERNS.length;

// src/patterns/solana-batched-patterns-57.ts
var BATCH_57_PATTERNS = [
  // Kudelski Audit Patterns (SOL2281-SOL2295)
  {
    id: "SOL2281",
    name: "Kudelski: Missing Ownership Validation",
    severity: "critical",
    pattern: /AccountInfo[\s\S]{0,100}(?!owner\s*==|\.owner\.eq)/i,
    description: "Account ownership not validated per Kudelski audit methodology.",
    recommendation: "Validate account owner matches expected program ID."
  },
  {
    id: "SOL2282",
    name: "Kudelski: Unvalidated Data Field",
    severity: "high",
    pattern: /data\s*=\s*account[\s\S]{0,50}(?!validate|check|verify)/i,
    description: "Account data accessed without field validation.",
    recommendation: "Validate all account data fields before use."
  },
  {
    id: "SOL2283",
    name: "Kudelski: Missing Stake Pool Validation",
    severity: "high",
    pattern: /stake_pool|StakePool(?![\s\S]{0,100}validator_list)/i,
    description: "Stake pool operations without validator list check.",
    recommendation: "Verify stake pool validator list integrity."
  },
  {
    id: "SOL2284",
    name: "Kudelski: Token Swap Slippage Missing",
    severity: "high",
    pattern: /swap|exchange(?![\s\S]{0,100}minimum_amount|slippage)/i,
    description: "Token swap without slippage protection.",
    recommendation: "Implement minimum output amount checks."
  },
  {
    id: "SOL2285",
    name: "Kudelski: Shared Memory Vulnerability",
    severity: "high",
    pattern: /shared_memory|SharedMemory(?![\s\S]{0,50}validate)/i,
    description: "Shared memory access without validation.",
    recommendation: "Validate shared memory before use."
  },
  {
    id: "SOL2286",
    name: "Kudelski: Synthetify Collateral Check",
    severity: "critical",
    pattern: /synthetic|collateral(?![\s\S]{0,100}ratio|threshold)/i,
    description: "Synthetic asset without collateral ratio check.",
    recommendation: "Enforce minimum collateralization ratios."
  },
  {
    id: "SOL2287",
    name: "Kudelski: Solido Stake Validation",
    severity: "high",
    pattern: /stake_account|StakeAccount(?![\s\S]{0,100}activation_epoch)/i,
    description: "Stake account without activation epoch check.",
    recommendation: "Verify stake account activation status."
  },
  {
    id: "SOL2288",
    name: "Kudelski: Friktion Volt Risk",
    severity: "high",
    pattern: /volt|option(?![\s\S]{0,100}expiry|strike)/i,
    description: "Options vault without expiry validation.",
    recommendation: "Validate option expiry and strike prices."
  },
  {
    id: "SOL2289",
    name: "Kudelski: Hubble Stability Check",
    severity: "high",
    pattern: /stability_pool|StabilityPool(?![\s\S]{0,100}debt_ceiling)/i,
    description: "Stability pool without debt ceiling enforcement.",
    recommendation: "Enforce debt ceiling limits."
  },
  {
    id: "SOL2290",
    name: "Kudelski: Swim Bridge Decimals",
    severity: "medium",
    pattern: /bridge|cross_chain(?![\s\S]{0,100}decimals)/i,
    description: "Cross-chain bridge without decimal normalization.",
    recommendation: "Normalize token decimals across chains."
  },
  {
    id: "SOL2291",
    name: "Kudelski: Marinade Delayed Unstake",
    severity: "medium",
    pattern: /unstake|withdraw_stake(?![\s\S]{0,100}delay|cooldown)/i,
    description: "Unstaking without delay mechanism.",
    recommendation: "Implement unstaking delay period."
  },
  {
    id: "SOL2292",
    name: "Kudelski: Hedge CDP Validation",
    severity: "high",
    pattern: /cdp|vault(?![\s\S]{0,100}health_factor|collateral_ratio)/i,
    description: "CDP without health factor validation.",
    recommendation: "Check vault health factor before operations."
  },
  {
    id: "SOL2293",
    name: "Kudelski: Orca Whirlpool Tick",
    severity: "high",
    pattern: /tick|whirlpool(?![\s\S]{0,100}spacing|bounds)/i,
    description: "Whirlpool tick without bounds checking.",
    recommendation: "Validate tick spacing and bounds."
  },
  {
    id: "SOL2294",
    name: "Kudelski: Aldrin DEX Order",
    severity: "medium",
    pattern: /order_book|OrderBook(?![\s\S]{0,100}expiry|cancel)/i,
    description: "Order book without order expiry handling.",
    recommendation: "Implement order expiry and cancellation."
  },
  {
    id: "SOL2295",
    name: "Kudelski: Audius Governance Race",
    severity: "high",
    pattern: /governance|proposal(?![\s\S]{0,100}snapshot|block_height)/i,
    description: "Governance without snapshot mechanism.",
    recommendation: "Use snapshot-based voting power."
  },
  // Neodyme Audit Patterns (SOL2296-SOL2310)
  {
    id: "SOL2296",
    name: "Neodyme: Mango Oracle Staleness",
    severity: "critical",
    pattern: /oracle|price_feed(?![\s\S]{0,100}last_update|staleness)/i,
    description: "Oracle price without staleness check (Mango pattern).",
    recommendation: "Verify oracle price freshness."
  },
  {
    id: "SOL2297",
    name: "Neodyme: Wormhole SignatureSet",
    severity: "critical",
    pattern: /signature_set|SignatureSet(?![\s\S]{0,100}guardian_count)/i,
    description: "Signature set without guardian count validation.",
    recommendation: "Verify guardian quorum in signature sets."
  },
  {
    id: "SOL2298",
    name: "Neodyme: SPL Lending Precision",
    severity: "high",
    pattern: /interest|rate(?![\s\S]{0,100}precision|decimals)/i,
    description: "Interest rate calculation without precision handling.",
    recommendation: "Use high-precision arithmetic for rates."
  },
  {
    id: "SOL2299",
    name: "Neodyme: Rounding Direction",
    severity: "high",
    pattern: /\.round\(\)|as\s+u\d+(?![\s\S]{0,30}ceil|floor)/i,
    description: "Rounding without explicit direction.",
    recommendation: "Use explicit ceil/floor for financial math."
  },
  {
    id: "SOL2300",
    name: "Neodyme: Debridge Finality",
    severity: "critical",
    pattern: /bridge_message|cross_chain(?![\s\S]{0,100}finalized|confirmations)/i,
    description: "Cross-chain message without finality check.",
    recommendation: "Wait for chain finality before processing."
  },
  {
    id: "SOL2301",
    name: "Neodyme: PoC Attacker Framework",
    severity: "high",
    pattern: /test|poc(?![\s\S]{0,50}assert|expect)/i,
    description: "Test code pattern detected in production.",
    recommendation: "Remove test/PoC code from production."
  },
  {
    id: "SOL2302",
    name: "Neodyme: Common Pitfall Owner",
    severity: "critical",
    pattern: /AccountInfo[\s\S]{0,50}\.key(?![\s\S]{0,30}owner)/i,
    description: "Account key check without owner verification.",
    recommendation: "Always verify account owner with key."
  },
  {
    id: "SOL2303",
    name: "Neodyme: Common Pitfall Signer",
    severity: "critical",
    pattern: /authority|admin(?![\s\S]{0,50}is_signer|Signer)/i,
    description: "Authority without signer check.",
    recommendation: "Verify authority is signer for all admin ops."
  },
  {
    id: "SOL2304",
    name: "Neodyme: Marinade v2 Rate",
    severity: "high",
    pattern: /exchange_rate|conversion(?![\s\S]{0,100}update_time)/i,
    description: "Exchange rate without update time check.",
    recommendation: "Verify rate freshness before conversion."
  },
  {
    id: "SOL2305",
    name: "Neodyme: Solido Validator Selection",
    severity: "medium",
    pattern: /validator|stake_pool(?![\s\S]{0,100}selection|weight)/i,
    description: "Validator selection without weighting.",
    recommendation: "Implement weighted validator selection."
  },
  {
    id: "SOL2306",
    name: "Neodyme: Workshop Level 0",
    severity: "medium",
    pattern: /seeds\s*=\s*\[(?![\s\S]{0,30}bump)/i,
    description: "PDA seeds without bump in derivation.",
    recommendation: "Include bump seed in PDA derivation."
  },
  {
    id: "SOL2307",
    name: "Neodyme: Workshop Level 1",
    severity: "high",
    pattern: /try_borrow|borrow_mut(?![\s\S]{0,50}RefCell)/i,
    description: "Mutable borrow without RefCell pattern.",
    recommendation: "Use RefCell for safe interior mutability."
  },
  {
    id: "SOL2308",
    name: "Neodyme: Workshop Level 2",
    severity: "high",
    pattern: /checked_|saturating_(?![\s\S]{0,20}unwrap_or)/i,
    description: "Checked math without default handling.",
    recommendation: "Handle None case from checked operations."
  },
  {
    id: "SOL2309",
    name: "Neodyme: Workshop Level 3",
    severity: "critical",
    pattern: /invoke_signed[\s\S]{0,100}(?!seeds_with_bump)/i,
    description: "invoke_signed without seeds_with_bump pattern.",
    recommendation: "Use seeds_with_bump for CPI signing."
  },
  {
    id: "SOL2310",
    name: "Neodyme: Workshop Level 4",
    severity: "high",
    pattern: /discriminator[\s\S]{0,50}(?!unique|8\s*bytes)/i,
    description: "Account discriminator may not be unique.",
    recommendation: "Ensure 8-byte unique discriminators."
  },
  // OtterSec Audit Patterns (SOL2311-SOL2325)
  {
    id: "SOL2311",
    name: "OtterSec: LP Token Oracle Manipulation",
    severity: "critical",
    pattern: /lp_token|liquidity_pool(?![\s\S]{0,100}fair_value|sqrt_price)/i,
    description: "LP token valuation vulnerable to manipulation.",
    recommendation: "Use fair LP pricing formula."
  },
  {
    id: "SOL2312",
    name: "OtterSec: Jet Governance PoC",
    severity: "high",
    pattern: /governance|vote(?![\s\S]{0,100}weight_at_slot)/i,
    description: "Governance voting without historical weight.",
    recommendation: "Use slot-based vote weight snapshots."
  },
  {
    id: "SOL2313",
    name: "OtterSec: Cashmere Multisig",
    severity: "high",
    pattern: /multisig|multi_sig(?![\s\S]{0,100}threshold|quorum)/i,
    description: "Multisig without threshold validation.",
    recommendation: "Validate multisig threshold before execution."
  },
  {
    id: "SOL2314",
    name: "OtterSec: Cega Vault Risk",
    severity: "high",
    pattern: /vault|strategy(?![\s\S]{0,100}max_deposit|cap)/i,
    description: "Vault without deposit cap enforcement.",
    recommendation: "Enforce vault deposit caps."
  },
  {
    id: "SOL2315",
    name: "OtterSec: Port Sundial Oracle",
    severity: "high",
    pattern: /sundial|fixed_rate(?![\s\S]{0,100}oracle_source)/i,
    description: "Fixed rate without oracle source validation.",
    recommendation: "Validate oracle sources for rate feeds."
  },
  {
    id: "SOL2316",
    name: "OtterSec: Juiced Yield Risk",
    severity: "medium",
    pattern: /yield|apy(?![\s\S]{0,100}sustainable|cap)/i,
    description: "Yield strategy without sustainability check.",
    recommendation: "Validate yield sustainability."
  },
  {
    id: "SOL2317",
    name: "OtterSec: Solvent NFT Fractionalization",
    severity: "high",
    pattern: /fractionalize|nft_shares(?![\s\S]{0,100}total_supply)/i,
    description: "NFT fractionalization without supply tracking.",
    recommendation: "Track total fractional shares accurately."
  },
  {
    id: "SOL2318",
    name: "OtterSec: Squads MPL Authority",
    severity: "high",
    pattern: /squad|multisig(?![\s\S]{0,100}member_count)/i,
    description: "Squad without member count validation.",
    recommendation: "Validate squad member count for quorum."
  },
  {
    id: "SOL2319",
    name: "OtterSec: Phoenix Order Matching",
    severity: "high",
    pattern: /order_matching|match_order(?![\s\S]{0,100}price_time_priority)/i,
    description: "Order matching without price-time priority.",
    recommendation: "Implement proper order matching rules."
  },
  {
    id: "SOL2320",
    name: "OtterSec: Bottomless Pit Attack",
    severity: "critical",
    pattern: /pool|liquidity(?![\s\S]{0,100}minimum_liquidity)/i,
    description: "Pool without minimum liquidity protection.",
    recommendation: "Lock minimum liquidity to prevent draining."
  },
  {
    id: "SOL2321",
    name: "OtterSec: Auditor Perspective Entry",
    severity: "medium",
    pattern: /entrypoint|process_instruction(?![\s\S]{0,100}verify_accounts)/i,
    description: "Entry point without account verification.",
    recommendation: "Verify all accounts at entry point."
  },
  {
    id: "SOL2322",
    name: "OtterSec: CPI Return Value",
    severity: "high",
    pattern: /invoke|invoke_signed(?![\s\S]{0,50}\?|Result)/i,
    description: "CPI without error handling.",
    recommendation: "Handle CPI return values with ?."
  },
  {
    id: "SOL2323",
    name: "OtterSec: Account Lifecycle",
    severity: "high",
    pattern: /close_account|close\s*=(?![\s\S]{0,100}rent_destination)/i,
    description: "Account closure without rent destination.",
    recommendation: "Specify rent destination on account close."
  },
  {
    id: "SOL2324",
    name: "OtterSec: State Machine Transition",
    severity: "high",
    pattern: /state\s*=|status\s*=(?![\s\S]{0,50}valid_transition)/i,
    description: "State transition without validation.",
    recommendation: "Validate state machine transitions."
  },
  {
    id: "SOL2325",
    name: "OtterSec: Event Ordering",
    severity: "low",
    pattern: /emit!|msg!(?![\s\S]{0,30}after.*state)/i,
    description: "Event emitted before state finalized.",
    recommendation: "Emit events after state changes complete."
  },
  // Bramah Systems Audit Patterns (SOL2326-SOL2335)
  {
    id: "SOL2326",
    name: "Bramah: Crema Fee Accumulator",
    severity: "high",
    pattern: /fee_accumulator|accumulated_fee(?![\s\S]{0,100}overflow)/i,
    description: "Fee accumulator vulnerable to overflow.",
    recommendation: "Use checked math for fee accumulation."
  },
  {
    id: "SOL2327",
    name: "Bramah: Saber StableSwap Invariant",
    severity: "critical",
    pattern: /stable_swap|curve(?![\s\S]{0,100}invariant_check)/i,
    description: "StableSwap without invariant verification.",
    recommendation: "Verify curve invariant after operations."
  },
  {
    id: "SOL2328",
    name: "Bramah: Maple Loan Maturity",
    severity: "high",
    pattern: /loan|borrow(?![\s\S]{0,100}maturity|due_date)/i,
    description: "Loan without maturity date enforcement.",
    recommendation: "Enforce loan maturity dates."
  },
  {
    id: "SOL2329",
    name: "Bramah: Solido Validator Score",
    severity: "medium",
    pattern: /validator_score|performance(?![\s\S]{0,100}update_period)/i,
    description: "Validator score without update period.",
    recommendation: "Implement score update intervals."
  },
  {
    id: "SOL2330",
    name: "Bramah: Emergency Shutdown",
    severity: "medium",
    pattern: /emergency|pause(?![\s\S]{0,100}guardian|multisig)/i,
    description: "Emergency shutdown without guardian.",
    recommendation: "Require guardian/multisig for emergency."
  },
  {
    id: "SOL2331",
    name: "Bramah: Rate Limit Bypass",
    severity: "high",
    pattern: /rate_limit|throttle(?![\s\S]{0,100}per_epoch|per_slot)/i,
    description: "Rate limit without time-based enforcement.",
    recommendation: "Implement slot/epoch-based rate limits."
  },
  {
    id: "SOL2332",
    name: "Bramah: Collateral Rebalance",
    severity: "high",
    pattern: /rebalance|collateral(?![\s\S]{0,100}atomic)/i,
    description: "Collateral rebalance not atomic.",
    recommendation: "Make collateral operations atomic."
  },
  {
    id: "SOL2333",
    name: "Bramah: LP Share Dilution",
    severity: "high",
    pattern: /lp_shares|mint_lp(?![\s\S]{0,100}total_supply_check)/i,
    description: "LP share minting without supply check.",
    recommendation: "Check total supply before minting shares."
  },
  {
    id: "SOL2334",
    name: "Bramah: Auction Reserve Price",
    severity: "high",
    pattern: /auction|bid(?![\s\S]{0,100}reserve_price|minimum_bid)/i,
    description: "Auction without reserve price.",
    recommendation: "Set minimum reserve price for auctions."
  },
  {
    id: "SOL2335",
    name: "Bramah: Insurance Fund",
    severity: "medium",
    pattern: /insurance|coverage(?![\s\S]{0,100}fund_balance)/i,
    description: "Insurance without fund balance check.",
    recommendation: "Verify insurance fund solvency."
  },
  // Halborn Audit Patterns (SOL2336-SOL2350)
  {
    id: "SOL2336",
    name: "Halborn: Cropper AMM Invariant",
    severity: "critical",
    pattern: /amm|swap(?![\s\S]{0,100}constant_product|xy=k)/i,
    description: "AMM without constant product invariant.",
    recommendation: "Verify xy=k invariant on all swaps."
  },
  {
    id: "SOL2337",
    name: "Halborn: GooseFX Swap Router",
    severity: "high",
    pattern: /router|swap_route(?![\s\S]{0,100}path_validation)/i,
    description: "Swap router without path validation.",
    recommendation: "Validate all swap path components."
  },
  {
    id: "SOL2338",
    name: "Halborn: Parrot Protocol Debt",
    severity: "high",
    pattern: /debt|borrow(?![\s\S]{0,100}debt_ceiling)/i,
    description: "Protocol without debt ceiling.",
    recommendation: "Enforce protocol-wide debt ceiling."
  },
  {
    id: "SOL2339",
    name: "Halborn: Phantasia NFT Store",
    severity: "medium",
    pattern: /nft_store|marketplace(?![\s\S]{0,100}listing_validation)/i,
    description: "NFT store without listing validation.",
    recommendation: "Validate NFT listings before sale."
  },
  {
    id: "SOL2340",
    name: "Halborn: Wormhole Guardian Rotation",
    severity: "critical",
    pattern: /guardian_set|guardians(?![\s\S]{0,100}rotation_delay)/i,
    description: "Guardian set without rotation delay.",
    recommendation: "Implement guardian rotation delay."
  },
  {
    id: "SOL2341",
    name: "Halborn: Cross-Chain Replay",
    severity: "critical",
    pattern: /cross_chain|bridge(?![\s\S]{0,100}chain_id|nonce)/i,
    description: "Cross-chain message without replay protection.",
    recommendation: "Include chain ID and nonce in messages."
  },
  {
    id: "SOL2342",
    name: "Halborn: Token Extension Conflict",
    severity: "high",
    pattern: /token_2022|extension(?![\s\S]{0,100}compatible)/i,
    description: "Token-2022 extension compatibility not checked.",
    recommendation: "Verify extension compatibility."
  },
  {
    id: "SOL2343",
    name: "Halborn: Metadata URI Injection",
    severity: "medium",
    pattern: /metadata_uri|uri(?![\s\S]{0,100}sanitize|validate)/i,
    description: "Metadata URI without sanitization.",
    recommendation: "Sanitize all metadata URIs."
  },
  {
    id: "SOL2344",
    name: "Halborn: Royalty Enforcement",
    severity: "high",
    pattern: /royalty|creator_fee(?![\s\S]{0,100}enforced|required)/i,
    description: "Royalty not enforced on transfer.",
    recommendation: "Use enforced royalty standards."
  },
  {
    id: "SOL2345",
    name: "Halborn: Program Upgrade Window",
    severity: "medium",
    pattern: /upgrade|set_authority(?![\s\S]{0,100}timelock|delay)/i,
    description: "Program upgrade without timelock.",
    recommendation: "Implement upgrade timelock."
  },
  {
    id: "SOL2346",
    name: "Halborn: Treasury Sweep",
    severity: "high",
    pattern: /treasury|sweep(?![\s\S]{0,100}recipient_validation)/i,
    description: "Treasury sweep without recipient check.",
    recommendation: "Validate treasury sweep recipients."
  },
  {
    id: "SOL2347",
    name: "Halborn: Staking Reward Calculation",
    severity: "high",
    pattern: /staking_reward|reward_rate(?![\s\S]{0,100}per_share)/i,
    description: "Staking reward not using per-share calculation.",
    recommendation: "Use reward-per-share for fairness."
  },
  {
    id: "SOL2348",
    name: "Halborn: Flash Mint Detection",
    severity: "critical",
    pattern: /flash_mint|instant_mint(?![\s\S]{0,100}burn_required)/i,
    description: "Flash mint without burn verification.",
    recommendation: "Verify flash mint is burned same tx."
  },
  {
    id: "SOL2349",
    name: "Halborn: Order Book DOS",
    severity: "high",
    pattern: /order_book|orders(?![\s\S]{0,100}max_orders|limit)/i,
    description: "Order book without order limit.",
    recommendation: "Limit orders per user/market."
  },
  {
    id: "SOL2350",
    name: "Halborn: Account Rent Attack",
    severity: "medium",
    pattern: /create_account|init(?![\s\S]{0,100}rent_exempt_check)/i,
    description: "Account creation without rent exemption check.",
    recommendation: "Verify rent-exempt minimum on creation."
  }
];
function checkBatch57Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_57_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_57_COUNT = BATCH_57_PATTERNS.length;

// src/patterns/solana-batched-patterns-58.ts
var BATCH_58_PATTERNS = [
  // 2025-2026 Latest Exploit Patterns (SOL2351-SOL2370)
  {
    id: "SOL2351",
    name: "Step Finance Treasury Pattern ($40M)",
    severity: "critical",
    pattern: /treasury|admin_wallet(?![\s\S]{0,100}multisig|timelock)/i,
    description: "Treasury without multisig protection (Step Finance pattern).",
    recommendation: "Use multisig + timelock for all treasury operations."
  },
  {
    id: "SOL2352",
    name: "Authority Transfer Phishing",
    severity: "critical",
    pattern: /set_authority|transfer_authority(?![\s\S]{0,100}two_step|pending)/i,
    description: "Authority transfer without two-step confirmation.",
    recommendation: "Implement two-step authority transfer with pending state."
  },
  {
    id: "SOL2353",
    name: "Owner Permission Spoofing",
    severity: "critical",
    pattern: /owner\s*=|authority\s*=(?![\s\S]{0,50}verify_signature)/i,
    description: "Owner field manipulation without signature verification.",
    recommendation: "Verify signatures for all authority changes."
  },
  {
    id: "SOL2354",
    name: "Transaction Simulation Bypass",
    severity: "high",
    pattern: /simulation|simulate(?![\s\S]{0,100}production_check)/i,
    description: "Transaction may behave differently in simulation vs production.",
    recommendation: "Add simulation detection safeguards."
  },
  {
    id: "SOL2355",
    name: "NoOnes Escrow Pattern ($8.5M)",
    severity: "critical",
    pattern: /escrow|p2p(?![\s\S]{0,100}release_verification)/i,
    description: "Escrow release without proper verification.",
    recommendation: "Implement multi-party escrow release verification."
  },
  {
    id: "SOL2356",
    name: "Loopscale Admin Launch ($5.8M)",
    severity: "critical",
    pattern: /launch|deploy(?![\s\S]{0,100}admin_rotation|key_ceremony)/i,
    description: "Protocol launch without admin key rotation.",
    recommendation: "Rotate admin keys post-launch."
  },
  {
    id: "SOL2357",
    name: "NPM Crypto-Clipper 2025",
    severity: "critical",
    pattern: /npm|package(?![\s\S]{0,100}integrity|checksum)/i,
    description: "NPM dependency without integrity verification.",
    recommendation: "Verify package checksums and use lockfiles."
  },
  {
    id: "SOL2358",
    name: "Pump.fun Early Withdrawal ($1.9M)",
    severity: "high",
    pattern: /bonding_curve|launch(?![\s\S]{0,100}lock_period|vesting)/i,
    description: "Token launch without liquidity lock.",
    recommendation: "Implement liquidity lock period."
  },
  {
    id: "SOL2359",
    name: "Banana Gun Bot Pattern ($1.4M)",
    severity: "high",
    pattern: /bot|trading_bot(?![\s\S]{0,100}session_validation)/i,
    description: "Trading bot without session validation.",
    recommendation: "Implement secure session management."
  },
  {
    id: "SOL2360",
    name: "Thunder Terminal MongoDB ($240K)",
    severity: "high",
    pattern: /mongodb|database(?![\s\S]{0,100}encrypted|tls)/i,
    description: "Database connection without encryption.",
    recommendation: "Use encrypted database connections."
  },
  {
    id: "SOL2361",
    name: "Cypher Insider Pattern ($317K)",
    severity: "high",
    pattern: /team_access|insider(?![\s\S]{0,100}audit_log|monitoring)/i,
    description: "Insider access without audit logging.",
    recommendation: "Log all insider/team actions."
  },
  {
    id: "SOL2362",
    name: "io.net API Key Exposure",
    severity: "critical",
    pattern: /api_key|secret(?![\s\S]{0,50}env|secret_manager)/i,
    description: "API key potentially exposed in code.",
    recommendation: "Use environment variables or secret manager."
  },
  {
    id: "SOL2363",
    name: "Aurory Game Exploit ($830K)",
    severity: "high",
    pattern: /game_item|nft_game(?![\s\S]{0,100}server_validation)/i,
    description: "Game item without server-side validation.",
    recommendation: "Validate all game actions server-side."
  },
  {
    id: "SOL2364",
    name: "SVT Token Unclaimed Vuln ($1M)",
    severity: "high",
    pattern: /unclaimed|claim(?![\s\S]{0,100}expiry|deadline)/i,
    description: "Claim mechanism without expiry.",
    recommendation: "Add claim deadlines and expiry."
  },
  {
    id: "SOL2365",
    name: "Saga DAO Insider ($1.5M)",
    severity: "high",
    pattern: /dao_treasury|community_fund(?![\s\S]{0,100}multisig)/i,
    description: "DAO treasury without multisig.",
    recommendation: "Require multisig for DAO treasury."
  },
  {
    id: "SOL2366",
    name: "Solareum Rug Detection",
    severity: "critical",
    pattern: /rugpull|rug(?![\s\S]{0,100}liquidity_lock)/i,
    description: "Potential rugpull pattern detected.",
    recommendation: "Lock liquidity and use trusted deployer."
  },
  {
    id: "SOL2367",
    name: "Parcl CDN Compromise",
    severity: "high",
    pattern: /cdn|frontend(?![\s\S]{0,100}sri|integrity)/i,
    description: "Frontend without subresource integrity.",
    recommendation: "Implement SRI for all external resources."
  },
  {
    id: "SOL2368",
    name: "Web3.js Supply Chain",
    severity: "critical",
    pattern: /web3\.js|@solana\/web3(?![\s\S]{0,100}version_pin)/i,
    description: "Solana web3.js without version pinning.",
    recommendation: "Pin specific web3.js versions."
  },
  {
    id: "SOL2369",
    name: "Tulip Flash Loan Vault ($5.2M)",
    severity: "high",
    pattern: /flash_loan|vault(?![\s\S]{0,100}same_block_check)/i,
    description: "Vault vulnerable to flash loan attacks.",
    recommendation: "Add same-block operation restrictions."
  },
  {
    id: "SOL2370",
    name: "UXD Depeg Risk ($3.9M)",
    severity: "high",
    pattern: /stablecoin|peg(?![\s\S]{0,100}oracle_deviation)/i,
    description: "Stablecoin without depeg detection.",
    recommendation: "Monitor and react to depeg events."
  },
  // Validator & Infrastructure Patterns (SOL2371-SOL2385)
  {
    id: "SOL2371",
    name: "Validator Commission Manipulation",
    severity: "high",
    pattern: /commission|validator_fee(?![\s\S]{0,100}max_cap|limit)/i,
    description: "Validator commission without cap.",
    recommendation: "Enforce maximum commission rates."
  },
  {
    id: "SOL2372",
    name: "Stake Pool Centralization",
    severity: "medium",
    pattern: /stake_pool|delegation(?![\s\S]{0,100}distribution_check)/i,
    description: "Stake pool without distribution requirements.",
    recommendation: "Enforce stake distribution across validators."
  },
  {
    id: "SOL2373",
    name: "Turbine Block Propagation",
    severity: "high",
    pattern: /turbine|shred(?![\s\S]{0,100}validation)/i,
    description: "Turbine shred handling without validation.",
    recommendation: "Validate all turbine shreds."
  },
  {
    id: "SOL2374",
    name: "Durable Nonce Expiry Risk",
    severity: "medium",
    pattern: /durable_nonce|nonce(?![\s\S]{0,100}advance_check)/i,
    description: "Durable nonce without advance verification.",
    recommendation: "Check nonce state before use."
  },
  {
    id: "SOL2375",
    name: "JIT Cache Corruption",
    severity: "critical",
    pattern: /jit|cache(?![\s\S]{0,100}integrity_check)/i,
    description: "JIT compilation without integrity verification.",
    recommendation: "Verify JIT cache integrity."
  },
  {
    id: "SOL2376",
    name: "ELF Address Alignment",
    severity: "high",
    pattern: /elf|bpf_loader(?![\s\S]{0,100}alignment)/i,
    description: "ELF loading without address alignment check.",
    recommendation: "Verify proper ELF address alignment."
  },
  {
    id: "SOL2377",
    name: "Compute Unit Exhaustion",
    severity: "high",
    pattern: /compute_units|cu(?![\s\S]{0,100}budget_check)/i,
    description: "Operation without compute budget check.",
    recommendation: "Verify compute budget before expensive ops."
  },
  {
    id: "SOL2378",
    name: "Account Heap Overflow",
    severity: "critical",
    pattern: /heap|allocate(?![\s\S]{0,100}size_check)/i,
    description: "Heap allocation without size check.",
    recommendation: "Validate allocation sizes."
  },
  {
    id: "SOL2379",
    name: "Stack Frame Limit",
    severity: "high",
    pattern: /stack|recursion(?![\s\S]{0,100}depth_limit)/i,
    description: "Recursion without stack depth limit.",
    recommendation: "Limit recursive call depth."
  },
  {
    id: "SOL2380",
    name: "CPI Depth Exhaustion",
    severity: "high",
    pattern: /cpi|invoke(?![\s\S]{0,100}depth_check)/i,
    description: "CPI without depth tracking.",
    recommendation: "Track and limit CPI depth (max 4)."
  },
  {
    id: "SOL2381",
    name: "Account Reallocation DOS",
    severity: "high",
    pattern: /realloc|resize(?![\s\S]{0,100}max_size)/i,
    description: "Account reallocation without size limit.",
    recommendation: "Limit account reallocation size."
  },
  {
    id: "SOL2382",
    name: "Rent Epoch Skip",
    severity: "medium",
    pattern: /rent_epoch|epoch(?![\s\S]{0,100}validation)/i,
    description: "Rent epoch not validated.",
    recommendation: "Validate rent epoch for accounts."
  },
  {
    id: "SOL2383",
    name: "Slot Hash Manipulation",
    severity: "high",
    pattern: /slot_hashes|recent_blockhash(?![\s\S]{0,100}verify)/i,
    description: "Slot hash used without verification.",
    recommendation: "Verify slot hash freshness."
  },
  {
    id: "SOL2384",
    name: "Clock Sysvar Drift",
    severity: "medium",
    pattern: /sysvar::clock|Clock(?![\s\S]{0,100}drift_check)/i,
    description: "Clock sysvar without drift consideration.",
    recommendation: "Account for clock drift in time-based ops."
  },
  {
    id: "SOL2385",
    name: "Instructions Sysvar Abuse",
    severity: "high",
    pattern: /sysvar::instructions|Instructions(?![\s\S]{0,100}verify)/i,
    description: "Instructions sysvar without verification.",
    recommendation: "Verify instruction sysvar contents."
  },
  // MEV & Jito Patterns (SOL2386-SOL2395)
  {
    id: "SOL2386",
    name: "Jito Bundle Sandwich",
    severity: "high",
    pattern: /bundle|jito(?![\s\S]{0,100}sandwich_protection)/i,
    description: "Transaction vulnerable to Jito sandwich attacks.",
    recommendation: "Implement private transaction submission."
  },
  {
    id: "SOL2387",
    name: "Priority Fee Manipulation",
    severity: "medium",
    pattern: /priority_fee|tip(?![\s\S]{0,100}max_cap)/i,
    description: "Priority fee without maximum cap.",
    recommendation: "Cap priority fees to prevent manipulation."
  },
  {
    id: "SOL2388",
    name: "MEV Frontrunning",
    severity: "high",
    pattern: /swap|trade(?![\s\S]{0,100}commit_reveal|private)/i,
    description: "Trade vulnerable to frontrunning.",
    recommendation: "Use commit-reveal or private mempools."
  },
  {
    id: "SOL2389",
    name: "Searcher Collusion",
    severity: "high",
    pattern: /searcher|mev(?![\s\S]{0,100}fair_ordering)/i,
    description: "MEV extraction without fair ordering.",
    recommendation: "Use fair ordering mechanisms."
  },
  {
    id: "SOL2390",
    name: "Backrunning Vulnerability",
    severity: "medium",
    pattern: /oracle_update|price_update(?![\s\S]{0,100}delay)/i,
    description: "Oracle update vulnerable to backrunning.",
    recommendation: "Add delay to oracle updates."
  },
  {
    id: "SOL2391",
    name: "Bundle Reversion Attack",
    severity: "high",
    pattern: /bundle|atomic(?![\s\S]{0,100}revert_check)/i,
    description: "Bundle without reversion handling.",
    recommendation: "Handle partial bundle execution."
  },
  {
    id: "SOL2392",
    name: "Jito DDoS Pattern",
    severity: "high",
    pattern: /spam|flood(?![\s\S]{0,100}rate_limit)/i,
    description: "Spam vulnerability without rate limiting.",
    recommendation: "Implement rate limiting."
  },
  {
    id: "SOL2393",
    name: "Block Builder Manipulation",
    severity: "high",
    pattern: /block_builder|validator(?![\s\S]{0,100}randomization)/i,
    description: "Block building without randomization.",
    recommendation: "Use randomized leader selection."
  },
  {
    id: "SOL2394",
    name: "Liquidation MEV",
    severity: "high",
    pattern: /liquidation|liquidate(?![\s\S]{0,100}dutch_auction)/i,
    description: "Liquidation vulnerable to MEV extraction.",
    recommendation: "Use Dutch auction for liquidations."
  },
  {
    id: "SOL2395",
    name: "Just-In-Time Liquidity",
    severity: "medium",
    pattern: /jit_liquidity|just_in_time(?![\s\S]{0,100}lockup)/i,
    description: "JIT liquidity provision risk.",
    recommendation: "Require minimum liquidity lockup."
  },
  // Token-2022 Advanced Patterns (SOL2396-SOL2408)
  {
    id: "SOL2396",
    name: "Token-2022 Transfer Hook Reentry",
    severity: "critical",
    pattern: /transfer_hook|TransferHook(?![\s\S]{0,100}reentrancy_guard)/i,
    description: "Transfer hook without reentrancy protection.",
    recommendation: "Add reentrancy guard to transfer hooks."
  },
  {
    id: "SOL2397",
    name: "Token-2022 Confidential Amount",
    severity: "high",
    pattern: /confidential_transfer|encrypted(?![\s\S]{0,100}zk_verify)/i,
    description: "Confidential transfer without ZK verification.",
    recommendation: "Verify ZK proofs for confidential transfers."
  },
  {
    id: "SOL2398",
    name: "Token-2022 Interest Bearing Exploit",
    severity: "high",
    pattern: /interest_bearing|interest_rate(?![\s\S]{0,100}compound_check)/i,
    description: "Interest bearing token without compound check.",
    recommendation: "Properly calculate compounding interest."
  },
  {
    id: "SOL2399",
    name: "Token-2022 Permanent Delegate Abuse",
    severity: "critical",
    pattern: /permanent_delegate|PermanentDelegate(?![\s\S]{0,100}guardian)/i,
    description: "Permanent delegate without guardian oversight.",
    recommendation: "Require guardian for permanent delegation."
  },
  {
    id: "SOL2400",
    name: "Token-2022 Memo Required Bypass",
    severity: "medium",
    pattern: /memo_required|MemoTransfer(?![\s\S]{0,100}enforce)/i,
    description: "Memo requirement can be bypassed.",
    recommendation: "Enforce memo at program level."
  },
  {
    id: "SOL2401",
    name: "Token-2022 Non-Transferable Override",
    severity: "high",
    pattern: /non_transferable|soul_bound(?![\s\S]{0,100}immutable)/i,
    description: "Non-transferable token can be overridden.",
    recommendation: "Make non-transferable truly immutable."
  },
  {
    id: "SOL2402",
    name: "Token-2022 Default State Abuse",
    severity: "medium",
    pattern: /default_account_state|DefaultAccountState(?![\s\S]{0,100}verify)/i,
    description: "Default account state not verified.",
    recommendation: "Verify account state on operations."
  },
  {
    id: "SOL2403",
    name: "Token-2022 Group Member Attack",
    severity: "high",
    pattern: /token_group|GroupMember(?![\s\S]{0,100}authority_check)/i,
    description: "Token group without authority verification.",
    recommendation: "Verify group member authority."
  },
  {
    id: "SOL2404",
    name: "Token-2022 Metadata Pointer",
    severity: "medium",
    pattern: /metadata_pointer|MetadataPointer(?![\s\S]{0,100}validate)/i,
    description: "Metadata pointer not validated.",
    recommendation: "Validate metadata pointer targets."
  },
  {
    id: "SOL2405",
    name: "Token-2022 Close Authority Drain",
    severity: "high",
    pattern: /close_authority|CloseAuthority(?![\s\S]{0,100}balance_check)/i,
    description: "Close authority without balance verification.",
    recommendation: "Verify zero balance before close."
  },
  {
    id: "SOL2406",
    name: "Token-2022 Fee Config Abuse",
    severity: "high",
    pattern: /transfer_fee_config|TransferFeeConfig(?![\s\S]{0,100}max_fee)/i,
    description: "Transfer fee without maximum cap.",
    recommendation: "Cap transfer fees at reasonable maximum."
  },
  {
    id: "SOL2407",
    name: "Token-2022 CPI Guard State",
    severity: "high",
    pattern: /cpi_guard|CpiGuard(?![\s\S]{0,100}state_check)/i,
    description: "CPI guard state not verified.",
    recommendation: "Check CPI guard before operations."
  },
  {
    id: "SOL2408",
    name: "Token-2022 Immutable Owner Bypass",
    severity: "high",
    pattern: /immutable_owner|ImmutableOwner(?![\s\S]{0,100}verify)/i,
    description: "Immutable owner can be bypassed.",
    recommendation: "Enforce immutable owner check."
  },
  // Compressed NFT Patterns (SOL2409-SOL2420)
  {
    id: "SOL2409",
    name: "cNFT Merkle Proof Spoofing",
    severity: "critical",
    pattern: /merkle_proof|MerkleProof(?![\s\S]{0,100}verify_proof)/i,
    description: "cNFT merkle proof without verification.",
    recommendation: "Verify all merkle proofs."
  },
  {
    id: "SOL2410",
    name: "cNFT Canopy Depth Attack",
    severity: "high",
    pattern: /canopy|tree_depth(?![\s\S]{0,100}depth_check)/i,
    description: "Canopy depth not validated.",
    recommendation: "Validate canopy depth on operations."
  },
  {
    id: "SOL2411",
    name: "cNFT Concurrent Modification",
    severity: "high",
    pattern: /concurrent|atomic_update(?![\s\S]{0,100}seq_check)/i,
    description: "cNFT tree concurrent modification risk.",
    recommendation: "Use sequence numbers for atomicity."
  },
  {
    id: "SOL2412",
    name: "cNFT Leaf Index Overflow",
    severity: "high",
    pattern: /leaf_index|tree_index(?![\s\S]{0,100}bounds_check)/i,
    description: "cNFT leaf index without bounds check.",
    recommendation: "Validate leaf index bounds."
  },
  {
    id: "SOL2413",
    name: "cNFT Creator Verification",
    severity: "high",
    pattern: /creator_hash|creator_verification(?![\s\S]{0,100}verify)/i,
    description: "cNFT creator hash not verified.",
    recommendation: "Verify creator hash on operations."
  },
  {
    id: "SOL2414",
    name: "cNFT Data Hash Collision",
    severity: "high",
    pattern: /data_hash|asset_hash(?![\s\S]{0,100}unique)/i,
    description: "cNFT data hash may collide.",
    recommendation: "Ensure data hash uniqueness."
  },
  {
    id: "SOL2415",
    name: "cNFT Tree Authority Transfer",
    severity: "critical",
    pattern: /tree_authority|tree_delegate(?![\s\S]{0,100}two_step)/i,
    description: "Tree authority transfer without two-step.",
    recommendation: "Use two-step authority transfer."
  },
  {
    id: "SOL2416",
    name: "cNFT Decompress Attack",
    severity: "high",
    pattern: /decompress|unpack(?![\s\S]{0,100}verify_ownership)/i,
    description: "cNFT decompression without ownership verify.",
    recommendation: "Verify ownership before decompression."
  },
  {
    id: "SOL2417",
    name: "cNFT Collection Verification",
    severity: "high",
    pattern: /collection_verified|collection_hash(?![\s\S]{0,100}check)/i,
    description: "cNFT collection not verified.",
    recommendation: "Verify collection membership."
  },
  {
    id: "SOL2418",
    name: "Bubblegum Creator Share",
    severity: "medium",
    pattern: /creator_share|royalty(?![\s\S]{0,100}total_100)/i,
    description: "Creator shares may not sum to 100.",
    recommendation: "Verify creator shares sum to 100%."
  },
  {
    id: "SOL2419",
    name: "Bubblegum Delegate Scope",
    severity: "high",
    pattern: /delegate|burn_delegate(?![\s\S]{0,100}scope_check)/i,
    description: "cNFT delegate scope not limited.",
    recommendation: "Limit delegate permissions scope."
  },
  {
    id: "SOL2420",
    name: "Bubblegum Metadata Update",
    severity: "medium",
    pattern: /metadata_update|update_metadata(?![\s\S]{0,100}authority)/i,
    description: "Metadata update without authority check.",
    recommendation: "Verify update authority."
  }
];
function checkBatch58Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_58_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_58_COUNT = BATCH_58_PATTERNS.length;

// src/patterns/solana-batched-patterns-59.ts
var BATCH_59_PATTERNS = [
  // Loopscale $5.8M Exploit (April 2025)
  {
    id: "SOL2421",
    name: "Loopscale Collateral Under-Collateralization",
    severity: "critical",
    pattern: /collateral_ratio|health_factor(?![\s\S]{0,100}minimum_ratio|[\s\S]{0,100}>=\s*\d)/i,
    description: "Lending protocol without minimum collateral ratio enforcement (Loopscale $5.8M).",
    recommendation: "Enforce minimum collateral ratios with constant checks.",
    exploit: "Loopscale April 2025 - $5.8M"
  },
  {
    id: "SOL2422",
    name: "Loopscale Flashloan Arbitrage",
    severity: "critical",
    pattern: /borrow[\s\S]{0,100}repay[\s\S]{0,100}(?!same_transaction|atomic)/i,
    description: "Flash loan without same-transaction repayment verification.",
    recommendation: "Verify flash loans repaid in same transaction.",
    exploit: "Loopscale April 2025 - $5.8M"
  },
  {
    id: "SOL2423",
    name: "Loopscale Oracle Frontrunning",
    severity: "high",
    pattern: /oracle[\s\S]{0,50}update(?![\s\S]{0,50}delay|[\s\S]{0,50}commitment)/i,
    description: "Oracle updates without frontrunning protection.",
    recommendation: "Add delay or use commit-reveal for oracle updates.",
    exploit: "Loopscale April 2025 - $5.8M"
  },
  // Thunder Terminal - MongoDB Injection
  {
    id: "SOL2424",
    name: "Thunder Terminal External DB Query",
    severity: "critical",
    pattern: /database|mongodb|query[\s\S]{0,50}user_input(?![\s\S]{0,50}sanitize|[\s\S]{0,50}escape)/i,
    description: "External database queries with unsanitized input (Thunder Terminal pattern).",
    recommendation: "Sanitize all external inputs before database queries.",
    exploit: "Thunder Terminal 2024"
  },
  {
    id: "SOL2425",
    name: "Thunder Terminal Session Management",
    severity: "high",
    pattern: /session|jwt[\s\S]{0,50}(?![\s\S]{0,50}expire|[\s\S]{0,50}rotate)/i,
    description: "Session tokens without expiration or rotation.",
    recommendation: "Implement session expiration and token rotation.",
    exploit: "Thunder Terminal 2024"
  },
  // Banana Gun MEV Bot Compromise
  {
    id: "SOL2426",
    name: "Banana Gun MEV Bot Private Key Storage",
    severity: "critical",
    pattern: /private_key|secret_key[\s\S]{0,50}(store|save|persist)(?![\s\S]{0,50}encrypt|[\s\S]{0,50}vault)/i,
    description: "Private keys stored without encryption (Banana Gun pattern).",
    recommendation: "Use hardware security modules or encrypted vaults.",
    exploit: "Banana Gun 2024 - $1.4M"
  },
  {
    id: "SOL2427",
    name: "Banana Gun MEV Oracle Dependency",
    severity: "high",
    pattern: /mev|sandwich[\s\S]{0,50}oracle(?![\s\S]{0,50}multi_source)/i,
    description: "MEV bot relying on single oracle source.",
    recommendation: "Use multiple oracle sources for MEV operations.",
    exploit: "Banana Gun 2024 - $1.4M"
  },
  // NoOnes Platform - API Key Exposure
  {
    id: "SOL2428",
    name: "NoOnes API Key in Client",
    severity: "critical",
    pattern: /api_key|apikey[\s\S]{0,30}(client|frontend|browser)(?![\s\S]{0,50}proxy)/i,
    description: "API keys exposed to client-side code (NoOnes pattern).",
    recommendation: "Use backend proxy for API key authenticated requests.",
    exploit: "NoOnes Platform 2024"
  },
  {
    id: "SOL2429",
    name: "NoOnes Platform Withdrawal Rate Limit",
    severity: "high",
    pattern: /withdraw[\s\S]{0,50}(?![\s\S]{0,50}rate_limit|[\s\S]{0,50}cooldown|[\s\S]{0,50}daily_limit)/i,
    description: "Withdrawal operations without rate limiting.",
    recommendation: "Implement withdrawal rate limits and daily caps.",
    exploit: "NoOnes Platform 2024"
  },
  // Aurory NFT Gaming Exploit
  {
    id: "SOL2430",
    name: "Aurory NFT Attribute Manipulation",
    severity: "high",
    pattern: /nft[\s\S]{0,50}attribute|metadata[\s\S]{0,50}(?![\s\S]{0,50}immutable|[\s\S]{0,50}freeze)/i,
    description: "NFT attributes mutable after mint (Aurory pattern).",
    recommendation: "Freeze NFT attributes after initial mint.",
    exploit: "Aurory NFT Gaming 2024"
  },
  {
    id: "SOL2431",
    name: "Aurory Game Economy Inflation",
    severity: "high",
    pattern: /reward|mint[\s\S]{0,50}game(?![\s\S]{0,50}cap|[\s\S]{0,50}max_supply)/i,
    description: "Game reward minting without supply caps.",
    recommendation: "Implement hard caps on game economy token supply.",
    exploit: "Aurory NFT Gaming 2024"
  },
  // Saga DAO Governance Attack
  {
    id: "SOL2432",
    name: "Saga DAO Proposal Timing Attack",
    severity: "critical",
    pattern: /proposal[\s\S]{0,50}vote(?![\s\S]{0,50}delay|[\s\S]{0,50}lock_period)/i,
    description: "DAO proposals without voting delay (Saga DAO pattern).",
    recommendation: "Implement mandatory voting delay after proposal creation.",
    exploit: "Saga DAO 2024"
  },
  {
    id: "SOL2433",
    name: "Saga DAO Flash Governance",
    severity: "critical",
    pattern: /governance[\s\S]{0,50}token[\s\S]{0,50}(?![\s\S]{0,50}snapshot|[\s\S]{0,50}lock)/i,
    description: "Governance tokens without snapshot or lock requirement.",
    recommendation: "Require token lock or snapshot for voting power.",
    exploit: "Saga DAO 2024"
  },
  // Solareum LP Drain
  {
    id: "SOL2434",
    name: "Solareum LP Token Validation",
    severity: "critical",
    pattern: /lp_token|liquidity[\s\S]{0,50}(?![\s\S]{0,50}verify_pool|[\s\S]{0,50}owner_check)/i,
    description: "LP token operations without pool verification (Solareum pattern).",
    recommendation: "Verify LP token belongs to expected pool.",
    exploit: "Solareum 2024"
  },
  {
    id: "SOL2435",
    name: "Solareum Admin Backdoor",
    severity: "critical",
    pattern: /admin[\s\S]{0,30}(emergency|bypass)(?![\s\S]{0,50}multisig|[\s\S]{0,50}timelock)/i,
    description: "Admin emergency functions without multisig.",
    recommendation: "Require multisig and timelock for emergency functions.",
    exploit: "Solareum 2024"
  },
  // Parcl Front-End Supply Chain
  {
    id: "SOL2436",
    name: "Parcl Frontend CDN Integrity",
    severity: "high",
    pattern: /cdn|external[\s\S]{0,50}script(?![\s\S]{0,50}integrity|[\s\S]{0,50}sri)/i,
    description: "External scripts without SRI integrity check (Parcl pattern).",
    recommendation: "Add Subresource Integrity (SRI) to external scripts.",
    exploit: "Parcl Front-End 2024"
  },
  {
    id: "SOL2437",
    name: "Parcl DNS Hijack Risk",
    severity: "high",
    pattern: /domain|dns(?![\s\S]{0,50}dnssec|[\s\S]{0,50}certificate_pin)/i,
    description: "Frontend DNS without DNSSEC or certificate pinning.",
    recommendation: "Enable DNSSEC and certificate pinning.",
    exploit: "Parcl Front-End 2024"
  },
  // Web3.js NPM Package Compromise
  {
    id: "SOL2438",
    name: "Web3.js Dependency Verification",
    severity: "critical",
    pattern: /@solana\/web3\.js(?![\s\S]{0,30}\d+\.\d+\.\d+)/i,
    description: "Solana web3.js without pinned version (supply chain risk).",
    recommendation: "Pin @solana/web3.js to verified version.",
    exploit: "Web3.js NPM Compromise 2024"
  },
  {
    id: "SOL2439",
    name: "Web3.js Signing Interception",
    severity: "critical",
    pattern: /signTransaction|signAllTransactions(?![\s\S]{0,50}verify_origin)/i,
    description: "Transaction signing without origin verification.",
    recommendation: "Verify signing requests come from trusted origin.",
    exploit: "Web3.js NPM Compromise 2024"
  },
  // Synthetify DAO Attack
  {
    id: "SOL2440",
    name: "Synthetify DAO Unnoticed Proposal",
    severity: "high",
    pattern: /proposal[\s\S]{0,50}(?![\s\S]{0,50}notify|[\s\S]{0,50}alert|[\s\S]{0,50}announce)/i,
    description: "DAO proposals without mandatory notification (Synthetify pattern).",
    recommendation: "Require mandatory notification for new proposals.",
    exploit: "Synthetify DAO $230K"
  },
  // Sec3 2025 Business Logic Patterns
  {
    id: "SOL2441",
    name: "Sec3 State Machine Violation",
    severity: "high",
    pattern: /state[\s\S]{0,30}=[\s\S]{0,30}(?![\s\S]{0,50}valid_transition|[\s\S]{0,50}require_state)/i,
    description: "State transitions without validity check (Sec3 2025: 38.5% of vulns).",
    recommendation: "Validate all state transitions against allowed paths."
  },
  {
    id: "SOL2442",
    name: "Sec3 Invariant Check Missing",
    severity: "high",
    pattern: /total|balance[\s\S]{0,30}(add|sub)(?![\s\S]{0,50}assert_invariant)/i,
    description: "State changes without invariant preservation check.",
    recommendation: "Assert invariants after all state-changing operations."
  },
  {
    id: "SOL2443",
    name: "Sec3 Order-Dependent Logic",
    severity: "medium",
    pattern: /instruction[\s\S]{0,30}(first|before|after)(?![\s\S]{0,50}enforce_order)/i,
    description: "Business logic dependent on instruction ordering.",
    recommendation: "Use explicit ordering constraints or sequence numbers."
  },
  // Sec3 2025 Input Validation (25%)
  {
    id: "SOL2444",
    name: "Sec3 Input Range Validation",
    severity: "high",
    pattern: /amount|quantity[\s\S]{0,20}:[\s\S]{0,10}u64(?![\s\S]{0,50}require!.*[<>])/i,
    description: "Numeric inputs without range validation (Sec3 2025: 25% of vulns).",
    recommendation: "Validate input ranges: min, max, non-zero checks."
  },
  {
    id: "SOL2445",
    name: "Sec3 String Input Sanitization",
    severity: "medium",
    pattern: /String[\s\S]{0,30}(?![\s\S]{0,50}len\(\)|[\s\S]{0,50}max_len|[\s\S]{0,50}sanitize)/i,
    description: "String inputs without length or content validation.",
    recommendation: "Validate string length and sanitize special characters."
  },
  {
    id: "SOL2446",
    name: "Sec3 Account Data Bounds",
    severity: "high",
    pattern: /data\[[\s\S]{0,20}\](?![\s\S]{0,30}\.get\(|[\s\S]{0,30}checked)/i,
    description: "Direct array index access without bounds checking.",
    recommendation: "Use .get() or bounds-checked access methods."
  },
  // Sec3 2025 Access Control (19%)
  {
    id: "SOL2447",
    name: "Sec3 Role-Based Access Missing",
    severity: "critical",
    pattern: /admin|owner[\s\S]{0,30}(?![\s\S]{0,50}has_role|[\s\S]{0,50}require_role)/i,
    description: "Privileged operations without RBAC (Sec3 2025: 19% of vulns).",
    recommendation: "Implement role-based access control for all admin functions."
  },
  {
    id: "SOL2448",
    name: "Sec3 Privilege Escalation Path",
    severity: "critical",
    pattern: /set_authority|transfer_authority(?![\s\S]{0,50}require_current_authority)/i,
    description: "Authority transfer without current authority verification.",
    recommendation: "Require current authority signature for transfers."
  },
  {
    id: "SOL2449",
    name: "Sec3 Capability Leak",
    severity: "high",
    pattern: /signer[\s\S]{0,30}seeds(?![\s\S]{0,50}verify_capability)/i,
    description: "PDA signer seeds exposed without capability verification.",
    recommendation: "Verify caller has capability before exposing signer seeds."
  },
  // Sec3 2025 Data Integrity (8.9%)
  {
    id: "SOL2450",
    name: "Sec3 Cross-Reference Integrity",
    severity: "high",
    pattern: /reference|pointer[\s\S]{0,30}(?![\s\S]{0,50}verify_exists|[\s\S]{0,50}constraint)/i,
    description: "Cross-references without existence verification.",
    recommendation: "Verify referenced accounts exist and are valid."
  },
  {
    id: "SOL2451",
    name: "Sec3 Timestamp Manipulation",
    severity: "medium",
    pattern: /clock[\s\S]{0,30}unix_timestamp(?![\s\S]{0,50}tolerance|[\s\S]{0,50}window)/i,
    description: "Clock timestamp used without manipulation tolerance.",
    recommendation: "Allow timestamp tolerance window for validator variance."
  },
  // Sec3 2025 DoS/Liveness (8.5%)
  {
    id: "SOL2452",
    name: "Sec3 Unbounded Iteration",
    severity: "high",
    pattern: /for[\s\S]{0,20}\.iter\(\)(?![\s\S]{0,30}\.take\(|[\s\S]{0,30}limit)/i,
    description: "Unbounded iteration causing compute exhaustion (Sec3 2025: 8.5%).",
    recommendation: "Limit iterations with .take() or explicit bounds."
  },
  {
    id: "SOL2453",
    name: "Sec3 Account Spam Vulnerability",
    severity: "medium",
    pattern: /create[\s\S]{0,30}account(?![\s\S]{0,50}fee|[\s\S]{0,50}deposit)/i,
    description: "Account creation without spam prevention fee.",
    recommendation: "Require deposit or fee for account creation."
  },
  // Advanced Attack Vectors 2025
  {
    id: "SOL2454",
    name: "JIT Liquidity MEV Attack",
    severity: "high",
    pattern: /liquidity[\s\S]{0,30}add[\s\S]{0,30}(?![\s\S]{0,50}lock_period)/i,
    description: "Liquidity provision vulnerable to JIT liquidity attacks.",
    recommendation: "Add lock period to prevent JIT MEV extraction."
  },
  {
    id: "SOL2455",
    name: "Backrunning Opportunity",
    severity: "medium",
    pattern: /swap[\s\S]{0,30}emit!(?![\s\S]{0,50}private)/i,
    description: "Public swap events enabling backrunning.",
    recommendation: "Consider private mempools or commit-reveal schemes."
  },
  {
    id: "SOL2456",
    name: "Validator Concentration Risk",
    severity: "medium",
    pattern: /validator|leader(?![\s\S]{0,50}rotate|[\s\S]{0,50}distributed)/i,
    description: "Operations dependent on specific validator behavior.",
    recommendation: "Design for validator-independent operation."
  },
  // Cross-Chain Specific (2025 Trends)
  {
    id: "SOL2457",
    name: "Wormhole VAA Replay",
    severity: "critical",
    pattern: /vaa|guardian[\s\S]{0,30}(?![\s\S]{0,50}nonce|[\s\S]{0,50}sequence)/i,
    description: "Cross-chain VAA without replay protection.",
    recommendation: "Track VAA sequence numbers to prevent replay."
  },
  {
    id: "SOL2458",
    name: "Bridge Finality Assumption",
    severity: "high",
    pattern: /bridge[\s\S]{0,30}confirm(?![\s\S]{0,50}finality|[\s\S]{0,50}confirmations)/i,
    description: "Cross-chain bridge without finality verification.",
    recommendation: "Wait for source chain finality before crediting."
  },
  {
    id: "SOL2459",
    name: "Layer 2 Fraud Proof Window",
    severity: "high",
    pattern: /l2|rollup[\s\S]{0,30}(?![\s\S]{0,50}challenge_period)/i,
    description: "L2 integration without fraud proof consideration.",
    recommendation: "Account for challenge period in L2 integrations."
  },
  // Token-2022 Advanced Patterns
  {
    id: "SOL2460",
    name: "Token-2022 Confidential Audit",
    severity: "high",
    pattern: /confidential[\s\S]{0,30}transfer(?![\s\S]{0,50}audit_key)/i,
    description: "Confidential transfers without audit capability.",
    recommendation: "Enable audit keys for compliance requirements."
  },
  {
    id: "SOL2461",
    name: "Token-2022 Transfer Fee Accuracy",
    severity: "medium",
    pattern: /transfer_fee[\s\S]{0,30}basis_points(?![\s\S]{0,50}max_fee)/i,
    description: "Transfer fee without maximum cap.",
    recommendation: "Set max_fee to prevent excessive fee accumulation."
  },
  {
    id: "SOL2462",
    name: "Token-2022 Interest Bearing Calculation",
    severity: "high",
    pattern: /interest[\s\S]{0,30}rate(?![\s\S]{0,50}compound|[\s\S]{0,50}accrue)/i,
    description: "Interest bearing tokens without proper accrual.",
    recommendation: "Use compound interest with regular accrual points."
  },
  // Compressed NFT Security (2025)
  {
    id: "SOL2463",
    name: "cNFT Concurrent Merkle Update",
    severity: "high",
    pattern: /merkle[\s\S]{0,30}update(?![\s\S]{0,50}concurrent|[\s\S]{0,50}canopy)/i,
    description: "Merkle tree updates without concurrency handling.",
    recommendation: "Use concurrent merkle trees with canopy for scale."
  },
  {
    id: "SOL2464",
    name: "cNFT Proof Verification Cost",
    severity: "medium",
    pattern: /verify_proof[\s\S]{0,30}(?![\s\S]{0,50}canopy_depth)/i,
    description: "Merkle proof verification without canopy optimization.",
    recommendation: "Use appropriate canopy depth to reduce proof size."
  },
  // Blink Actions Security (2025)
  {
    id: "SOL2465",
    name: "Blink Action Origin Validation",
    severity: "critical",
    pattern: /action[\s\S]{0,30}url(?![\s\S]{0,50}verify_domain|[\s\S]{0,50}allowlist)/i,
    description: "Blink actions without origin domain validation.",
    recommendation: "Validate action URLs against domain allowlist."
  },
  {
    id: "SOL2466",
    name: "Blink Transaction Preview",
    severity: "high",
    pattern: /blink[\s\S]{0,30}sign(?![\s\S]{0,50}simulate|[\s\S]{0,50}preview)/i,
    description: "Blink transactions signed without simulation preview.",
    recommendation: "Always simulate and preview blink transactions."
  },
  // AI Agent Wallet Security (2025 Emerging)
  {
    id: "SOL2467",
    name: "AI Agent Transaction Limits",
    severity: "critical",
    pattern: /agent[\s\S]{0,30}wallet(?![\s\S]{0,50}limit|[\s\S]{0,50}allowance)/i,
    description: "AI agent wallet without transaction limits.",
    recommendation: "Set per-transaction and daily limits for AI agents."
  },
  {
    id: "SOL2468",
    name: "AI Agent Allowlist Operations",
    severity: "high",
    pattern: /agent[\s\S]{0,30}(invoke|call)(?![\s\S]{0,50}program_allowlist)/i,
    description: "AI agent calling arbitrary programs.",
    recommendation: "Restrict AI agents to allowlisted programs only."
  },
  {
    id: "SOL2469",
    name: "AI Agent Key Rotation",
    severity: "high",
    pattern: /agent[\s\S]{0,30}key(?![\s\S]{0,50}rotate|[\s\S]{0,50}expire)/i,
    description: "AI agent keys without automatic rotation.",
    recommendation: "Implement automatic key rotation for AI agents."
  },
  // Pump.fun Specific Patterns
  {
    id: "SOL2470",
    name: "Pump.fun Bonding Curve Manipulation",
    severity: "critical",
    pattern: /bonding[\s\S]{0,30}curve[\s\S]{0,30}(?![\s\S]{0,50}atomic|[\s\S]{0,50}flash_protection)/i,
    description: "Bonding curve vulnerable to multi-tx manipulation.",
    recommendation: "Make bonding curve updates atomic with flash protection."
  },
  {
    id: "SOL2471",
    name: "Pump.fun Insider Trading Detection",
    severity: "high",
    pattern: /launch[\s\S]{0,30}(?![\s\S]{0,50}fair_launch|[\s\S]{0,50}delay)/i,
    description: "Token launch without fair launch mechanics.",
    recommendation: "Implement fair launch with initial delay."
  },
  // Infrastructure Security (2025 Focus)
  {
    id: "SOL2472",
    name: "RPC Provider Validation",
    severity: "high",
    pattern: /rpc[\s\S]{0,30}(url|endpoint)(?![\s\S]{0,50}verify|[\s\S]{0,50}https)/i,
    description: "RPC endpoints without TLS verification.",
    recommendation: "Use HTTPS and verify RPC provider certificates."
  },
  {
    id: "SOL2473",
    name: "WebSocket Connection Security",
    severity: "medium",
    pattern: /websocket|wss(?![\s\S]{0,50}reconnect|[\s\S]{0,50}heartbeat)/i,
    description: "WebSocket connections without heartbeat monitoring.",
    recommendation: "Implement heartbeat and automatic reconnection."
  },
  // Economic Attack Vectors
  {
    id: "SOL2474",
    name: "First Depositor Share Inflation",
    severity: "critical",
    pattern: /vault[\s\S]{0,30}share(?![\s\S]{0,50}minimum_deposit|[\s\S]{0,50}dead_shares)/i,
    description: "Vault vulnerable to first depositor share inflation.",
    recommendation: "Require minimum deposit or mint dead shares to zero address."
  },
  {
    id: "SOL2475",
    name: "Fee-on-Transfer Token Handling",
    severity: "high",
    pattern: /transfer[\s\S]{0,30}amount(?![\s\S]{0,50}actual_received|[\s\S]{0,50}fee_adjusted)/i,
    description: "Transfer operations not accounting for fee-on-transfer tokens.",
    recommendation: "Check actual received amount, not requested amount."
  },
  {
    id: "SOL2476",
    name: "Rebasing Token Accounting",
    severity: "high",
    pattern: /balance[\s\S]{0,30}stored(?![\s\S]{0,50}shares|[\s\S]{0,50}elastic)/i,
    description: "Rebasing token tracked by absolute balance instead of shares.",
    recommendation: "Use share-based accounting for rebasing tokens."
  },
  // Audit-Derived Patterns (2025)
  {
    id: "SOL2477",
    name: "OtterSec: Anchor Zero-Copy Safety",
    severity: "high",
    pattern: /#\[account\(zero_copy\)\](?![\s\S]{0,100}repr\(C\))/i,
    description: "Zero-copy account without repr(C) (OtterSec finding).",
    recommendation: "Add #[repr(C)] to zero-copy account structs."
  },
  {
    id: "SOL2478",
    name: "Neodyme: Account Discriminator Collision",
    severity: "critical",
    pattern: /discriminator[\s\S]{0,30}=[\s\S]{0,30}\[(?![\s\S]{0,50}unique)/i,
    description: "Manual discriminator may collide with other accounts.",
    recommendation: "Use unique discriminators or Anchor auto-discrimination."
  },
  {
    id: "SOL2479",
    name: "Kudelski: Instruction Introspection",
    severity: "medium",
    pattern: /sysvar::instructions(?![\s\S]{0,50}verify_program)/i,
    description: "Instruction introspection without program verification.",
    recommendation: "Verify instruction program IDs when introspecting."
  },
  {
    id: "SOL2480",
    name: "Halborn: Serum DEX Integration",
    severity: "high",
    pattern: /serum|openbook[\s\S]{0,30}(?![\s\S]{0,50}market_authority)/i,
    description: "DEX integration without market authority validation.",
    recommendation: "Verify market authority for DEX operations."
  },
  // Latest 2025 Exploit Techniques
  {
    id: "SOL2481",
    name: "DEXX Private Key Leak Pattern",
    severity: "critical",
    pattern: /export|dump[\s\S]{0,30}(key|secret)(?![\s\S]{0,50}encrypted)/i,
    description: "Key export without encryption (DEXX $30M pattern).",
    recommendation: "Never export keys unencrypted.",
    exploit: "DEXX 2024 - $30M"
  },
  {
    id: "SOL2482",
    name: "DEXX Custodial Wallet Risk",
    severity: "critical",
    pattern: /custodial|managed[\s\S]{0,30}wallet(?![\s\S]{0,50}insurance|[\s\S]{0,50}audit)/i,
    description: "Custodial wallet without insurance or audit.",
    recommendation: "Require insurance and regular audits for custodial wallets."
  },
  // Resilience Patterns
  {
    id: "SOL2483",
    name: "Circuit Breaker Missing",
    severity: "high",
    pattern: /protocol[\s\S]{0,30}(?![\s\S]{0,50}circuit_breaker|[\s\S]{0,50}pause)/i,
    description: "Protocol without emergency circuit breaker.",
    recommendation: "Implement circuit breaker for emergency pausing."
  },
  {
    id: "SOL2484",
    name: "Graceful Degradation",
    severity: "medium",
    pattern: /oracle[\s\S]{0,30}fail(?![\s\S]{0,50}fallback|[\s\S]{0,50}default)/i,
    description: "No fallback behavior when oracles fail.",
    recommendation: "Implement graceful degradation for oracle failures."
  },
  // Testing & Verification Patterns
  {
    id: "SOL2485",
    name: "Fuzzing Coverage Gap",
    severity: "low",
    pattern: /#\[test\](?![\s\S]{0,200}proptest|[\s\S]{0,200}quickcheck|[\s\S]{0,200}arbitrary)/i,
    description: "Tests without property-based testing or fuzzing.",
    recommendation: "Add property-based tests with proptest or quickcheck."
  },
  {
    id: "SOL2486",
    name: "Invariant Testing Missing",
    severity: "medium",
    pattern: /#\[test\][\s\S]{0,500}(?!invariant|assert_eq![\s\S]{0,30}total)/i,
    description: "Tests without invariant assertions.",
    recommendation: "Add invariant checks to test suite."
  },
  // Documentation Security
  {
    id: "SOL2487",
    name: "Security Contact Missing",
    severity: "info",
    pattern: /README|SECURITY(?![\s\S]{0,500}security@|[\s\S]{0,500}bug.bounty)/i,
    description: "No security contact or bug bounty information.",
    recommendation: "Add SECURITY.md with contact and bounty info."
  },
  // Monitoring & Alerting
  {
    id: "SOL2488",
    name: "Event Logging Insufficient",
    severity: "low",
    pattern: /pub fn (?![\s\S]{0,200}emit!|[\s\S]{0,200}msg!|[\s\S]{0,200}log)/i,
    description: "Public functions without event logging.",
    recommendation: "Emit events for all state-changing operations."
  },
  {
    id: "SOL2489",
    name: "On-Chain Monitoring Hook",
    severity: "info",
    pattern: /critical[\s\S]{0,30}(?![\s\S]{0,50}alert|[\s\S]{0,50}monitor)/i,
    description: "Critical operations without monitoring hooks.",
    recommendation: "Add monitoring hooks for critical operations."
  },
  // Deployment Security
  {
    id: "SOL2490",
    name: "Deployment Script Security",
    severity: "high",
    pattern: /deploy[\s\S]{0,30}(script|sh)(?![\s\S]{0,50}verify|[\s\S]{0,50}check)/i,
    description: "Deployment scripts without verification steps.",
    recommendation: "Add verification and rollback to deployment scripts."
  }
];
function checkBatch59Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_59_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description + (pattern.exploit ? ` [Exploit: ${pattern.exploit}]` : ""),
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_59_COUNT = BATCH_59_PATTERNS.length;

// src/patterns/solana-batched-patterns-60.ts
var BATCH_60_PATTERNS = [
  // Wormhole-Derived Patterns ($326M)
  {
    id: "SOL2491",
    name: "Wormhole: Signature Count Verification",
    severity: "critical",
    pattern: /signatures[\s\S]{0,30}len\(\)(?![\s\S]{0,50}>=\s*quorum)/i,
    description: "Multi-sig signature count without quorum check.",
    recommendation: "Verify signature count meets quorum threshold.",
    category: "Cross-Chain"
  },
  {
    id: "SOL2492",
    name: "Wormhole: Deprecated Verify Function",
    severity: "critical",
    pattern: /verify_signatures[\s\S]{0,30}deprecated(?![\s\S]{0,50}migrate)/i,
    description: "Using deprecated signature verification (Wormhole root cause).",
    recommendation: "Migrate to current verification implementations.",
    category: "Cross-Chain"
  },
  {
    id: "SOL2493",
    name: "Wormhole: Guardian Set Update",
    severity: "high",
    pattern: /guardian_set[\s\S]{0,30}update(?![\s\S]{0,50}old_set_expiry)/i,
    description: "Guardian set update without old set expiry.",
    recommendation: "Implement guardian set expiry period.",
    category: "Cross-Chain"
  },
  // Mango Markets Patterns ($116M)
  {
    id: "SOL2494",
    name: "Mango: Perp Market Manipulation",
    severity: "critical",
    pattern: /perp[\s\S]{0,30}price(?![\s\S]{0,50}impact_limit|[\s\S]{0,50}circuit_breaker)/i,
    description: "Perpetual market without price impact limits.",
    recommendation: "Implement price impact limits and circuit breakers.",
    category: "DeFi"
  },
  {
    id: "SOL2495",
    name: "Mango: Self-Reference Oracle",
    severity: "critical",
    pattern: /oracle[\s\S]{0,30}(internal|self)(?![\s\S]{0,50}external_validation)/i,
    description: "Protocol using self-referencing oracle (Mango root cause).",
    recommendation: "Use external oracles with multiple sources.",
    category: "Oracle"
  },
  {
    id: "SOL2496",
    name: "Mango: Collateral Concentration",
    severity: "high",
    pattern: /collateral[\s\S]{0,30}(?![\s\S]{0,50}diversification|[\s\S]{0,50}limit_per_asset)/i,
    description: "No limits on collateral concentration per asset.",
    recommendation: "Implement per-asset collateral limits.",
    category: "DeFi"
  },
  // Cashio Patterns ($52M)
  {
    id: "SOL2497",
    name: "Cashio: Collateral Chain Validation",
    severity: "critical",
    pattern: /collateral[\s\S]{0,30}chain(?![\s\S]{0,50}validate_each|[\s\S]{0,50}root_of_trust)/i,
    description: "Collateral chain without root-of-trust validation.",
    recommendation: "Validate entire collateral chain to root of trust.",
    category: "DeFi"
  },
  {
    id: "SOL2498",
    name: "Cashio: LP Token Verification",
    severity: "critical",
    pattern: /lp_token[\s\S]{0,30}mint(?![\s\S]{0,50}verify_pool_mint|[\s\S]{0,50}whitelist)/i,
    description: "LP token mint not verified against whitelist.",
    recommendation: "Whitelist valid LP token mints.",
    category: "DeFi"
  },
  {
    id: "SOL2499",
    name: "Cashio: Nested Account Trust",
    severity: "high",
    pattern: /account[\s\S]{0,30}nested(?![\s\S]{0,50}verify_each_level)/i,
    description: "Nested account structure without level-by-level verification.",
    recommendation: "Verify each level of nested account structures.",
    category: "Account"
  },
  // Crema Finance Patterns ($8.8M)
  {
    id: "SOL2500",
    name: "Crema: CLMM Tick Account Spoofing",
    severity: "critical",
    pattern: /tick[\s\S]{0,30}account(?![\s\S]{0,50}owner_check|[\s\S]{0,50}pda_verify)/i,
    description: "Tick account without ownership verification (Crema root cause).",
    recommendation: "Verify tick account ownership via PDA.",
    category: "AMM"
  },
  {
    id: "SOL2501",
    name: "Crema: Fee Claim Validation",
    severity: "high",
    pattern: /fee[\s\S]{0,30}claim(?![\s\S]{0,50}position_owner|[\s\S]{0,50}verify_accrued)/i,
    description: "Fee claiming without position ownership check.",
    recommendation: "Verify position ownership before fee claims.",
    category: "AMM"
  },
  {
    id: "SOL2502",
    name: "Crema: Flash Loan Fee Manipulation",
    severity: "critical",
    pattern: /flash[\s\S]{0,30}fee[\s\S]{0,30}(?![\s\S]{0,50}before_state|[\s\S]{0,50}snapshot)/i,
    description: "Flash loan fees calculated without pre-state snapshot.",
    recommendation: "Snapshot state before flash loan for fee calculation.",
    category: "DeFi"
  },
  // Slope Wallet Patterns ($8M)
  {
    id: "SOL2503",
    name: "Slope: Seed Phrase Transmission",
    severity: "critical",
    pattern: /seed|mnemonic[\s\S]{0,30}(send|transmit|log)(?![\s\S]{0,50}never)/i,
    description: "Seed phrase potentially transmitted externally.",
    recommendation: "Never transmit seed phrases - keep client-side only.",
    category: "Wallet"
  },
  {
    id: "SOL2504",
    name: "Slope: Analytics Key Exposure",
    severity: "critical",
    pattern: /analytics|telemetry[\s\S]{0,30}(key|secret)(?![\s\S]{0,50}exclude_sensitive)/i,
    description: "Analytics potentially capturing sensitive data.",
    recommendation: "Explicitly exclude sensitive data from analytics.",
    category: "Wallet"
  },
  // Nirvana Finance Patterns ($3.5M)
  {
    id: "SOL2505",
    name: "Nirvana: Bonding Curve Flash Loan",
    severity: "critical",
    pattern: /bonding[\s\S]{0,30}(?![\s\S]{0,50}block_flash|[\s\S]{0,50}same_block_check)/i,
    description: "Bonding curve without flash loan protection.",
    recommendation: "Block same-block bonding curve operations.",
    category: "DeFi"
  },
  {
    id: "SOL2506",
    name: "Nirvana: Algorithmic Peg Attack",
    severity: "high",
    pattern: /peg[\s\S]{0,30}algorithm(?![\s\S]{0,50}dampening|[\s\S]{0,50}rate_limit)/i,
    description: "Algorithmic peg without manipulation dampening.",
    recommendation: "Add dampening factors to peg mechanisms.",
    category: "DeFi"
  },
  // Raydium Patterns ($4.4M)
  {
    id: "SOL2507",
    name: "Raydium: Pool Authority Leak",
    severity: "critical",
    pattern: /pool[\s\S]{0,30}authority[\s\S]{0,30}(key|secret)(?![\s\S]{0,50}never_expose)/i,
    description: "Pool authority key potentially exposed.",
    recommendation: "Pool authority keys must never be exposed.",
    category: "AMM"
  },
  {
    id: "SOL2508",
    name: "Raydium: Admin Key Storage",
    severity: "critical",
    pattern: /admin[\s\S]{0,30}key[\s\S]{0,30}(store|save)(?![\s\S]{0,50}hardware_wallet|[\s\S]{0,50}hsm)/i,
    description: "Admin keys not stored in hardware security.",
    recommendation: "Store admin keys in HSM or hardware wallet.",
    category: "Admin"
  },
  // Pump.fun Patterns ($1.9M)
  {
    id: "SOL2509",
    name: "Pump.fun: Employee Access Control",
    severity: "critical",
    pattern: /employee|internal[\s\S]{0,30}access(?![\s\S]{0,50}audit_log|[\s\S]{0,50}segregation)/i,
    description: "Internal access without audit logging (Pump.fun insider threat).",
    recommendation: "Log all internal access and implement segregation.",
    category: "Admin"
  },
  {
    id: "SOL2510",
    name: "Pump.fun: Privileged Transaction Monitor",
    severity: "high",
    pattern: /privileged[\s\S]{0,30}(?![\s\S]{0,50}alert|[\s\S]{0,50}monitor)/i,
    description: "Privileged operations without real-time monitoring.",
    recommendation: "Monitor and alert on all privileged operations.",
    category: "Admin"
  },
  // OptiFi Patterns (Accidental lockup)
  {
    id: "SOL2511",
    name: "OptiFi: Shutdown Sequence",
    severity: "critical",
    pattern: /shutdown|close[\s\S]{0,30}(?![\s\S]{0,50}withdraw_first|[\s\S]{0,50}safety_check)/i,
    description: "Program closure without forced withdrawal (OptiFi root cause).",
    recommendation: "Require all funds withdrawn before program closure.",
    category: "Admin"
  },
  {
    id: "SOL2512",
    name: "OptiFi: Irreversible Action Guard",
    severity: "high",
    pattern: /irreversible[\s\S]{0,30}(?![\s\S]{0,50}confirmation|[\s\S]{0,50}delay)/i,
    description: "Irreversible actions without confirmation delay.",
    recommendation: "Add confirmation delay for irreversible operations.",
    category: "Admin"
  },
  // UXD Protocol Patterns
  {
    id: "SOL2513",
    name: "UXD: Delta-Neutral Hedge",
    severity: "high",
    pattern: /hedge[\s\S]{0,30}delta(?![\s\S]{0,50}rebalance_threshold)/i,
    description: "Delta-neutral position without rebalance thresholds.",
    recommendation: "Set automated rebalance thresholds for hedges.",
    category: "DeFi"
  },
  {
    id: "SOL2514",
    name: "UXD: Insurance Fund Depletion",
    severity: "high",
    pattern: /insurance[\s\S]{0,30}fund(?![\s\S]{0,50}minimum_reserve)/i,
    description: "Insurance fund without minimum reserve requirement.",
    recommendation: "Maintain minimum insurance fund reserve.",
    category: "DeFi"
  },
  // Cypher Protocol Patterns ($1M+)
  {
    id: "SOL2515",
    name: "Cypher: Post-Exploit Recovery",
    severity: "high",
    pattern: /recover|restore[\s\S]{0,30}(?![\s\S]{0,50}escrow|[\s\S]{0,50}secure_custody)/i,
    description: "Recovery without secure custody (Cypher second theft).",
    recommendation: "Use escrow/multi-sig for recovery operations.",
    category: "Recovery"
  },
  {
    id: "SOL2516",
    name: "Cypher: White-Hat Coordination",
    severity: "medium",
    pattern: /white[\s\S]{0,5}hat[\s\S]{0,30}(?![\s\S]{0,50}verified|[\s\S]{0,50}known)/i,
    description: "White-hat interaction without verification.",
    recommendation: "Verify white-hat identity through known channels.",
    category: "Recovery"
  },
  // Audius Patterns
  {
    id: "SOL2517",
    name: "Audius: Initialization Guard",
    severity: "critical",
    pattern: /initialize[\s\S]{0,30}(?![\s\S]{0,50}once|[\s\S]{0,50}initialized_check)/i,
    description: "Initialization function callable multiple times.",
    recommendation: "Add one-time initialization guard.",
    category: "Initialization"
  },
  {
    id: "SOL2518",
    name: "Audius: Governance Proxy",
    severity: "high",
    pattern: /governance[\s\S]{0,30}proxy(?![\s\S]{0,50}verify_impl)/i,
    description: "Governance proxy without implementation verification.",
    recommendation: "Verify proxy implementation before calls.",
    category: "Governance"
  },
  // Tulip Protocol Patterns
  {
    id: "SOL2519",
    name: "Tulip: Vault Strategy Risk",
    severity: "high",
    pattern: /vault[\s\S]{0,30}strategy(?![\s\S]{0,50}risk_score|[\s\S]{0,50}audit)/i,
    description: "Vault strategy without risk assessment.",
    recommendation: "Audit and score vault strategy risks.",
    category: "DeFi"
  },
  {
    id: "SOL2520",
    name: "Tulip: Yield Aggregation Risk",
    severity: "medium",
    pattern: /yield[\s\S]{0,30}aggregate(?![\s\S]{0,50}diversif|[\s\S]{0,50}limit)/i,
    description: "Yield aggregation without diversification limits.",
    recommendation: "Diversify yield sources and set limits.",
    category: "DeFi"
  },
  // Solend Advanced Patterns
  {
    id: "SOL2521",
    name: "Solend: Reserve Config Auth",
    severity: "critical",
    pattern: /reserve[\s\S]{0,30}config[\s\S]{0,30}update(?![\s\S]{0,50}admin_check)/i,
    description: "Reserve config update without admin verification.",
    recommendation: "Verify admin authority for reserve config updates.",
    category: "Lending"
  },
  {
    id: "SOL2522",
    name: "Solend: Liquidation Threshold Guard",
    severity: "high",
    pattern: /liquidation[\s\S]{0,30}threshold[\s\S]{0,30}(?![\s\S]{0,50}bounds_check)/i,
    description: "Liquidation threshold modifiable without bounds.",
    recommendation: "Set immutable bounds on liquidation thresholds.",
    category: "Lending"
  },
  {
    id: "SOL2523",
    name: "Solend: Borrow Rate Spike",
    severity: "medium",
    pattern: /borrow[\s\S]{0,30}rate(?![\s\S]{0,50}max_rate|[\s\S]{0,50}cap)/i,
    description: "Borrow rate without maximum cap.",
    recommendation: "Cap maximum borrow rates.",
    category: "Lending"
  },
  // io.net Patterns
  {
    id: "SOL2524",
    name: "io.net: Worker Node Verification",
    severity: "high",
    pattern: /worker[\s\S]{0,30}node(?![\s\S]{0,50}stake|[\s\S]{0,50}verify)/i,
    description: "Worker nodes without stake or verification.",
    recommendation: "Require stake and verification for workers.",
    category: "Infrastructure"
  },
  {
    id: "SOL2525",
    name: "io.net: Compute Proof Validation",
    severity: "high",
    pattern: /compute[\s\S]{0,30}proof(?![\s\S]{0,50}verify|[\s\S]{0,50}challenge)/i,
    description: "Compute proofs without challenge-response.",
    recommendation: "Implement proof-of-compute challenges.",
    category: "Infrastructure"
  },
  // SVT Token Patterns
  {
    id: "SOL2526",
    name: "SVT: Mint Authority Handoff",
    severity: "critical",
    pattern: /mint[\s\S]{0,30}authority[\s\S]{0,30}(?![\s\S]{0,50}revoke|[\s\S]{0,50}null)/i,
    description: "Mint authority not revoked after initial distribution.",
    recommendation: "Revoke mint authority after token distribution.",
    category: "Token"
  },
  {
    id: "SOL2527",
    name: "SVT: Supply Verification",
    severity: "high",
    pattern: /total[\s\S]{0,30}supply(?![\s\S]{0,50}verify|[\s\S]{0,50}max)/i,
    description: "Total supply without maximum verification.",
    recommendation: "Verify total supply against maximum.",
    category: "Token"
  },
  // Network-Level Attack Patterns
  {
    id: "SOL2528",
    name: "Grape: Transaction Flood Protection",
    severity: "high",
    pattern: /transaction[\s\S]{0,30}(?![\s\S]{0,50}rate_limit|[\s\S]{0,50}throttle)/i,
    description: "No transaction rate limiting (Grape DDoS pattern).",
    recommendation: "Implement transaction rate limits.",
    category: "Network"
  },
  {
    id: "SOL2529",
    name: "Candy Machine: Bot Protection",
    severity: "high",
    pattern: /mint[\s\S]{0,30}public(?![\s\S]{0,50}captcha|[\s\S]{0,50}allowlist)/i,
    description: "Public mint without bot protection.",
    recommendation: "Add captcha or allowlist for public mints.",
    category: "NFT"
  },
  {
    id: "SOL2530",
    name: "Jito: Bundle Priority Manipulation",
    severity: "medium",
    pattern: /bundle[\s\S]{0,30}priority(?![\s\S]{0,50}fair_ordering)/i,
    description: "Bundle priority without fair ordering guarantees.",
    recommendation: "Consider fair ordering mechanisms.",
    category: "MEV"
  },
  // Core Protocol Vulnerability Patterns
  {
    id: "SOL2531",
    name: "Turbine: Block Propagation",
    severity: "high",
    pattern: /block[\s\S]{0,30}propagat(?![\s\S]{0,50}timeout|[\s\S]{0,50}fallback)/i,
    description: "Block propagation without timeout handling.",
    recommendation: "Handle block propagation timeouts gracefully.",
    category: "Core"
  },
  {
    id: "SOL2532",
    name: "Durable Nonce: Advancement Check",
    severity: "high",
    pattern: /nonce[\s\S]{0,30}(?![\s\S]{0,50}advance|[\s\S]{0,50}verify_recent)/i,
    description: "Durable nonce without advancement verification.",
    recommendation: "Verify nonce advancement before use.",
    category: "Core"
  },
  {
    id: "SOL2533",
    name: "JIT Cache: Compilation Safety",
    severity: "high",
    pattern: /jit[\s\S]{0,30}compile(?![\s\S]{0,50}sandbox|[\s\S]{0,50}verify)/i,
    description: "JIT compilation without sandboxing.",
    recommendation: "Sandbox JIT compilation processes.",
    category: "Core"
  },
  // Supply Chain Attack Patterns
  {
    id: "SOL2534",
    name: "Web3.js: Package Integrity",
    severity: "critical",
    pattern: /@solana[\s\S]{0,30}(?![\s\S]{0,50}integrity|[\s\S]{0,50}checksum)/i,
    description: "Solana packages without integrity verification.",
    recommendation: "Verify package integrity with checksums.",
    category: "Supply Chain"
  },
  {
    id: "SOL2535",
    name: "NPM: Dependency Lock",
    severity: "high",
    pattern: /dependencies[\s\S]{0,30}(?![\s\S]{0,50}lock|[\s\S]{0,50}exact)/i,
    description: "Dependencies without lock file.",
    recommendation: "Use lock files and exact versions.",
    category: "Supply Chain"
  },
  {
    id: "SOL2536",
    name: "CDN: Frontend Integrity",
    severity: "high",
    pattern: /script[\s\S]{0,30}src[\s\S]{0,30}(?![\s\S]{0,50}integrity)/i,
    description: "CDN scripts without SRI integrity.",
    recommendation: "Add SRI integrity attributes to CDN scripts.",
    category: "Supply Chain"
  },
  // Advanced Protocol Patterns
  {
    id: "SOL2537",
    name: "Jupiter: Route Aggregation Safety",
    severity: "high",
    pattern: /route[\s\S]{0,30}aggregate(?![\s\S]{0,50}slippage|[\s\S]{0,50}deadline)/i,
    description: "Route aggregation without slippage protection.",
    recommendation: "Enforce slippage and deadline on aggregated routes.",
    category: "DEX"
  },
  {
    id: "SOL2538",
    name: "Marinade: Stake Pool Manipulation",
    severity: "high",
    pattern: /stake[\s\S]{0,30}pool[\s\S]{0,30}(?![\s\S]{0,50}validator_set)/i,
    description: "Stake pool without validator set verification.",
    recommendation: "Verify validator set for stake pool operations.",
    category: "Staking"
  },
  {
    id: "SOL2539",
    name: "Drift: Perp Funding Rate",
    severity: "medium",
    pattern: /funding[\s\S]{0,30}rate(?![\s\S]{0,50}cap|[\s\S]{0,50}bounds)/i,
    description: "Perpetual funding rate without bounds.",
    recommendation: "Cap funding rates to prevent manipulation.",
    category: "Perps"
  },
  {
    id: "SOL2540",
    name: "Phoenix: Order Book Integrity",
    severity: "high",
    pattern: /order[\s\S]{0,30}book(?![\s\S]{0,50}verify_sorted)/i,
    description: "Order book without sort verification.",
    recommendation: "Verify order book sort integrity.",
    category: "DEX"
  },
  // Stablecoin Specific
  {
    id: "SOL2541",
    name: "USDC: Blacklist Check",
    severity: "high",
    pattern: /usdc[\s\S]{0,30}transfer(?![\s\S]{0,50}blacklist_check)/i,
    description: "USDC transfer without blacklist consideration.",
    recommendation: "Check USDC blacklist before transfers.",
    category: "Token"
  },
  {
    id: "SOL2542",
    name: "Stablecoin: Depeg Detection",
    severity: "high",
    pattern: /stablecoin[\s\S]{0,30}(?![\s\S]{0,50}peg_check|[\s\S]{0,50}deviation)/i,
    description: "Stablecoin operations without depeg detection.",
    recommendation: "Implement depeg detection and circuit breakers.",
    category: "Token"
  },
  // Governance Advanced
  {
    id: "SOL2543",
    name: "DAO: Proposal Spam Protection",
    severity: "medium",
    pattern: /proposal[\s\S]{0,30}create(?![\s\S]{0,50}stake_required|[\s\S]{0,50}deposit)/i,
    description: "Proposal creation without stake requirement.",
    recommendation: "Require stake or deposit for proposals.",
    category: "Governance"
  },
  {
    id: "SOL2544",
    name: "DAO: Execution Delay",
    severity: "high",
    pattern: /execute[\s\S]{0,30}proposal(?![\s\S]{0,50}timelock|[\s\S]{0,50}delay)/i,
    description: "Proposal execution without timelock.",
    recommendation: "Add timelock delay for proposal execution.",
    category: "Governance"
  },
  {
    id: "SOL2545",
    name: "DAO: Quorum Manipulation",
    severity: "high",
    pattern: /quorum[\s\S]{0,30}(?![\s\S]{0,50}snapshot|[\s\S]{0,50}fixed)/i,
    description: "Quorum calculation without snapshot.",
    recommendation: "Use snapshot for quorum calculations.",
    category: "Governance"
  },
  // NFT Marketplace Patterns
  {
    id: "SOL2546",
    name: "NFT: Royalty Enforcement",
    severity: "medium",
    pattern: /royalt(?![\s\S]{0,50}enforce|[\s\S]{0,50}programmable)/i,
    description: "NFT royalties not enforced on-chain.",
    recommendation: "Use programmable NFTs for royalty enforcement.",
    category: "NFT"
  },
  {
    id: "SOL2547",
    name: "NFT: Collection Verification",
    severity: "high",
    pattern: /collection[\s\S]{0,30}(?![\s\S]{0,50}verified|[\s\S]{0,50}authority)/i,
    description: "NFT collection without verification.",
    recommendation: "Verify collection authority.",
    category: "NFT"
  },
  {
    id: "SOL2548",
    name: "NFT: Metadata Mutability",
    severity: "medium",
    pattern: /metadata[\s\S]{0,30}update(?![\s\S]{0,50}authority_check)/i,
    description: "NFT metadata updates without authority check.",
    recommendation: "Verify update authority for metadata changes.",
    category: "NFT"
  },
  // Bridge Patterns
  {
    id: "SOL2549",
    name: "Bridge: Source Finality",
    severity: "critical",
    pattern: /bridge[\s\S]{0,30}receive(?![\s\S]{0,50}finality_wait)/i,
    description: "Bridge receiving without source finality.",
    recommendation: "Wait for source chain finality.",
    category: "Cross-Chain"
  },
  {
    id: "SOL2550",
    name: "Bridge: Relayer Incentives",
    severity: "medium",
    pattern: /relayer[\s\S]{0,30}(?![\s\S]{0,50}incentive|[\s\S]{0,50}fee)/i,
    description: "Bridge relayer without incentive alignment.",
    recommendation: "Align relayer incentives with protocol.",
    category: "Cross-Chain"
  },
  // Advanced Security Patterns
  {
    id: "SOL2551",
    name: "Reentrancy: CPI State Check",
    severity: "critical",
    pattern: /invoke[\s\S]{0,50}[\s\S]{0,30}state(?![\s\S]{0,50}before_cpi)/i,
    description: "State accessed after CPI without re-check.",
    recommendation: "Re-check state after CPI calls.",
    category: "Reentrancy"
  },
  {
    id: "SOL2552",
    name: "Reentrancy: Guard Pattern",
    severity: "high",
    pattern: /pub fn[\s\S]{0,100}invoke(?![\s\S]{0,200}reentrancy_guard|[\s\S]{0,200}mutex)/i,
    description: "Function with CPI lacks reentrancy guard.",
    recommendation: "Add reentrancy guard to CPI functions.",
    category: "Reentrancy"
  },
  // Memory & Compute Patterns
  {
    id: "SOL2553",
    name: "Compute: Budget Estimation",
    severity: "medium",
    pattern: /compute[\s\S]{0,30}budget(?![\s\S]{0,50}estimate|[\s\S]{0,50}buffer)/i,
    description: "Compute budget without safety buffer.",
    recommendation: "Add buffer to compute budget estimates.",
    category: "Performance"
  },
  {
    id: "SOL2554",
    name: "Memory: Heap Allocation",
    severity: "medium",
    pattern: /vec!|Vec::new(?![\s\S]{0,50}with_capacity)/i,
    description: "Vector without pre-allocation.",
    recommendation: "Use with_capacity for known sizes.",
    category: "Performance"
  },
  // Error Handling
  {
    id: "SOL2555",
    name: "Error: Generic Handler",
    severity: "medium",
    pattern: /catch[\s\S]{0,30}(?![\s\S]{0,50}specific|[\s\S]{0,50}match)/i,
    description: "Generic error handling hiding specific failures.",
    recommendation: "Handle specific errors appropriately.",
    category: "Error"
  },
  {
    id: "SOL2556",
    name: "Error: Silent Failure",
    severity: "high",
    pattern: /\.ok\(\)|\.unwrap_or(?![\s\S]{0,50}log|[\s\S]{0,50}emit)/i,
    description: "Error silently converted to default.",
    recommendation: "Log or emit events for error cases.",
    category: "Error"
  },
  // Monitoring & Observability
  {
    id: "SOL2557",
    name: "Audit: Trail Missing",
    severity: "medium",
    pattern: /admin[\s\S]{0,30}action(?![\s\S]{0,50}emit!|[\s\S]{0,50}log)/i,
    description: "Admin actions without audit trail.",
    recommendation: "Log all admin actions for audit.",
    category: "Audit"
  },
  {
    id: "SOL2558",
    name: "Metrics: TVL Tracking",
    severity: "low",
    pattern: /deposit|withdraw(?![\s\S]{0,100}total_value)/i,
    description: "Value operations without TVL tracking.",
    recommendation: "Track TVL for monitoring.",
    category: "Metrics"
  },
  // Upgrade Patterns
  {
    id: "SOL2559",
    name: "Upgrade: Migration Safety",
    severity: "high",
    pattern: /upgrade[\s\S]{0,30}(?![\s\S]{0,50}migrate|[\s\S]{0,50}compatible)/i,
    description: "Program upgrade without migration plan.",
    recommendation: "Plan data migration for upgrades.",
    category: "Upgrade"
  },
  {
    id: "SOL2560",
    name: "Upgrade: Rollback Capability",
    severity: "medium",
    pattern: /upgrade[\s\S]{0,30}(?![\s\S]{0,50}rollback|[\s\S]{0,50}previous)/i,
    description: "Upgrade without rollback capability.",
    recommendation: "Maintain rollback capability for upgrades.",
    category: "Upgrade"
  }
];
function checkBatch60Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_60_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description + (pattern.category ? ` [Category: ${pattern.category}]` : ""),
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_60_COUNT = BATCH_60_PATTERNS.length;

// src/patterns/solana-batched-patterns-61.ts
var ORACLE_ADVANCED_PATTERNS = [
  {
    id: "SOL2561",
    name: "Oracle Update Failure Silent Pass",
    severity: "critical",
    pattern: /get_price|fetch_price|oracle\.price(?![\s\S]{0,100}(stale|fresh|valid|check|error|fail|none|some))/i,
    description: "Oracle price fetch without handling update failures. From Certora Lulo audit - oracle updates can fail silently.",
    recommendation: "Handle oracle update failures explicitly and fail gracefully or use fallback prices."
  },
  {
    id: "SOL2562",
    name: "Pyth Confidence Interval Ignored",
    severity: "high",
    pattern: /pyth[\s\S]{0,50}price(?![\s\S]{0,100}conf|confidence)/i,
    description: "Pyth oracle used without checking confidence interval. High confidence intervals indicate unreliable prices.",
    recommendation: "Check price.conf and reject prices where conf/price ratio exceeds threshold (e.g., 1%)."
  },
  {
    id: "SOL2563",
    name: "Switchboard Staleness Unchecked",
    severity: "high",
    pattern: /switchboard[\s\S]{0,50}(result|feed)(?![\s\S]{0,100}timestamp|staleness|max_age)/i,
    description: "Switchboard feed used without staleness validation.",
    recommendation: "Verify feed timestamp is within acceptable age (e.g., <30 seconds for volatile assets)."
  },
  {
    id: "SOL2564",
    name: "TWAP Window Too Short",
    severity: "medium",
    pattern: /twap[\s\S]{0,50}(window|period)[\s\S]{0,20}(60|30|15|10|5)\b/i,
    description: "TWAP window shorter than 5 minutes is vulnerable to manipulation.",
    recommendation: "Use TWAP windows of at least 15-30 minutes for critical price feeds."
  },
  {
    id: "SOL2565",
    name: "Single Oracle Source Dependency",
    severity: "high",
    pattern: /oracle[\s\S]{0,100}price(?![\s\S]{0,200}(fallback|backup|secondary|aggregate))/i,
    description: "Single oracle dependency without fallback. Oracle downtime = protocol halt.",
    recommendation: "Implement fallback oracles or use aggregated price feeds from multiple sources."
  },
  {
    id: "SOL2566",
    name: "Price Deviation Unchecked Between Oracles",
    severity: "high",
    pattern: /(oracle_a|oracle_1|primary)[\s\S]{0,100}(oracle_b|oracle_2|secondary)(?![\s\S]{0,100}deviation|diff|delta)/i,
    description: "Multiple oracles used without checking deviation between them.",
    recommendation: "Reject transactions when oracle prices deviate more than threshold (e.g., 5%)."
  },
  {
    id: "SOL2567",
    name: "Market Price vs Oracle Price Arbitrage",
    severity: "critical",
    pattern: /(swap|trade|exchange)[\s\S]{0,200}oracle[\s\S]{0,100}price(?![\s\S]{0,100}bound|limit|deviation)/i,
    description: "No bounds checking between market execution and oracle price. Enables oracle arbitrage.",
    recommendation: "Enforce maximum deviation between oracle and execution price."
  },
  {
    id: "SOL2568",
    name: "Liquidation Oracle Manipulation Window",
    severity: "critical",
    pattern: /liquidat[\s\S]{0,100}(price|oracle)(?![\s\S]{0,100}delay|twap|average)/i,
    description: "Liquidations using spot price without delay or averaging. From Mango exploit.",
    recommendation: "Use time-delayed or TWAP prices for liquidation to prevent manipulation."
  },
  {
    id: "SOL2569",
    name: "Oracle Decimal Mismatch",
    severity: "high",
    pattern: /oracle[\s\S]{0,100}(price|value)[\s\S]{0,50}(decimals|scale|exponent)(?![\s\S]{0,50}(normalize|adjust|convert))/i,
    description: "Oracle price decimals not normalized. Different oracles use different decimal scales.",
    recommendation: "Always normalize oracle prices to a consistent decimal scale before use."
  },
  {
    id: "SOL2570",
    name: "LP Token Oracle Price Manipulation",
    severity: "critical",
    pattern: /lp_token[\s\S]{0,100}(price|value)(?![\s\S]{0,100}(fair|underlying|reserve))/i,
    description: 'LP token priced without fair value calculation. From OtterSec "$200M Bluff" research.',
    recommendation: "Calculate LP token fair value from underlying reserves, not AMM spot price."
  },
  {
    id: "SOL2571",
    name: "Flash Loan Oracle Attack Window",
    severity: "critical",
    pattern: /flash[\s\S]{0,50}(loan|borrow)[\s\S]{0,200}oracle[\s\S]{0,100}price/i,
    description: "Oracle read susceptible to same-transaction flash loan manipulation.",
    recommendation: "Use TWAP, previous block price, or multiple confirmation prices for critical operations."
  },
  {
    id: "SOL2572",
    name: "Oracle Heartbeat Check Missing",
    severity: "medium",
    pattern: /oracle[\s\S]{0,100}(feed|source)(?![\s\S]{0,100}(heartbeat|alive|active|status))/i,
    description: "Oracle used without checking if feed is actively updating.",
    recommendation: "Verify oracle heartbeat/update frequency before trusting prices."
  },
  {
    id: "SOL2573",
    name: "Negative Price Not Handled",
    severity: "high",
    pattern: /price[\s\S]{0,30}(i64|i128|signed)(?![\s\S]{0,50}(abs|positive|unsigned|check))/i,
    description: "Signed price type without negative value handling. Some assets can have negative prices.",
    recommendation: "Handle negative prices appropriately or reject if unexpected."
  },
  {
    id: "SOL2574",
    name: "Price Impact Not Calculated",
    severity: "high",
    pattern: /(swap|trade|exchange)[\s\S]{0,100}amount(?![\s\S]{0,100}(impact|slippage|price_impact))/i,
    description: "Trade execution without calculating price impact for large orders.",
    recommendation: "Calculate and display price impact, reject if exceeds user-defined threshold."
  },
  {
    id: "SOL2575",
    name: "Stale Oracle Causes Liquidation Cascade",
    severity: "critical",
    pattern: /liquidat[\s\S]{0,100}(health|ratio|factor)[\s\S]{0,100}oracle(?![\s\S]{0,100}fresh)/i,
    description: "Liquidation using potentially stale oracle data can cause cascade liquidations.",
    recommendation: "Verify oracle freshness before any liquidation, use conservative staleness thresholds."
  }
];
var REFERRAL_FEE_PATTERNS = [
  {
    id: "SOL2576",
    name: "Self-Referral Fee Extraction",
    severity: "high",
    pattern: /referr(al|er)[\s\S]{0,100}fee(?![\s\S]{0,100}(self|same|user|owner))/i,
    description: "Referral system without self-referral prevention. From Certora Lulo audit.",
    recommendation: "Prevent users from referring themselves to extract fees."
  },
  {
    id: "SOL2577",
    name: "Referral Fee Unbounded",
    severity: "high",
    pattern: /referr(al|er)[\s\S]{0,50}(fee|percent|bps)(?![\s\S]{0,50}(max|cap|limit|bound))/i,
    description: "Referral fee percentage not bounded. Could be set to 100%.",
    recommendation: "Cap referral fees at reasonable maximum (e.g., 50% of protocol fee)."
  },
  {
    id: "SOL2578",
    name: "Fee Precision Loss Attack",
    severity: "medium",
    pattern: /fee[\s\S]{0,50}(amount|value)[\s\S]{0,30}\/[\s\S]{0,30}(100|1000|10000)(?![\s\S]{0,50}checked)/i,
    description: "Fee calculation with potential precision loss in division.",
    recommendation: "Calculate fees with sufficient precision, consider using fixed-point math."
  },
  {
    id: "SOL2579",
    name: "Protocol Fee Bypass via Routing",
    severity: "high",
    pattern: /(route|path|hop)[\s\S]{0,100}(fee|swap)(?![\s\S]{0,100}aggregate_fee)/i,
    description: "Multi-hop routing that could bypass protocol fees.",
    recommendation: "Ensure fees are collected on each hop or aggregated correctly."
  },
  {
    id: "SOL2580",
    name: "Fee-on-Transfer Token Handling",
    severity: "high",
    pattern: /transfer[\s\S]{0,100}(amount|value)(?![\s\S]{0,100}(actual|received|post_fee))/i,
    description: "Token transfers without accounting for fee-on-transfer tokens.",
    recommendation: "Check actual received amount vs expected for fee-on-transfer tokens."
  },
  {
    id: "SOL2581",
    name: "Treasury Fee Drain via Dust",
    severity: "medium",
    pattern: /treasury[\s\S]{0,100}(withdraw|claim|collect)(?![\s\S]{0,100}minimum)/i,
    description: "Treasury withdrawal without minimum amount could drain via dust attacks.",
    recommendation: "Enforce minimum withdrawal amounts to prevent dust drain attacks."
  },
  {
    id: "SOL2582",
    name: "Fee Accrual Without Claim Limit",
    severity: "medium",
    pattern: /(accru|earn|collect)[\s\S]{0,50}fee(?![\s\S]{0,100}(rate_limit|cooldown|max))/i,
    description: "Fee accrual without rate limiting could be gamed.",
    recommendation: "Rate limit fee claims or implement fair distribution mechanism."
  },
  {
    id: "SOL2583",
    name: "Dynamic Fee Manipulation",
    severity: "high",
    pattern: /(dynamic|variable)[\s\S]{0,30}fee(?![\s\S]{0,100}(bound|range|admin_only))/i,
    description: "Dynamic fees without bounds could be manipulated.",
    recommendation: "Bound dynamic fees within reasonable range and protect update authority."
  },
  {
    id: "SOL2584",
    name: "Flash Loan Fee Evasion",
    severity: "high",
    pattern: /flash[\s\S]{0,50}(loan|borrow)[\s\S]{0,100}fee(?![\s\S]{0,100}(minimum|floor))/i,
    description: "Flash loan fee could be evaded through minimum amount manipulation.",
    recommendation: "Set minimum flash loan fee floor to prevent evasion."
  },
  {
    id: "SOL2585",
    name: "Withdrawal Fee Frontrun",
    severity: "medium",
    pattern: /withdraw[\s\S]{0,50}fee[\s\S]{0,50}(update|change|set)(?![\s\S]{0,100}timelock)/i,
    description: "Withdrawal fee changes without timelock enable frontrunning users.",
    recommendation: "Add timelock to fee changes so users can withdraw before increase."
  },
  {
    id: "SOL2586",
    name: "Performance Fee Timing Attack",
    severity: "high",
    pattern: /performance[\s\S]{0,50}fee[\s\S]{0,100}(calculate|collect)(?![\s\S]{0,100}highwater)/i,
    description: "Performance fee without high-water mark enables timing attacks.",
    recommendation: "Implement high-water mark for performance fee calculation."
  },
  {
    id: "SOL2587",
    name: "Management Fee Compounding Error",
    severity: "medium",
    pattern: /management[\s\S]{0,50}fee[\s\S]{0,50}(annual|yearly)(?![\s\S]{0,100}pro_rat)/i,
    description: "Annual management fee not pro-rated could be gamed.",
    recommendation: "Pro-rate management fees based on actual time elapsed."
  },
  {
    id: "SOL2588",
    name: "Swap Fee Rounding Exploit",
    severity: "medium",
    pattern: /swap[\s\S]{0,50}fee[\s\S]{0,50}(round|truncat)(?![\s\S]{0,100}favor_protocol)/i,
    description: "Swap fee rounding direction favors user over protocol.",
    recommendation: "Round fees in favor of protocol to prevent dust extraction."
  },
  {
    id: "SOL2589",
    name: "Liquidation Fee Manipulation",
    severity: "high",
    pattern: /liquidat[\s\S]{0,50}(bonus|fee|reward)(?![\s\S]{0,100}(cap|max|limit))/i,
    description: "Unbounded liquidation bonus enables excessive extraction.",
    recommendation: "Cap liquidation bonus at reasonable maximum (e.g., 15%)."
  },
  {
    id: "SOL2590",
    name: "Cross-Program Fee Bypass",
    severity: "high",
    pattern: /invoke[\s\S]{0,100}(swap|transfer)(?![\s\S]{0,100}fee_check)/i,
    description: "CPI to external program may bypass fee collection.",
    recommendation: "Verify fees are collected regardless of execution path."
  }
];
var WITHDRAWAL_DEPOSIT_PATTERNS = [
  {
    id: "SOL2591",
    name: "Withdrawal Amount Manipulation",
    severity: "critical",
    pattern: /withdraw[\s\S]{0,100}(amount|value)(?![\s\S]{0,100}(balance|available|check))/i,
    description: "Withdrawal amount not validated against actual balance. From Certora Lulo audit.",
    recommendation: "Always verify withdrawal amount against available balance before transfer."
  },
  {
    id: "SOL2592",
    name: "First Depositor Vault Attack",
    severity: "critical",
    pattern: /deposit[\s\S]{0,100}(shares|mint)[\s\S]{0,50}(total_supply|supply)\s*==\s*0/i,
    description: "First depositor can manipulate share price. Classic vault attack vector.",
    recommendation: "Seed vault with initial deposit or use virtual offset for share calculation."
  },
  {
    id: "SOL2593",
    name: "Share Inflation via Donation",
    severity: "critical",
    pattern: /shares[\s\S]{0,50}(assets|balance)[\s\S]{0,50}total(?![\s\S]{0,100}(virtual|offset))/i,
    description: "Direct asset donation can inflate share price and grief small depositors.",
    recommendation: "Use virtual offset or minimum deposit to prevent share inflation attack."
  },
  {
    id: "SOL2594",
    name: "Withdrawal Queue Jump",
    severity: "high",
    pattern: /withdraw[\s\S]{0,50}queue(?![\s\S]{0,100}(order|fifo|priority))/i,
    description: "Withdrawal queue without ordering enables queue jumping.",
    recommendation: "Enforce FIFO or priority-based queue processing."
  },
  {
    id: "SOL2595",
    name: "Deposit During Pause",
    severity: "medium",
    pattern: /paused[\s\S]{0,100}deposit(?![\s\S]{0,100}require.*!paused)/i,
    description: "Deposits may be possible during pause state.",
    recommendation: "Block both deposits and withdrawals during paused state."
  },
  {
    id: "SOL2596",
    name: "Withdrawal Minimum Not Enforced",
    severity: "low",
    pattern: /withdraw[\s\S]{0,50}(amount|value)(?![\s\S]{0,100}(minimum|min_amount))/i,
    description: "No minimum withdrawal amount enables dust attacks.",
    recommendation: "Enforce minimum withdrawal to prevent state bloat and dust attacks."
  },
  {
    id: "SOL2597",
    name: "Deposit Cap Bypass via Multiple Transactions",
    severity: "medium",
    pattern: /deposit[\s\S]{0,50}(cap|limit|max)(?![\s\S]{0,100}(user|total|cumulative))/i,
    description: "Deposit cap only checks single transaction, not cumulative.",
    recommendation: "Track cumulative deposits per user and enforce cap accordingly."
  },
  {
    id: "SOL2598",
    name: "Withdrawal Delay Bypass",
    severity: "high",
    pattern: /withdraw[\s\S]{0,50}(delay|cooldown|lock)(?![\s\S]{0,100}(enforce|check|verify))/i,
    description: "Withdrawal delay declared but not enforced in execution.",
    recommendation: "Verify delay period has elapsed before processing withdrawal."
  },
  {
    id: "SOL2599",
    name: "Instant Withdrawal During Emergency",
    severity: "high",
    pattern: /emergency[\s\S]{0,50}withdraw(?![\s\S]{0,100}(partial|limit|delay))/i,
    description: "Emergency withdrawal without rate limit enables bank run.",
    recommendation: "Even emergency withdrawals should have rate limits to prevent total drain."
  },
  {
    id: "SOL2600",
    name: "Deposit Deadline Not Checked",
    severity: "medium",
    pattern: /deposit[\s\S]{0,100}deadline(?![\s\S]{0,100}(check|require|verify))/i,
    description: "Deposit deadline parameter ignored in validation.",
    recommendation: "Reject deposits after specified deadline to prevent stale transactions."
  },
  {
    id: "SOL2601",
    name: "Asset Decimal Mismatch in Deposit",
    severity: "high",
    pattern: /deposit[\s\S]{0,100}(mint|token)(?![\s\S]{0,100}decimals)/i,
    description: "Deposit amount not adjusted for token decimals.",
    recommendation: "Normalize amounts based on token decimals before calculation."
  },
  {
    id: "SOL2602",
    name: "Withdrawal Rounding Favor Attacker",
    severity: "medium",
    pattern: /withdraw[\s\S]{0,50}(amount|shares)[\s\S]{0,30}(round|floor|ceil)/i,
    description: "Withdrawal rounding direction may favor attacker over protocol.",
    recommendation: "Round withdrawals down (floor) to favor protocol."
  },
  {
    id: "SOL2603",
    name: "Deposit Slippage Check Missing",
    severity: "high",
    pattern: /deposit[\s\S]{0,100}(shares|mint)(?![\s\S]{0,100}(min_shares|slippage))/i,
    description: "Deposit returns shares without minimum shares check.",
    recommendation: "Allow users to specify minimum shares expected from deposit."
  },
  {
    id: "SOL2604",
    name: "Withdrawal Max Slippage Unbounded",
    severity: "high",
    pattern: /withdraw[\s\S]{0,100}slippage(?![\s\S]{0,100}(max|cap|bound))/i,
    description: "Withdrawal slippage not bounded could result in near-zero returns.",
    recommendation: "Enforce maximum slippage tolerance for withdrawals."
  },
  {
    id: "SOL2605",
    name: "Locked Funds Recovery Missing",
    severity: "medium",
    pattern: /(stuck|lock|trap)[\s\S]{0,50}(fund|token|asset)(?![\s\S]{0,100}recover)/i,
    description: "No mechanism to recover stuck funds from edge cases.",
    recommendation: "Implement admin recovery function with appropriate safeguards."
  }
];
var ACCESS_CONTROL_ADVANCED_PATTERNS = [
  {
    id: "SOL2606",
    name: "Admin Key Single Point of Failure",
    severity: "critical",
    pattern: /admin[\s\S]{0,50}(pubkey|authority|key)(?![\s\S]{0,100}(multisig|threshold|quorum))/i,
    description: "Single admin key controls critical functions. From Accretion audit findings.",
    recommendation: "Use multisig or threshold signatures for admin operations."
  },
  {
    id: "SOL2607",
    name: "Privilege Escalation via Upgrade",
    severity: "critical",
    pattern: /upgrade[\s\S]{0,50}(authority|program)(?![\s\S]{0,100}timelock)/i,
    description: "Program upgrade without timelock enables immediate privilege escalation.",
    recommendation: "Implement upgrade timelock with governance oversight."
  },
  {
    id: "SOL2608",
    name: "Role Assignment Without Revocation",
    severity: "high",
    pattern: /role[\s\S]{0,50}(assign|grant|add)(?![\s\S]{0,200}(revoke|remove|delete))/i,
    description: "Role assignment exists but revocation mechanism missing.",
    recommendation: "Always implement role revocation alongside assignment."
  },
  {
    id: "SOL2609",
    name: "Emergency Admin Backdoor",
    severity: "critical",
    pattern: /emergency[\s\S]{0,50}(admin|owner|authority)(?![\s\S]{0,100}(timelock|multisig))/i,
    description: "Emergency admin functions without additional safeguards.",
    recommendation: "Even emergency functions need timelock or multisig for non-emergency use."
  },
  {
    id: "SOL2610",
    name: "Authority Transfer Without 2-Step",
    severity: "high",
    pattern: /authority[\s\S]{0,30}=[\s\S]{0,30}new_authority(?![\s\S]{0,100}(pending|accept))/i,
    description: "Authority transfer immediate without 2-step process.",
    recommendation: "Use 2-step transfer: propose then accept, to prevent accidental loss."
  },
  {
    id: "SOL2611",
    name: "Guardian Set Update Without Delay",
    severity: "critical",
    pattern: /guardian[\s\S]{0,50}(set|update|change)(?![\s\S]{0,100}delay)/i,
    description: "Guardian set can be changed immediately. From Wormhole analysis.",
    recommendation: "Guardian changes should have significant delay (24-72 hours)."
  },
  {
    id: "SOL2612",
    name: "Pauser Role Without Unpauser",
    severity: "high",
    pattern: /pause[\s\S]{0,50}(only|require)(?![\s\S]{0,200}unpause)/i,
    description: "Pause functionality exists but unpause may be missing or restricted.",
    recommendation: "Ensure unpause mechanism exists and is properly controlled."
  },
  {
    id: "SOL2613",
    name: "Config Update Without Bounds",
    severity: "high",
    pattern: /config[\s\S]{0,30}(update|set)[\s\S]{0,50}(param|value)(?![\s\S]{0,100}(valid|bound|range))/i,
    description: "Configuration parameters can be set to arbitrary values.",
    recommendation: "Validate config parameters against acceptable bounds."
  },
  {
    id: "SOL2614",
    name: "CPI Authority Leak",
    severity: "critical",
    pattern: /invoke_signed[\s\S]{0,100}(signer|authority)(?![\s\S]{0,100}scope_check)/i,
    description: "PDA signing authority may be used beyond intended scope via CPI.",
    recommendation: "Verify CPI operations are within intended authority scope."
  },
  {
    id: "SOL2615",
    name: "Operator Privilege Creep",
    severity: "high",
    pattern: /operator[\s\S]{0,50}(can|allow|permit)(?![\s\S]{0,100}(only|specific|limited))/i,
    description: "Operator role has more privileges than necessary.",
    recommendation: "Minimize operator privileges to only required operations."
  },
  {
    id: "SOL2616",
    name: "Treasury Access Without Multi-Approval",
    severity: "critical",
    pattern: /treasury[\s\S]{0,50}(withdraw|transfer|spend)(?![\s\S]{0,100}(multisig|quorum|threshold))/i,
    description: "Treasury access with single signature. From real-world DAO attacks.",
    recommendation: "Require multi-approval for treasury operations."
  },
  {
    id: "SOL2617",
    name: "Time-Based Access Not UTC",
    severity: "medium",
    pattern: /(start_time|end_time|deadline)[\s\S]{0,50}(check|compare)(?![\s\S]{0,100}utc)/i,
    description: "Time-based access control may use inconsistent time zones.",
    recommendation: "Always use UTC timestamps for time-based access control."
  },
  {
    id: "SOL2618",
    name: "Access Control Log Missing",
    severity: "low",
    pattern: /(admin|owner|authority)[\s\S]{0,50}(action|call)(?![\s\S]{0,200}(emit|log|event))/i,
    description: "Privileged actions not logged for audit trail.",
    recommendation: "Emit events for all privileged operations for forensics."
  },
  {
    id: "SOL2619",
    name: "Rate Limit Per User Missing",
    severity: "medium",
    pattern: /rate_limit[\s\S]{0,50}(global|total)(?![\s\S]{0,100}(per_user|individual))/i,
    description: "Global rate limit but no per-user limit enables single user to consume quota.",
    recommendation: "Implement both global and per-user rate limits."
  },
  {
    id: "SOL2620",
    name: "Cross-Program Authority Confusion",
    severity: "high",
    pattern: /invoke[\s\S]{0,100}(authority|signer)[\s\S]{0,100}(different|external)_program/i,
    description: "Authority from one program used to sign for different program.",
    recommendation: "Verify authority context matches expected program."
  }
];
var MEMORY_SAFETY_PATTERNS = [
  {
    id: "SOL2621",
    name: "Unsafe Block Without Justification",
    severity: "high",
    pattern: /unsafe\s*\{[\s\S]{0,200}(?!\/\/\s*(SAFETY|JUSTIFICATION|REASON))/i,
    description: "Unsafe Rust block without safety justification comment.",
    recommendation: "Document why unsafe is necessary and why it is safe in this context."
  },
  {
    id: "SOL2622",
    name: "Zero-Copy Aliasing Risk",
    severity: "critical",
    pattern: /zero_copy[\s\S]{0,100}(borrow|ref)[\s\S]{0,100}(mut|mutable)/i,
    description: "Zero-copy account with mutable borrow may cause aliasing. From Three Sigma research.",
    recommendation: "Avoid mutable borrows with zero-copy accounts or use RefCell carefully."
  },
  {
    id: "SOL2623",
    name: "Raw Pointer Dereference",
    severity: "critical",
    pattern: /\*\s*(const|mut)\s*\w+[\s\S]{0,50}as\s*\*(?![\s\S]{0,50}null_check)/i,
    description: "Raw pointer dereference without null check.",
    recommendation: "Always verify pointer is non-null before dereferencing."
  },
  {
    id: "SOL2624",
    name: "Uninitialized Memory Read",
    severity: "critical",
    pattern: /MaybeUninit[\s\S]{0,50}assume_init(?![\s\S]{0,100}(after|once|when).*init)/i,
    description: "Assuming memory is initialized without verification.",
    recommendation: "Only call assume_init after provably initializing all bytes."
  },
  {
    id: "SOL2625",
    name: "Transmute Type Size Mismatch",
    severity: "critical",
    pattern: /transmute[\s\S]{0,50}<[\s\S]{0,50},[\s\S]{0,50}>(?![\s\S]{0,100}size_of.*==)/i,
    description: "Type transmutation without size verification.",
    recommendation: "Verify source and destination types have identical size before transmute."
  },
  {
    id: "SOL2626",
    name: "Slice Index Without Bounds",
    severity: "high",
    pattern: /\[\s*\w+\s*\](?![\s\S]{0,30}(get|get_unchecked|\.len\(\)))/i,
    description: "Array/slice indexing without bounds check.",
    recommendation: "Use .get() or verify index is within bounds before indexing."
  },
  {
    id: "SOL2627",
    name: "Iterator Invalidation",
    severity: "high",
    pattern: /for[\s\S]{0,50}in[\s\S]{0,50}\.iter\(\)[\s\S]{0,100}(push|remove|insert)/i,
    description: "Modifying collection while iterating over it.",
    recommendation: "Collect modifications and apply after iteration completes."
  },
  {
    id: "SOL2628",
    name: "Stack Overflow from Deep Recursion",
    severity: "high",
    pattern: /fn\s+\w+[\s\S]{0,100}\1\s*\((?![\s\S]{0,100}depth.*limit)/i,
    description: "Recursive function without depth limit.",
    recommendation: "Add recursion depth limit or convert to iterative approach."
  },
  {
    id: "SOL2629",
    name: "Data Race in Parallel Processing",
    severity: "critical",
    pattern: /(rayon|parallel|thread)[\s\S]{0,100}(mut|write)[\s\S]{0,50}shared(?![\s\S]{0,100}(mutex|lock|atomic))/i,
    description: "Shared mutable state in parallel code without synchronization.",
    recommendation: "Use Mutex, RwLock, or atomic types for shared mutable state."
  },
  {
    id: "SOL2630",
    name: "Integer Cast Overflow in Size Calculation",
    severity: "high",
    pattern: /(size|len|count)[\s\S]{0,30}as\s*(u32|u16|u8)(?![\s\S]{0,50}try_into)/i,
    description: "Casting larger integer to smaller type for size may overflow.",
    recommendation: "Use try_into() for safe casting or verify value fits in target type."
  }
];
var ALL_BATCH_61_PATTERNS = [
  ...ORACLE_ADVANCED_PATTERNS,
  ...REFERRAL_FEE_PATTERNS,
  ...WITHDRAWAL_DEPOSIT_PATTERNS,
  ...ACCESS_CONTROL_ADVANCED_PATTERNS,
  ...MEMORY_SAFETY_PATTERNS
];
function checkBatch61Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of ALL_BATCH_61_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_61_PATTERN_COUNT = ALL_BATCH_61_PATTERNS.length;

// src/patterns/solana-batched-patterns-62.ts
var LENDING_PROTOCOL_PATTERNS = [
  {
    id: "SOL2631",
    name: "Borrow Without Collateral Ratio Check",
    severity: "critical",
    pattern: /borrow[\s\S]{0,100}(amount|value)(?![\s\S]{0,100}(collateral|health|ratio))/i,
    description: "Borrow operation without collateral ratio verification.",
    recommendation: "Always verify collateral ratio before allowing borrows."
  },
  {
    id: "SOL2632",
    name: "Liquidation Threshold Same as Collateral Factor",
    severity: "high",
    pattern: /liquidation_threshold[\s\S]{0,30}==[\s\S]{0,30}collateral_factor/i,
    description: "No buffer between borrow limit and liquidation. Users instantly liquidatable.",
    recommendation: "Set liquidation threshold higher than collateral factor (e.g., 82.5% vs 80%)."
  },
  {
    id: "SOL2633",
    name: "Interest Rate Model Kink Missing",
    severity: "medium",
    pattern: /interest_rate[\s\S]{0,100}(utilization|usage)(?![\s\S]{0,100}kink)/i,
    description: "Linear interest rate model without utilization kink.",
    recommendation: "Use kinked model: low rates until optimal utilization, then steep increase."
  },
  {
    id: "SOL2634",
    name: "Bad Debt Socialization Missing",
    severity: "high",
    pattern: /liquidat[\s\S]{0,100}(shortfall|bad_debt|loss)(?![\s\S]{0,100}(socialize|distribute|reserve))/i,
    description: "No mechanism to handle bad debt from underwater positions.",
    recommendation: "Implement bad debt socialization or insurance fund mechanism."
  },
  {
    id: "SOL2635",
    name: "Reserve Factor Zero",
    severity: "medium",
    pattern: /reserve_factor[\s\S]{0,10}=[\s\S]{0,10}0(?![\s\S]{0,30}\d)/i,
    description: "Zero reserve factor means no protocol revenue or insurance.",
    recommendation: "Set reserve factor > 0 for protocol sustainability and insurance."
  },
  {
    id: "SOL2636",
    name: "Liquidation Close Factor 100%",
    severity: "high",
    pattern: /close_factor[\s\S]{0,10}=[\s\S]{0,10}(100|10000|1\.0)/i,
    description: "Full liquidation allowed. Users lose entire position unfairly.",
    recommendation: "Limit close factor to 50% to allow partial recovery."
  },
  {
    id: "SOL2637",
    name: "Stale Borrow Index",
    severity: "high",
    pattern: /borrow_index[\s\S]{0,50}(get|fetch)(?![\s\S]{0,100}(update|accrue|refresh))/i,
    description: "Using borrow index without accruing interest first.",
    recommendation: "Always accrue interest before using borrow index."
  },
  {
    id: "SOL2638",
    name: "Supply Cap Not Per-Token",
    severity: "medium",
    pattern: /supply_cap[\s\S]{0,30}(global|total)(?![\s\S]{0,100}per_token)/i,
    description: "Global supply cap but no per-token limit. Single token can dominate.",
    recommendation: "Implement per-token supply caps based on liquidity."
  },
  {
    id: "SOL2639",
    name: "Borrow Cap Not Enforced",
    severity: "high",
    pattern: /borrow[\s\S]{0,100}(amount|value)(?![\s\S]{0,100}(cap|limit|max))/i,
    description: "No borrow cap allows unlimited borrowing of scarce assets.",
    recommendation: "Enforce borrow caps based on available liquidity."
  },
  {
    id: "SOL2640",
    name: "Repay More Than Owed",
    severity: "medium",
    pattern: /repay[\s\S]{0,100}amount(?![\s\S]{0,100}(min|cap|owed|debt))/i,
    description: "Repayment amount not capped at debt owed.",
    recommendation: "Cap repayment at outstanding debt to prevent overpayment."
  },
  {
    id: "SOL2641",
    name: "Interest Accrual Timestamp Manipulation",
    severity: "high",
    pattern: /interest[\s\S]{0,50}(accrue|calculate)[\s\S]{0,50}timestamp(?![\s\S]{0,100}slot)/i,
    description: "Interest based on timestamp instead of slot. Slot is harder to manipulate.",
    recommendation: "Use slot-based time for interest calculations when possible."
  },
  {
    id: "SOL2642",
    name: "Collateral Withdraw During Borrow",
    severity: "critical",
    pattern: /withdraw[\s\S]{0,100}collateral(?![\s\S]{0,100}(borrow|debt|health).*check)/i,
    description: "Collateral withdrawal without checking outstanding borrows.",
    recommendation: "Always verify health factor remains safe after collateral withdrawal."
  },
  {
    id: "SOL2643",
    name: "Flash Loan Without Same-Transaction Repay",
    severity: "critical",
    pattern: /flash[\s\S]{0,50}loan[\s\S]{0,100}(?![\s\S]{0,200}(same|within|this).*transaction)/i,
    description: "Flash loan mechanism may not enforce same-transaction repayment.",
    recommendation: "Verify repayment occurs within same transaction using instruction introspection."
  },
  {
    id: "SOL2644",
    name: "Liquidator Bonus From Depositors",
    severity: "high",
    pattern: /liquidat[\s\S]{0,50}(bonus|discount)(?![\s\S]{0,100}(reserve|protocol))/i,
    description: "Liquidation bonus comes from depositors, not protocol.",
    recommendation: "Fund liquidation incentives from reserve to protect depositors."
  },
  {
    id: "SOL2645",
    name: "No Liquidation Protection Period",
    severity: "medium",
    pattern: /liquidat[\s\S]{0,100}(check|trigger)(?![\s\S]{0,100}(grace|delay|protection))/i,
    description: "Users liquidated immediately without chance to add collateral.",
    recommendation: "Consider grace period before liquidation is allowed."
  },
  {
    id: "SOL2646",
    name: "Isolated Asset Not Actually Isolated",
    severity: "high",
    pattern: /isolated[\s\S]{0,50}(asset|collateral)(?![\s\S]{0,100}(only|single|exclusive))/i,
    description: "Isolated collateral mode may still allow cross-collateralization.",
    recommendation: "Verify isolated assets truly cannot cross-collateralize."
  },
  {
    id: "SOL2647",
    name: "E-Mode Configuration Incorrect",
    severity: "high",
    pattern: /e_mode|efficiency_mode[\s\S]{0,100}(ltv|threshold)(?![\s\S]{0,100}validate)/i,
    description: "E-mode parameters not validated for correlated assets.",
    recommendation: "Validate e-mode assets are actually correlated before higher LTV."
  },
  {
    id: "SOL2648",
    name: "Debt Ceiling Per Asset Missing",
    severity: "medium",
    pattern: /debt[\s\S]{0,50}(cap|limit|ceiling)(?![\s\S]{0,100}per_(asset|token))/i,
    description: "Global debt ceiling but no per-asset limits.",
    recommendation: "Set per-asset debt ceilings based on risk assessment."
  },
  {
    id: "SOL2649",
    name: "Oracle Price Bounds Not Set",
    severity: "high",
    pattern: /oracle[\s\S]{0,50}price(?![\s\S]{0,100}(min_price|max_price|bound))/i,
    description: "No minimum/maximum bounds on oracle prices.",
    recommendation: "Set price bounds to prevent extreme oracle failures."
  },
  {
    id: "SOL2650",
    name: "Liquidation Reward Exceeds Debt",
    severity: "high",
    pattern: /liquidat[\s\S]{0,100}(reward|bonus)(?![\s\S]{0,100}(cap|min.*debt))/i,
    description: "Liquidation reward could exceed debt being repaid.",
    recommendation: "Cap liquidation reward at repaid debt plus reasonable bonus."
  }
];
var DEX_AMM_PATTERNS = [
  {
    id: "SOL2651",
    name: "AMM K Value Not Preserved",
    severity: "critical",
    pattern: /(swap|trade)[\s\S]{0,100}(reserve|balance)(?![\s\S]{0,100}(k_value|invariant|constant_product))/i,
    description: "Constant product invariant (k=x*y) not verified after swap.",
    recommendation: "Always verify k value is preserved or increased after swap."
  },
  {
    id: "SOL2652",
    name: "Concentrated Liquidity Out of Range",
    severity: "high",
    pattern: /(clmm|concentrated)[\s\S]{0,100}(liquidity|position)(?![\s\S]{0,100}(range|tick|bound))/i,
    description: "Concentrated liquidity position tick range not validated.",
    recommendation: "Verify position tick range is valid and within pool bounds."
  },
  {
    id: "SOL2653",
    name: "LP Share Inflation on First Deposit",
    severity: "critical",
    pattern: /lp[\s\S]{0,50}(share|token|mint)[\s\S]{0,100}(total.*==.*0|first.*deposit)/i,
    description: "First LP depositor can manipulate share price.",
    recommendation: "Mint initial LP tokens to dead address or use minimum liquidity."
  },
  {
    id: "SOL2654",
    name: "Swap Output Amount Zero",
    severity: "high",
    pattern: /swap[\s\S]{0,100}(output|out|amount_out)(?![\s\S]{0,100}(>|greater|minimum|min))/i,
    description: "Swap may return zero output for dust amounts.",
    recommendation: "Verify output amount is non-zero and meets minimum."
  },
  {
    id: "SOL2655",
    name: "Pool Fee Not Applied Correctly",
    severity: "high",
    pattern: /swap[\s\S]{0,50}(fee|commission)(?![\s\S]{0,100}(before|deduct|subtract).*output)/i,
    description: "Fee deducted from wrong side or at wrong time.",
    recommendation: "Deduct fee from input or add to output consistently."
  },
  {
    id: "SOL2656",
    name: "Virtual Reserves Manipulation",
    severity: "high",
    pattern: /virtual[\s\S]{0,30}(reserve|balance)(?![\s\S]{0,100}(bound|limit|verify))/i,
    description: "Virtual reserves can be manipulated to affect pricing.",
    recommendation: "Bound virtual reserves and verify consistency with real reserves."
  },
  {
    id: "SOL2657",
    name: "Price Impact Calculation Missing",
    severity: "high",
    pattern: /(swap|trade)[\s\S]{0,100}(execute|process)(?![\s\S]{0,100}price_impact)/i,
    description: "Trade executed without calculating or limiting price impact.",
    recommendation: "Calculate price impact and reject trades exceeding threshold."
  },
  {
    id: "SOL2658",
    name: "Tick Spacing Validation Missing",
    severity: "medium",
    pattern: /tick[\s\S]{0,30}(lower|upper|index)(?![\s\S]{0,100}(spacing|modulo|divisible))/i,
    description: "Tick values not validated against tick spacing.",
    recommendation: "Verify ticks are divisible by tick spacing."
  },
  {
    id: "SOL2659",
    name: "Sqrt Price X96 Overflow",
    severity: "high",
    pattern: /sqrt[\s\S]{0,30}price[\s\S]{0,30}(x96|q64)(?![\s\S]{0,100}(bound|overflow|check))/i,
    description: "Fixed-point sqrt price calculations may overflow.",
    recommendation: "Use checked math for sqrt price calculations."
  },
  {
    id: "SOL2660",
    name: "Liquidity Delta Sign Confusion",
    severity: "high",
    pattern: /liquidity[\s\S]{0,30}delta[\s\S]{0,30}(i128|signed)(?![\s\S]{0,100}(positive|negative|check))/i,
    description: "Signed liquidity delta may be confused (add vs remove).",
    recommendation: "Explicitly handle positive (add) and negative (remove) delta."
  },
  {
    id: "SOL2661",
    name: "Pool Creation Without Fee Tier",
    severity: "medium",
    pattern: /pool[\s\S]{0,50}(create|init)(?![\s\S]{0,100}fee_(tier|rate|bps))/i,
    description: "Pool created without specifying fee tier.",
    recommendation: "Require explicit fee tier selection on pool creation."
  },
  {
    id: "SOL2662",
    name: "Swap Route Validation Missing",
    severity: "high",
    pattern: /(route|path|hop)[\s\S]{0,50}(execute|swap)(?![\s\S]{0,100}(validate|verify|check))/i,
    description: "Multi-hop swap route not validated for consistency.",
    recommendation: "Validate each hop in route and verify final token matches expected."
  },
  {
    id: "SOL2663",
    name: "Protocol Fee Receiver Mutable",
    severity: "medium",
    pattern: /protocol_fee[\s\S]{0,50}(receiver|recipient)[\s\S]{0,30}mut/i,
    description: "Protocol fee receiver can be changed by admin.",
    recommendation: "Use timelock for fee receiver changes or make immutable."
  },
  {
    id: "SOL2664",
    name: "Flash Swap Callback Reentrancy",
    severity: "critical",
    pattern: /flash[\s\S]{0,50}swap[\s\S]{0,100}callback(?![\s\S]{0,100}(guard|lock|reentr))/i,
    description: "Flash swap callback may enable reentrancy.",
    recommendation: "Add reentrancy guard around flash swap operations."
  },
  {
    id: "SOL2665",
    name: "Observation Array Not Updated",
    severity: "medium",
    pattern: /observation[\s\S]{0,50}(array|buffer)(?![\s\S]{0,100}(update|write|grow))/i,
    description: "TWAP observation array not updated on trades.",
    recommendation: "Update observation array on every swap for accurate TWAP."
  },
  {
    id: "SOL2666",
    name: "Position NFT Transfer Unchecked",
    severity: "high",
    pattern: /position[\s\S]{0,50}(nft|token)[\s\S]{0,50}transfer(?![\s\S]{0,100}(authority|owner).*check)/i,
    description: "Position NFT transfer without ownership verification.",
    recommendation: "Verify caller owns position NFT before allowing operations."
  },
  {
    id: "SOL2667",
    name: "Pool Paused But Withdrawals Blocked",
    severity: "high",
    pattern: /pool[\s\S]{0,30}paused(?![\s\S]{0,200}withdraw.*allow)/i,
    description: "Paused pool blocks all operations including user fund withdrawal.",
    recommendation: "Always allow withdrawals even when pool is paused."
  },
  {
    id: "SOL2668",
    name: "Zero Liquidity Check Missing",
    severity: "high",
    pattern: /swap[\s\S]{0,100}(execute|process)(?![\s\S]{0,100}liquidity.*>.*0)/i,
    description: "Swap attempted on pool with zero liquidity.",
    recommendation: "Verify pool has liquidity before executing swaps."
  },
  {
    id: "SOL2669",
    name: "Reward Token Drain via Collect",
    severity: "high",
    pattern: /collect[\s\S]{0,50}(reward|fee)(?![\s\S]{0,100}(owner|position).*check)/i,
    description: "Anyone can collect rewards not belonging to them.",
    recommendation: "Verify caller owns the position before collecting rewards."
  },
  {
    id: "SOL2670",
    name: "Emergency Withdraw Forfeits Rewards",
    severity: "medium",
    pattern: /emergency[\s\S]{0,30}withdraw(?![\s\S]{0,100}(reward|fee).*collect)/i,
    description: "Emergency withdrawal loses accrued rewards.",
    recommendation: "Collect rewards before emergency withdrawal or return them."
  }
];
var STAKING_VALIDATOR_PATTERNS = [
  {
    id: "SOL2671",
    name: "Stake Pool Commission Unlimited",
    severity: "high",
    pattern: /commission[\s\S]{0,30}(fee|rate|percent)(?![\s\S]{0,100}(max|cap|limit))/i,
    description: "Stake pool commission can be set to 100%.",
    recommendation: "Cap commission at reasonable maximum (e.g., 10%)."
  },
  {
    id: "SOL2672",
    name: "Validator Set Not Verified",
    severity: "high",
    pattern: /validator[\s\S]{0,50}(vote|identity)(?![\s\S]{0,100}(verify|whitelist|approved))/i,
    description: "Delegating to validators without verification.",
    recommendation: "Maintain approved validator list or verify vote account."
  },
  {
    id: "SOL2673",
    name: "Unstake Without Cooldown",
    severity: "medium",
    pattern: /unstake[\s\S]{0,100}(execute|process)(?![\s\S]{0,100}(cooldown|delay|epoch))/i,
    description: "Instant unstake without cooldown period.",
    recommendation: "Enforce unstaking cooldown aligned with Solana epochs."
  },
  {
    id: "SOL2674",
    name: "Stake Pool Reserve Insufficient",
    severity: "high",
    pattern: /stake[\s\S]{0,30}pool[\s\S]{0,50}reserve(?![\s\S]{0,100}minimum)/i,
    description: "Stake pool reserve for instant withdrawals may be insufficient.",
    recommendation: "Maintain minimum reserve ratio for withdrawal liquidity."
  },
  {
    id: "SOL2675",
    name: "Validator Commission Change Instant",
    severity: "medium",
    pattern: /validator[\s\S]{0,50}commission[\s\S]{0,30}(set|update)(?![\s\S]{0,100}(delay|notice|timelock))/i,
    description: "Validator can instantly increase commission.",
    recommendation: "Require advance notice for commission increases."
  },
  {
    id: "SOL2676",
    name: "Slashing Not Handled",
    severity: "critical",
    pattern: /stake[\s\S]{0,100}(reward|yield)(?![\s\S]{0,200}(slash|penalty|loss))/i,
    description: "Staking protocol does not handle validator slashing.",
    recommendation: "Implement slashing detection and loss distribution."
  },
  {
    id: "SOL2677",
    name: "Reward Distribution Not Pro-Rata",
    severity: "high",
    pattern: /reward[\s\S]{0,50}distribut(?![\s\S]{0,100}(pro_rata|proportion|share))/i,
    description: "Rewards not distributed proportionally to stake.",
    recommendation: "Distribute rewards proportional to stake share."
  },
  {
    id: "SOL2678",
    name: "Stake Account Not Delegated",
    severity: "medium",
    pattern: /stake[\s\S]{0,30}account[\s\S]{0,50}(create|init)(?![\s\S]{0,100}delegat)/i,
    description: "Stake account created but not delegated to validator.",
    recommendation: "Delegate stake accounts to earn rewards."
  },
  {
    id: "SOL2679",
    name: "Epoch Boundary Reward Timing",
    severity: "medium",
    pattern: /epoch[\s\S]{0,50}(reward|yield|return)(?![\s\S]{0,100}(boundary|transition|change))/i,
    description: "Reward calculation may miss epoch boundary edge cases.",
    recommendation: "Handle epoch transitions explicitly in reward calculations."
  },
  {
    id: "SOL2680",
    name: "Delegation Strategy Manipulation",
    severity: "high",
    pattern: /delegat[\s\S]{0,50}(strategy|allocation)(?![\s\S]{0,100}(validate|verify|bound))/i,
    description: "Delegation strategy can concentrate stake on few validators.",
    recommendation: "Enforce diversification limits in delegation strategy."
  },
  {
    id: "SOL2681",
    name: "Liquid Stake Token Depeg",
    severity: "high",
    pattern: /(lst|liquid_stake)[\s\S]{0,50}(token|mint)(?![\s\S]{0,100}(backing|reserve|peg))/i,
    description: "Liquid staking token may depeg from underlying SOL.",
    recommendation: "Ensure LST is always backed by >= equivalent staked SOL."
  },
  {
    id: "SOL2682",
    name: "Stake Account Authority Not Transferred",
    severity: "high",
    pattern: /stake[\s\S]{0,30}account[\s\S]{0,50}(authority|withdraw)(?![\s\S]{0,100}(transfer|assign|pool))/i,
    description: "Stake account authority not transferred to pool.",
    recommendation: "Transfer stake authority to pool PDA for proper management."
  },
  {
    id: "SOL2683",
    name: "Validator Vote Account Mismatch",
    severity: "high",
    pattern: /validator[\s\S]{0,50}(pubkey|address)[\s\S]{0,50}vote(?![\s\S]{0,100}(match|verify|check))/i,
    description: "Validator identity not verified against vote account.",
    recommendation: "Verify validator identity matches vote account."
  },
  {
    id: "SOL2684",
    name: "Stake Pool SOL Counting Error",
    severity: "high",
    pattern: /total[\s\S]{0,30}(sol|lamports)[\s\S]{0,50}(count|sum)(?![\s\S]{0,100}(all|every|stake.*reserve))/i,
    description: "Total SOL calculation may miss some accounts.",
    recommendation: "Include all SOL: staked + reserve + rent-exempt."
  },
  {
    id: "SOL2685",
    name: "Stake Pool Fee Update Without Notice",
    severity: "medium",
    pattern: /pool[\s\S]{0,30}fee[\s\S]{0,30}(update|change)(?![\s\S]{0,100}(notice|delay|timelock))/i,
    description: "Pool fees can change instantly without user notice.",
    recommendation: "Require advance notice for fee increases."
  }
];
var TOKEN_SECURITY_PATTERNS = [
  {
    id: "SOL2686",
    name: "Mint Authority Not Revoked",
    severity: "high",
    pattern: /mint[\s\S]{0,30}authority(?![\s\S]{0,100}(none|revoke|null|zero))/i,
    description: "Token mint authority still active, enabling unlimited minting.",
    recommendation: "Revoke mint authority for fixed-supply tokens."
  },
  {
    id: "SOL2687",
    name: "Freeze Authority Centralized",
    severity: "medium",
    pattern: /freeze[\s\S]{0,30}authority(?![\s\S]{0,100}(multisig|none|revoke))/i,
    description: "Single entity can freeze any token account.",
    recommendation: "Use multisig for freeze authority or revoke if not needed."
  },
  {
    id: "SOL2688",
    name: "Token Extension Incompatibility",
    severity: "high",
    pattern: /token_2022[\s\S]{0,100}extension(?![\s\S]{0,100}(compat|support|check))/i,
    description: "Token-2022 extensions may conflict with protocol logic.",
    recommendation: "Test protocol with all relevant token extensions."
  },
  {
    id: "SOL2689",
    name: "Transfer Hook Reentrancy",
    severity: "critical",
    pattern: /transfer_hook[\s\S]{0,100}(invoke|call)(?![\s\S]{0,100}(guard|lock))/i,
    description: "Transfer hook may enable reentrancy attacks.",
    recommendation: "Add reentrancy protection around transfer hooks."
  },
  {
    id: "SOL2690",
    name: "Confidential Transfer Leak",
    severity: "high",
    pattern: /confidential[\s\S]{0,50}transfer(?![\s\S]{0,100}(audit|verify|proof))/i,
    description: "Confidential transfer amounts may leak through other means.",
    recommendation: "Ensure all related operations maintain confidentiality."
  },
  {
    id: "SOL2691",
    name: "Permanent Delegate Abuse",
    severity: "critical",
    pattern: /permanent[\s\S]{0,30}delegate(?![\s\S]{0,100}(warn|consent|aware))/i,
    description: "Permanent delegate can drain tokens without user consent.",
    recommendation: "Warn users about permanent delegate, require explicit consent."
  },
  {
    id: "SOL2692",
    name: "Interest-Bearing Token Accrual",
    severity: "high",
    pattern: /interest[\s\S]{0,30}bearing[\s\S]{0,50}(token|mint)(?![\s\S]{0,100}(rate|accrue).*check)/i,
    description: "Interest-bearing token rate may be manipulated.",
    recommendation: "Validate interest rate is within acceptable bounds."
  },
  {
    id: "SOL2693",
    name: "Non-Transferable Token Override",
    severity: "high",
    pattern: /non_transferable(?![\s\S]{0,100}(enforce|block|prevent))/i,
    description: "Non-transferable token constraint may be bypassed.",
    recommendation: "Verify transfer is actually blocked in all code paths."
  },
  {
    id: "SOL2694",
    name: "Memo Required Not Checked",
    severity: "low",
    pattern: /memo[\s\S]{0,30}required(?![\s\S]{0,100}(check|verify|enforce))/i,
    description: "Memo requirement declared but not enforced.",
    recommendation: "Actually check memo presence when required."
  },
  {
    id: "SOL2695",
    name: "Default Account State Unexpected",
    severity: "medium",
    pattern: /default[\s\S]{0,30}account[\s\S]{0,30}state(?![\s\S]{0,100}(expect|handle|check))/i,
    description: "Token-2022 default account state may differ from expected.",
    recommendation: "Handle both frozen and initialized default states."
  },
  {
    id: "SOL2696",
    name: "Reallocate Without Size Check",
    severity: "high",
    pattern: /reallocat[\s\S]{0,50}(account|space)(?![\s\S]{0,100}(max|limit|bound))/i,
    description: "Account reallocation without size limit.",
    recommendation: "Limit reallocation size to prevent compute exhaustion."
  },
  {
    id: "SOL2697",
    name: "CPI Guard State Ignored",
    severity: "high",
    pattern: /cpi_guard[\s\S]{0,50}(state|enabled)(?![\s\S]{0,100}check)/i,
    description: "CPI guard state not checked before CPI operation.",
    recommendation: "Check CPI guard state and fail if enabled when not expected."
  },
  {
    id: "SOL2698",
    name: "Metadata Authority Mismatch",
    severity: "high",
    pattern: /metadata[\s\S]{0,50}authority(?![\s\S]{0,100}(verify|check|match))/i,
    description: "Token metadata authority not verified against expected.",
    recommendation: "Verify metadata authority matches expected before trusting data."
  },
  {
    id: "SOL2699",
    name: "Token Burn Not Reducing Supply",
    severity: "high",
    pattern: /burn[\s\S]{0,100}(token|amount)(?![\s\S]{0,100}(supply.*decrement|total.*sub))/i,
    description: "Token burn operation may not reduce total supply.",
    recommendation: "Verify total supply decreases after burn."
  },
  {
    id: "SOL2700",
    name: "Decimal Mismatch in Token Math",
    severity: "high",
    pattern: /(token_a|token_b)[\s\S]{0,50}(amount|value)[\s\S]{0,50}(add|sub|mul|div)(?![\s\S]{0,100}decimal)/i,
    description: "Token arithmetic without considering different decimals.",
    recommendation: "Normalize token amounts to same decimal scale before math."
  }
];
var ALL_BATCH_62_PATTERNS = [
  ...LENDING_PROTOCOL_PATTERNS,
  ...DEX_AMM_PATTERNS,
  ...STAKING_VALIDATOR_PATTERNS,
  ...TOKEN_SECURITY_PATTERNS
];
function checkBatch62Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of ALL_BATCH_62_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_62_PATTERN_COUNT = ALL_BATCH_62_PATTERNS.length;

// src/patterns/solana-batched-patterns-63.ts
var RATEX_VALUATION_PATTERNS = [
  {
    id: "SOL2701",
    name: "PT Token Valuation Without Maturity Check",
    severity: "critical",
    pattern: /pt[\s_]?token[\s\S]{0,100}(value|price|worth)(?![\s\S]{0,100}maturity)/i,
    description: "Principal Token (PT) valuation without maturity consideration. Loopscale lost $5.8M from this.",
    recommendation: "PT tokens must be valued based on time-to-maturity and underlying redemption value."
  },
  {
    id: "SOL2702",
    name: "Yield Token Redemption Without Rate Validation",
    severity: "high",
    pattern: /yt[\s_]?token[\s\S]{0,100}redeem(?![\s\S]{0,100}(rate|yield|check))/i,
    description: "Yield Token redemption without validating underlying yield rate.",
    recommendation: "Validate yield rate from trusted oracle before allowing redemptions."
  },
  {
    id: "SOL2703",
    name: "Fixed Rate Protocol Manipulation",
    severity: "critical",
    pattern: /fixed[\s_]?rate[\s\S]{0,50}(set|update|change)(?![\s\S]{0,100}(authority|admin|owner))/i,
    description: "Fixed rate can be changed without authority check.",
    recommendation: "Only authorized accounts should modify fixed rates with timelock."
  },
  {
    id: "SOL2704",
    name: "Tokenized Asset Circular Collateral",
    severity: "critical",
    pattern: /(deposit|collateral)[\s\S]{0,50}(pt|yt|synthetic)[\s\S]{0,100}(borrow|mint)/i,
    description: "Circular collateral: synthetic/tokenized asset used as collateral for itself.",
    recommendation: "Prevent using derivative tokens as collateral for their underlying."
  },
  {
    id: "SOL2705",
    name: "Principal Token Redemption Before Maturity",
    severity: "high",
    pattern: /pt[\s_]?(token)?[\s\S]{0,50}redeem(?![\s\S]{0,100}(maturity|timestamp|clock))/i,
    description: "PT redemption without maturity date check allows early redemption exploit.",
    recommendation: "Check Clock::get() timestamp against maturity before allowing redemption."
  },
  {
    id: "SOL2706",
    name: "Yield Stripping Without Balance Verification",
    severity: "high",
    pattern: /strip[\s_]?yield[\s\S]{0,100}transfer(?![\s\S]{0,100}balance)/i,
    description: "Yield stripping without verifying sufficient underlying balance.",
    recommendation: "Verify underlying token balance before stripping yield."
  },
  {
    id: "SOL2707",
    name: "Tokenized Position Value Cache Stale",
    severity: "high",
    pattern: /position[\s_]?value[\s\S]{0,30}cache(?![\s\S]{0,100}(refresh|update|recalculate))/i,
    description: "Cached position values can become stale and exploitable.",
    recommendation: "Recalculate position values on each use or use staleness check."
  },
  {
    id: "SOL2708",
    name: "Synthetic Token Backing Ratio Unchecked",
    severity: "critical",
    pattern: /synthetic[\s\S]{0,50}(mint|create)(?![\s\S]{0,100}(backing|collateral|ratio))/i,
    description: "Synthetic token minting without verifying backing ratio.",
    recommendation: "Enforce minimum backing ratio before minting synthetic tokens."
  }
];
var DEXX_KEY_EXPOSURE_PATTERNS = [
  {
    id: "SOL2721",
    name: "Private Key in Request Body",
    severity: "critical",
    pattern: /(post|put|send)[\s\S]{0,100}(private[\s_]?key|secret[\s_]?key|keypair)/i,
    description: "Private key transmitted over network. DEXX lost $30M from key leakage.",
    recommendation: "Never transmit private keys. Use client-side signing only."
  },
  {
    id: "SOL2722",
    name: "Centralized Key Storage",
    severity: "critical",
    pattern: /(database|db|storage)[\s\S]{0,50}(private[\s_]?key|secret|seed)/i,
    description: "Private keys stored in centralized database - single point of failure.",
    recommendation: "Use HSM, MPC, or client-side key management. Never store user keys."
  },
  {
    id: "SOL2723",
    name: "Seed Phrase in Logs",
    severity: "critical",
    pattern: /(log|print|debug|console)[\s\S]{0,50}(seed|mnemonic|phrase)/i,
    description: "Seed phrases logged. Slope Wallet exploit exposed $8M through logging.",
    recommendation: "Never log any key material. Implement secure logging policies."
  },
  {
    id: "SOL2724",
    name: "Key Material in Error Messages",
    severity: "critical",
    pattern: /(error|err|exception)[\s\S]{0,50}(key|secret|seed|private)/i,
    description: "Key material exposed in error messages.",
    recommendation: "Sanitize error messages to exclude any sensitive data."
  },
  {
    id: "SOL2725",
    name: "Unencrypted Key in Memory",
    severity: "high",
    pattern: /String[\s\S]{0,20}(private_key|secret_key|seed_phrase)/i,
    description: "Keys stored as regular strings remain in memory longer.",
    recommendation: "Use secure memory types like Zeroizing<> that clear on drop."
  },
  {
    id: "SOL2726",
    name: "Trading Bot Custodial Keys",
    severity: "critical",
    pattern: /bot[\s\S]{0,50}(custody|hold|store)[\s\S]{0,50}key/i,
    description: "Trading bot holds user keys. Solareum lost $1.4M from insider theft.",
    recommendation: "Use non-custodial design with delegated authority instead."
  },
  {
    id: "SOL2727",
    name: "Third-Party Service Key Access",
    severity: "high",
    pattern: /(mongo|redis|postgres|external)[\s\S]{0,50}(key|secret|credential)/i,
    description: "Keys accessible to third-party services. Thunder Terminal lost $240K via MongoDB.",
    recommendation: "Isolate key management from all third-party integrations."
  }
];
var INSIDER_THREAT_PATTERNS = [
  {
    id: "SOL2741",
    name: "Single Admin Key No Multisig",
    severity: "critical",
    pattern: /admin[\s\S]{0,30}(authority|key|signer)(?![\s\S]{0,100}multisig)/i,
    description: "Single admin key without multisig. Insider can drain protocol.",
    recommendation: "Require multisig (e.g., 3/5) for all admin operations."
  },
  {
    id: "SOL2742",
    name: "Employee Access to Production Keys",
    severity: "critical",
    pattern: /(employee|dev|team)[\s\S]{0,50}(access|key|authority)/i,
    description: "Employee access to production signing keys. Pump.fun lost $1.9M.",
    recommendation: "Use hardware wallets and segregated duties for production keys."
  },
  {
    id: "SOL2743",
    name: "DAO 1-of-N Multisig",
    severity: "critical",
    pattern: /multisig[\s\S]{0,30}(1[\s_]?of|1\/)/i,
    description: "1-of-N multisig provides no security. Saga DAO lost $60K.",
    recommendation: "Require at least 2/3 or 3/5 threshold for treasury multisig."
  },
  {
    id: "SOL2744",
    name: "Withdrawal Authority No Timelock",
    severity: "high",
    pattern: /withdraw[\s\S]{0,50}authority(?![\s\S]{0,100}timelock)/i,
    description: "Withdrawal authority without timelock. Instant rug possible.",
    recommendation: "Add 24-48 hour timelock on large withdrawals."
  },
  {
    id: "SOL2745",
    name: "Treasury Access No Event Emission",
    severity: "medium",
    pattern: /treasury[\s\S]{0,50}(transfer|withdraw)(?![\s\S]{0,100}(emit|event|log))/i,
    description: "Treasury operations without event emission. Hard to detect theft.",
    recommendation: "Emit events for all treasury movements for monitoring."
  },
  {
    id: "SOL2746",
    name: "Team Token Unlock No Vesting",
    severity: "high",
    pattern: /team[\s_]?token[\s\S]{0,50}(unlock|release)(?![\s\S]{0,100}vest)/i,
    description: "Team tokens unlockable without vesting schedule.",
    recommendation: "Implement proper vesting with cliff and linear release."
  },
  {
    id: "SOL2747",
    name: "Upgrade Authority Single Key",
    severity: "critical",
    pattern: /upgrade[\s_]?authority[\s\S]{0,30}(pubkey|key)(?![\s\S]{0,100}multisig)/i,
    description: "Program upgrade controlled by single key. Full protocol takeover risk.",
    recommendation: "Transfer upgrade authority to multisig or make immutable."
  }
];
var GOVERNANCE_ATTACK_PATTERNS = [
  {
    id: "SOL2761",
    name: "Governance Proposal No Delay",
    severity: "critical",
    pattern: /proposal[\s\S]{0,50}execute(?![\s\S]{0,100}(delay|timelock|wait))/i,
    description: "Proposals execute immediately. Audius lost $6.1M to instant execution.",
    recommendation: "Add 24-72 hour delay between approval and execution."
  },
  {
    id: "SOL2762",
    name: "Low Quorum for Critical Actions",
    severity: "high",
    pattern: /quorum[\s\S]{0,20}(1|5|10)[\s_]?%/i,
    description: "Very low quorum allows attackers to pass proposals unnoticed.",
    recommendation: "Set quorum to at least 10-20% of circulating supply."
  },
  {
    id: "SOL2763",
    name: "Proposal Voting During Creation",
    severity: "high",
    pattern: /proposal[\s\S]{0,30}(create|new)[\s\S]{0,50}vote/i,
    description: "Same transaction creates and votes on proposal. No community review.",
    recommendation: "Separate proposal creation and voting period by at least 24 hours."
  },
  {
    id: "SOL2764",
    name: "Token-Weighted Voting Flash Loan Vulnerable",
    severity: "critical",
    pattern: /voting[\s_]?power[\s\S]{0,30}(balance|amount)(?![\s\S]{0,100}snapshot)/i,
    description: "Voting power from current balance. Attackable via flash loan.",
    recommendation: "Use snapshot-based voting power from past block."
  },
  {
    id: "SOL2765",
    name: "Inactive DAO No Notification",
    severity: "high",
    pattern: /dao[\s\S]{0,50}proposal(?![\s\S]{0,100}(notify|alert|event))/i,
    description: "No notifications for proposals in inactive DAO. Synthetify lost $230K.",
    recommendation: "Implement proposal alerts and require active monitoring."
  },
  {
    id: "SOL2766",
    name: "Governance Bypass via Direct Call",
    severity: "critical",
    pattern: /(admin|treasury)[\s\S]{0,30}(pub|public)[\s\S]{0,30}fn(?![\s\S]{0,100}governance)/i,
    description: "Critical functions callable directly, bypassing governance.",
    recommendation: "Gate all admin functions through governance proposal execution."
  },
  {
    id: "SOL2767",
    name: "No Veto Council",
    severity: "medium",
    pattern: /governance[\s\S]{0,100}(?!veto|guardian|emergency)/i,
    description: "No veto mechanism for malicious proposals.",
    recommendation: "Add guardian/veto council for emergency proposal rejection."
  },
  {
    id: "SOL2768",
    name: "Proposal Data Not Validated",
    severity: "critical",
    pattern: /proposal[\s\S]{0,30}data[\s\S]{0,50}execute(?![\s\S]{0,100}(validate|verify|check))/i,
    description: "Proposal instruction data executed without validation.",
    recommendation: "Validate proposal instructions against allowed operations."
  }
];
var ADVANCED_DEFI_PATTERNS = [
  {
    id: "SOL2781",
    name: "Bonding Curve Flash Loan Exploitable",
    severity: "critical",
    pattern: /bonding[\s_]?curve[\s\S]{0,100}(buy|sell|swap)(?![\s\S]{0,100}(block|lock|delay))/i,
    description: "Bonding curve exploitable via flash loan. Nirvana lost $3.5M.",
    recommendation: "Add per-block limits or time delays on large curve operations."
  },
  {
    id: "SOL2782",
    name: "AMM Constant Product Unprotected",
    severity: "high",
    pattern: /x[\s]*\*[\s]*y[\s]*=[\s]*k(?![\s\S]{0,100}(slippage|check|guard))/i,
    description: "Constant product formula without slippage protection.",
    recommendation: "Enforce minimum output amounts for all swaps."
  },
  {
    id: "SOL2783",
    name: "Liquidity Mining Infinite Emission",
    severity: "high",
    pattern: /emission[\s_]?(rate|per)(?![\s\S]{0,100}(cap|max|limit|halving))/i,
    description: "Uncapped token emissions dilute value indefinitely.",
    recommendation: "Implement emission caps, halvings, or decay schedules."
  },
  {
    id: "SOL2784",
    name: "Staking Rewards Calculator Overflow",
    severity: "high",
    pattern: /reward[\s\S]{0,30}(accumulated|total)[\s\S]{0,30}\*/i,
    description: "Reward calculation multiplication without overflow check.",
    recommendation: "Use checked_mul for all reward calculations."
  },
  {
    id: "SOL2785",
    name: "Bridge Guardian Set Too Small",
    severity: "critical",
    pattern: /guardian[\s\S]{0,30}(count|len|size)[\s\S]{0,10}(3|4|5)(?![\s_]?of)/i,
    description: "Small guardian set easier to compromise. Wormhole had 19.",
    recommendation: "Use at least 13 guardians with 2/3 threshold."
  },
  {
    id: "SOL2786",
    name: "Cross-Chain Message Replay",
    severity: "critical",
    pattern: /message[\s\S]{0,30}(verify|validate)(?![\s\S]{0,100}(nonce|sequence|used))/i,
    description: "Cross-chain messages without replay protection.",
    recommendation: "Track processed message nonces to prevent replay."
  },
  {
    id: "SOL2787",
    name: "Liquidation No Dust Protection",
    severity: "medium",
    pattern: /liquidat[\s\S]{0,50}(amount|value)(?![\s\S]{0,100}(min|dust|threshold))/i,
    description: "Dust amounts can be liquidated profitably via gas subsidies.",
    recommendation: "Set minimum liquidation amount above dust threshold."
  },
  {
    id: "SOL2788",
    name: "Vault Deposit No Slippage",
    severity: "high",
    pattern: /vault[\s\S]{0,30}deposit(?![\s\S]{0,100}(min|slippage|expected))/i,
    description: "Vault deposits without minimum shares protection.",
    recommendation: "Require minimum shares parameter for sandwich protection."
  },
  {
    id: "SOL2789",
    name: "Oracle TWAP Period Too Short",
    severity: "high",
    pattern: /twap[\s\S]{0,30}(period|window)[\s\S]{0,10}(1|5|10)[\s_]?(min|minute)/i,
    description: "TWAP period under 15 min is manipulatable.",
    recommendation: "Use TWAP period of at least 15-30 minutes."
  },
  {
    id: "SOL2790",
    name: "LP Token Calculation Before Fee",
    severity: "high",
    pattern: /lp[\s_]?(token|share)[\s\S]{0,50}(amount|calc)[\s\S]{0,50}fee/i,
    description: "LP shares calculated before fee deduction. Fee avoidance possible.",
    recommendation: "Calculate LP shares after deducting all fees."
  },
  {
    id: "SOL2791",
    name: "Yield Aggregator Strategy No Validation",
    severity: "critical",
    pattern: /strategy[\s\S]{0,30}(add|register)(?![\s\S]{0,100}(validate|whitelist|verify))/i,
    description: "Strategies can be added without validation. Tulip-style risk.",
    recommendation: "Whitelist and audit all strategies before deployment."
  },
  {
    id: "SOL2792",
    name: "Perpetual Funding Rate Manipulation",
    severity: "high",
    pattern: /funding[\s_]?rate[\s\S]{0,50}(calc|compute)(?![\s\S]{0,100}(cap|clamp|limit))/i,
    description: "Uncapped funding rates can drain positions.",
    recommendation: "Cap funding rates at reasonable bounds (e.g., \xB10.1% per hour)."
  },
  {
    id: "SOL2793",
    name: "Insurance Fund Drain No Limit",
    severity: "high",
    pattern: /insurance[\s_]?fund[\s\S]{0,50}(use|withdraw|drain)(?![\s\S]{0,100}(limit|cap|max))/i,
    description: "Insurance fund can be fully drained in single event.",
    recommendation: "Limit insurance fund usage per event to preserve solvency."
  },
  {
    id: "SOL2794",
    name: "Leverage Without Margin Call",
    severity: "critical",
    pattern: /leverage[\s\S]{0,50}(position|trade)(?![\s\S]{0,100}(margin|liquidat|health))/i,
    description: "Leveraged positions without margin call mechanism.",
    recommendation: "Implement continuous margin monitoring and liquidation."
  },
  {
    id: "SOL2795",
    name: "Stablecoin Depeg No Emergency",
    severity: "critical",
    pattern: /stable[\s_]?coin[\s\S]{0,100}(?!(emergency|depeg|circuit|pause))/i,
    description: "No emergency mechanism for depeg scenario. Cashio collapsed.",
    recommendation: "Implement circuit breakers and emergency redemption at par."
  }
];
function checkBatch63Patterns(input) {
  const findings = [];
  if (!input.rust?.content) {
    return findings;
  }
  const content = input.rust.content;
  const lines = content.split("\n");
  const allPatterns = [
    ...RATEX_VALUATION_PATTERNS,
    ...DEXX_KEY_EXPOSURE_PATTERNS,
    ...INSIDER_THREAT_PATTERNS,
    ...GOVERNANCE_ATTACK_PATTERNS,
    ...ADVANCED_DEFI_PATTERNS
  ];
  for (const pattern of allPatterns) {
    const match = pattern.pattern.exec(content);
    if (match) {
      const lineNumber = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: pattern.id,
        title: pattern.name,
        severity: pattern.severity,
        description: pattern.description,
        location: { file: input.path, line: lineNumber },
        recommendation: pattern.recommendation
      });
    }
  }
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const context = lines.slice(Math.max(0, i - 10), Math.min(lines.length, i + 10)).join("\n");
    if ((line.includes("Clock::get") || line.includes("unix_timestamp")) && (context.includes("random") || context.includes("lottery") || context.includes("raffle"))) {
      findings.push({
        id: "SOL2796",
        title: "Timestamp Used for Randomness",
        severity: "critical",
        description: "Timestamps are predictable and manipulatable. Not suitable for randomness.",
        location: { file: input.path, line: i + 1 },
        recommendation: "Use VRF (Switchboard/Chainlink) for on-chain randomness."
      });
    }
    if (line.includes("/") && !line.includes("//") && !line.includes("/*") && !context.includes("checked_div") && !context.includes("!= 0") && !context.includes("> 0") && context.includes("fn ")) {
      if (line.match(/\w+\s*\/\s*\w+/)) {
        findings.push({
          id: "SOL2797",
          title: "Potential Division by Zero",
          severity: "high",
          description: "Division without checking divisor is non-zero.",
          location: { file: input.path, line: i + 1 },
          recommendation: "Use checked_div or verify divisor > 0 before division."
        });
      }
    }
    if (line.match(/\b\d{7,}\b/) && !line.includes("_")) {
      findings.push({
        id: "SOL2798",
        title: "Large Number Without Underscore Separator",
        severity: "low",
        description: "Large numbers without underscores are error-prone (e.g., 1000000 vs 100000).",
        location: { file: input.path, line: i + 1 },
        recommendation: "Use underscores: 1_000_000 instead of 1000000."
      });
    }
    if ((line.includes("invoke") || line.includes("invoke_signed") || line.includes("CpiContext")) && context.includes("for ") && context.includes("in ")) {
      findings.push({
        id: "SOL2799",
        title: "CPI Call Inside Loop",
        severity: "high",
        description: "External program calls in loops are expensive and may hit compute limits.",
        location: { file: input.path, line: i + 1 },
        recommendation: "Batch operations or limit loop iterations with compute budget."
      });
    }
    if ((line.includes("close") || line.includes("Close")) && line.includes("account") && !context.includes("lamport")) {
      findings.push({
        id: "SOL2800",
        title: "Account Close Without Final Lamport Check",
        severity: "medium",
        description: "Closing accounts should verify final lamport balance transfer.",
        location: { file: input.path, line: i + 1 },
        recommendation: "Verify lamports transferred to destination equals account balance."
      });
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-64.ts
var SUPPLY_CHAIN_PATTERNS = [
  {
    id: "SOL2801",
    name: "NPM Package Exact Version Not Pinned",
    severity: "high",
    pattern: /"@solana\/web3\.js"\s*:\s*"\^/i,
    description: "Using caret version allows auto-update to compromised versions. Web3.js 1.95.5-1.95.7 were malicious.",
    recommendation: 'Pin exact versions: "@solana/web3.js": "1.95.4" (no caret).'
  },
  {
    id: "SOL2802",
    name: "Package Lock File Missing",
    severity: "high",
    pattern: /npm\s+install(?![\s\S]{0,50}--package-lock)/i,
    description: "Installing without lockfile can pull malicious versions.",
    recommendation: "Always commit package-lock.json and use npm ci in CI/CD."
  },
  {
    id: "SOL2803",
    name: "Postinstall Script Not Reviewed",
    severity: "medium",
    pattern: /"postinstall"\s*:\s*"/i,
    description: "Postinstall scripts can execute malicious code during install.",
    recommendation: "Review all postinstall scripts. Use --ignore-scripts if needed."
  },
  {
    id: "SOL2804",
    name: "Environment Variable Key Exposure",
    severity: "critical",
    pattern: /process\.env\.(PRIVATE_KEY|SECRET_KEY|MNEMONIC)/i,
    description: "Malicious packages can read environment variables with keys.",
    recommendation: "Never store keys in env vars. Use hardware signers or KMS."
  },
  {
    id: "SOL2805",
    name: "Dependency Confusion Attack Vector",
    severity: "high",
    pattern: /@(internal|private|company)\//i,
    description: "Private package names can be hijacked on public registry.",
    recommendation: "Use scoped packages with organization ownership verification."
  },
  {
    id: "SOL2806",
    name: "Transitive Dependency Not Audited",
    severity: "medium",
    pattern: /"dependencies"\s*:\s*\{[\s\S]*\}/i,
    description: "Transitive dependencies can introduce vulnerabilities.",
    recommendation: "Run npm audit regularly and review deep dependency tree."
  },
  {
    id: "SOL2807",
    name: "GitHub Action Workflow Injection",
    severity: "high",
    pattern: /\$\{\{\s*github\.event\.[\s\S]*\}\}/i,
    description: "Unsanitized GitHub context in workflows enables code injection.",
    recommendation: "Never use github.event directly in run commands."
  },
  {
    id: "SOL2808",
    name: "CI/CD Secret Exposure",
    severity: "critical",
    pattern: /echo[\s\S]*\$\{\{\s*secrets\./i,
    description: "Secrets printed in CI logs can be captured.",
    recommendation: "Never echo secrets. Use secret masking in CI/CD."
  }
];
var RACE_CONDITION_PATTERNS = [
  {
    id: "SOL2821",
    name: "Off-Chain Balance Without Lock",
    severity: "critical",
    pattern: /(balance|amount)[\s\S]{0,50}(increment|add|update)(?![\s\S]{0,100}(lock|mutex|transaction))/i,
    description: "Balance updates without locking enable race condition exploits. Aurory lost $830K.",
    recommendation: "Use database transactions with row-level locking for balance updates."
  },
  {
    id: "SOL2822",
    name: "Parallel Request No Deduplication",
    severity: "critical",
    pattern: /(buy|sell|transfer|withdraw)[\s\S]{0,50}(handler|endpoint)(?![\s\S]{0,100}(dedupe|idempotent|nonce))/i,
    description: "Parallel requests can be replayed. Use idempotency keys.",
    recommendation: "Require unique idempotency key per request with deduplication."
  },
  {
    id: "SOL2823",
    name: "Read-Modify-Write Without Atomic",
    severity: "high",
    pattern: /(get|read|fetch)[\s\S]{0,30}(balance|amount)[\s\S]{0,50}(set|update|save)/i,
    description: "Non-atomic read-modify-write sequence has race window.",
    recommendation: "Use atomic operations: UPDATE balance = balance + x WHERE..."
  },
  {
    id: "SOL2824",
    name: "Hybrid On-Off Chain State Mismatch",
    severity: "critical",
    pattern: /(sync|bridge|transfer)[\s\S]{0,50}(chain|on.?chain)[\s\S]{0,50}(off.?chain|database)/i,
    description: "State synchronization between on-chain and off-chain can desync.",
    recommendation: "Implement two-phase commit or use on-chain as source of truth."
  },
  {
    id: "SOL2825",
    name: "Event Ordering Not Guaranteed",
    severity: "high",
    pattern: /event[\s\S]{0,30}(process|handle)(?![\s\S]{0,100}(sequence|order|serial))/i,
    description: "Out-of-order event processing can corrupt state.",
    recommendation: "Process events sequentially using sequence numbers."
  },
  {
    id: "SOL2826",
    name: "Optimistic Update Without Rollback",
    severity: "high",
    pattern: /optimistic[\s\S]{0,50}(update|write)(?![\s\S]{0,100}(rollback|revert|compensate))/i,
    description: "Optimistic updates without rollback capability lose consistency.",
    recommendation: "Implement compensating transactions for failed operations."
  }
];
var DEPIN_SECURITY_PATTERNS = [
  {
    id: "SOL2841",
    name: "Worker Registration No Verification",
    severity: "critical",
    pattern: /worker[\s\S]{0,30}(register|add)(?![\s\S]{0,100}(verify|proof|attestation))/i,
    description: "Workers can register with fake capabilities. io.net had 400K spoofed GPUs.",
    recommendation: "Require hardware attestation or proof-of-work for worker registration."
  },
  {
    id: "SOL2842",
    name: "Resource Metadata Unverified",
    severity: "high",
    pattern: /metadata[\s\S]{0,30}(gpu|cpu|memory|storage)(?![\s\S]{0,100}(verify|check|validate))/i,
    description: "Self-reported metadata can be spoofed.",
    recommendation: "Verify resource claims through benchmark tests or attestation."
  },
  {
    id: "SOL2843",
    name: "Sybil Attack No Prevention",
    severity: "critical",
    pattern: /(node|worker|peer)[\s\S]{0,30}(join|register)(?![\s\S]{0,100}(stake|identity|proof))/i,
    description: "No cost to create nodes enables Sybil attacks.",
    recommendation: "Require stake, verified identity, or proof-of-resource."
  },
  {
    id: "SOL2844",
    name: "Decentralized Network Eclipse Attack",
    severity: "high",
    pattern: /peer[\s\S]{0,30}(select|connect)(?![\s\S]{0,100}(random|diverse|limit))/i,
    description: "Biased peer selection enables eclipse attacks.",
    recommendation: "Use random peer selection with diversity requirements."
  },
  {
    id: "SOL2845",
    name: "Reward Distribution Gameable",
    severity: "high",
    pattern: /reward[\s\S]{0,30}(distribute|calculate)[\s\S]{0,50}(uptime|availability)/i,
    description: "Uptime-based rewards can be gamed with minimal actual contribution.",
    recommendation: "Base rewards on verified work output, not just availability."
  }
];
var FRONTEND_SECURITY_PATTERNS = [
  {
    id: "SOL2861",
    name: "Transaction Preview Missing",
    severity: "critical",
    pattern: /sign(Transaction|AllTransactions)(?![\s\S]{0,100}(preview|confirm|display))/i,
    description: "No transaction preview before signing. Users sign blind.",
    recommendation: "Always show human-readable transaction preview before signing."
  },
  {
    id: "SOL2862",
    name: "Address Comparison Case Sensitive",
    severity: "high",
    pattern: /address[\s\S]{0,20}(==|===)[\s\S]{0,20}(address|pubkey)/i,
    description: "Case-sensitive address comparison can be bypassed.",
    recommendation: "Normalize addresses before comparison (lowercase or base58 canonical)."
  },
  {
    id: "SOL2863",
    name: "Domain Verification Missing",
    severity: "critical",
    pattern: /(wallet[\s_]?connect|sign)(?![\s\S]{0,100}(domain|origin|verify))/i,
    description: "No domain verification for wallet connections. Enables phishing.",
    recommendation: "Verify domain against whitelist before wallet interaction."
  },
  {
    id: "SOL2864",
    name: "CDN Resource Without SRI",
    severity: "medium",
    pattern: /<script[\s\S]*src=["']https?:\/\/[\s\S]*(?!integrity)/i,
    description: "External scripts without Subresource Integrity can be hijacked.",
    recommendation: "Add integrity attribute with SHA-384/512 hash for CDN resources."
  },
  {
    id: "SOL2865",
    name: "Local Storage for Sensitive Data",
    severity: "high",
    pattern: /localStorage\.(setItem|getItem)[\s\S]{0,50}(key|secret|token)/i,
    description: "Sensitive data in localStorage is accessible to any script.",
    recommendation: "Never store keys in localStorage. Use session storage or memory only."
  },
  {
    id: "SOL2866",
    name: "CORS Wildcard Origin",
    severity: "high",
    pattern: /Access-Control-Allow-Origin[\s\S]{0,10}\*/i,
    description: "Wildcard CORS allows any site to make requests.",
    recommendation: "Specify allowed origins explicitly, never use wildcard."
  },
  {
    id: "SOL2867",
    name: "Unsigned WebSocket Messages",
    severity: "high",
    pattern: /websocket[\s\S]{0,50}(message|send)(?![\s\S]{0,100}(sign|verify|auth))/i,
    description: "Unsigned WebSocket messages can be spoofed or tampered.",
    recommendation: "Sign all WebSocket messages and verify on receipt."
  }
];
var CORE_PROTOCOL_PATTERNS = [
  {
    id: "SOL2881",
    name: "BPF Loader Upgrade Without Guard",
    severity: "critical",
    pattern: /bpf_loader[\s\S]{0,30}upgrade(?![\s\S]{0,100}(guard|verify|auth))/i,
    description: "BPF program upgrade without proper authority verification.",
    recommendation: "Always verify upgrade authority before allowing program upgrades."
  },
  {
    id: "SOL2882",
    name: "Compute Unit Estimation Wrong",
    severity: "medium",
    pattern: /compute[\s_]?unit[\s\S]{0,30}(set|request)[\s\S]{0,20}\d{3,5}(?!\d)/i,
    description: "Fixed compute units may be insufficient for complex transactions.",
    recommendation: "Use simulation to estimate compute units, add buffer for variance."
  },
  {
    id: "SOL2883",
    name: "Priority Fee Zero",
    severity: "low",
    pattern: /priority[\s_]?fee[\s\S]{0,10}(=|:)[\s\S]{0,5}0/i,
    description: "Zero priority fee may cause transaction delays in congestion.",
    recommendation: "Set dynamic priority fees based on network conditions."
  },
  {
    id: "SOL2884",
    name: "Durable Nonce Without Advance",
    severity: "high",
    pattern: /nonce[\s_]?account(?![\s\S]{0,100}advance)/i,
    description: "Durable nonce without advance instruction. JIT cache bug affected this.",
    recommendation: "Always include NonceAdvance as first instruction."
  },
  {
    id: "SOL2885",
    name: "Blockhash Caching Too Long",
    severity: "medium",
    pattern: /blockhash[\s\S]{0,30}(cache|store)[\s\S]{0,50}(minute|hour|day)/i,
    description: "Blockhashes expire after ~2 minutes. Caching causes failures.",
    recommendation: "Fetch fresh blockhash for each transaction or use durable nonces."
  },
  {
    id: "SOL2886",
    name: "Transaction Size Unbounded",
    severity: "high",
    pattern: /instruction[\s\S]{0,30}(push|add)(?![\s\S]{0,100}(size|len|limit))/i,
    description: "Transaction size limit is 1232 bytes. Unbounded adds fail.",
    recommendation: "Check transaction size before adding instructions."
  },
  {
    id: "SOL2887",
    name: "Account Realloc Without Rent",
    severity: "high",
    pattern: /realloc[\s\S]{0,50}(increase|grow)(?![\s\S]{0,100}rent)/i,
    description: "Account reallocation needs rent top-up for larger size.",
    recommendation: "Calculate and transfer additional rent on realloc."
  },
  {
    id: "SOL2888",
    name: "Lookup Table Stale Reference",
    severity: "medium",
    pattern: /lookup[\s_]?table[\s\S]{0,30}(use|get)(?![\s\S]{0,100}(fresh|reload|verify))/i,
    description: "Stale address lookup table can cause transaction failures.",
    recommendation: "Refresh lookup table state before critical transactions."
  },
  {
    id: "SOL2889",
    name: "Versioned Transaction Compatibility",
    severity: "medium",
    pattern: /Transaction[\s\S]{0,20}::new(?![\s\S]{0,100}Version)/i,
    description: "Legacy transactions dont support lookup tables.",
    recommendation: "Use VersionedTransaction for modern features."
  },
  {
    id: "SOL2890",
    name: "CPI Depth Limit Exceeded",
    severity: "high",
    pattern: /invoke[\s\S]{0,50}invoke[\s\S]{0,50}invoke[\s\S]{0,50}invoke/i,
    description: "CPI depth limit is 4. Deep nesting fails.",
    recommendation: "Flatten CPI chains or use different architectural approach."
  }
];
function checkBatch64Patterns(input) {
  const findings = [];
  if (!input.rust?.content) {
    return findings;
  }
  const content = input.rust.content;
  const lines = content.split("\n");
  const allPatterns = [
    ...SUPPLY_CHAIN_PATTERNS,
    ...RACE_CONDITION_PATTERNS,
    ...DEPIN_SECURITY_PATTERNS,
    ...FRONTEND_SECURITY_PATTERNS,
    ...CORE_PROTOCOL_PATTERNS
  ];
  for (const pattern of allPatterns) {
    const match = pattern.pattern.exec(content);
    if (match) {
      const lineNumber = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: pattern.id,
        title: pattern.name,
        severity: pattern.severity,
        description: pattern.description,
        location: { file: input.path, line: lineNumber },
        recommendation: pattern.recommendation
      });
    }
  }
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const context = lines.slice(Math.max(0, i - 10), Math.min(lines.length, i + 10)).join("\n");
    if (line.includes("msg!") && (line.includes("{}") || line.includes("{:?}"))) {
      if (context.includes("input") || context.includes("user") || context.includes("data")) {
        findings.push({
          id: "SOL2891",
          title: "User Input in Error Message",
          severity: "low",
          description: "User-controlled data in error messages can leak information.",
          location: { file: input.path, line: i + 1 },
          recommendation: "Sanitize or redact user input in error messages."
        });
      }
    }
    if (line.match(/Pubkey::from_str\(["'][A-HJ-NP-Za-km-z1-9]{32,44}["']\)/)) {
      findings.push({
        id: "SOL2892",
        title: "Hardcoded Public Key",
        severity: "medium",
        description: "Hardcoded addresses reduce flexibility and can be deployment issues.",
        location: { file: input.path, line: i + 1 },
        recommendation: "Use configurable addresses or derive from seeds."
      });
    }
    if (line.match(/\[\s*\d+\s*\]/) && !context.includes("len()") && !context.includes(".get(")) {
      if (!line.includes("[0]") && !line.includes("// safe")) {
        findings.push({
          id: "SOL2893",
          title: "Unchecked Array Index Access",
          severity: "high",
          description: "Direct array index without bounds check can panic.",
          location: { file: input.path, line: i + 1 },
          recommendation: "Use .get() with proper error handling instead."
        });
      }
    }
    if ((line.includes("f32") || line.includes("f64")) && (context.includes("price") || context.includes("amount") || context.includes("fee"))) {
      findings.push({
        id: "SOL2894",
        title: "Floating Point in Financial Calculation",
        severity: "high",
        description: "Floating point has precision issues. Use fixed-point for money.",
        location: { file: input.path, line: i + 1 },
        recommendation: "Use u64/u128 with fixed decimal places for financial math."
      });
    }
    if ((line.includes("format!") || line.includes("to_string()")) && context.includes("fn process") || context.includes("#[instruction]")) {
      findings.push({
        id: "SOL2895",
        title: "String Allocation in Hot Path",
        severity: "medium",
        description: "String operations consume significant compute units.",
        location: { file: input.path, line: i + 1 },
        recommendation: "Avoid string ops in instruction handlers. Use msg! directly."
      });
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-65.ts
var SOL2901_TREASURY_WALLET_COMPROMISE = {
  id: "SOL2901",
  title: "Treasury Wallet Single Point of Failure",
  severity: "critical",
  description: "Treasury wallet controlled by single key without multisig. Step Finance lost $40M when treasury wallet was compromised.",
  pattern: /treasury|vault.*authority|admin.*wallet/i,
  antiPattern: /multisig|threshold|guardian|timelock/i,
  recommendation: "Use multisig for treasury wallets (e.g., Squads, Realms). Implement timelocks for large withdrawals."
};
var SOL2902_EXECUTIVE_KEY_EXPOSURE = {
  id: "SOL2902",
  title: "Executive/Admin Key Exposure Risk",
  severity: "critical",
  description: "High-value admin keys not properly secured. Step Finance breach attributed to executive-level key compromise.",
  pattern: /admin.*key|authority.*private|owner.*seed/i,
  antiPattern: /hardware.*wallet|cold.*storage|hsm|mpc/i,
  recommendation: "Store admin keys in hardware wallets or HSMs. Never store keys in hot wallets or software."
};
var SOL2903_YIELD_AGGREGATOR_TREASURY = {
  id: "SOL2903",
  title: "Yield Aggregator Treasury Isolation Missing",
  severity: "high",
  description: "Yield aggregator treasuries not isolated from operational accounts. Single compromise affects all funds.",
  pattern: /yield.*treasury|aggregator.*fund|vault.*balance/i,
  antiPattern: /isolated.*account|segregated|per.*user.*vault/i,
  recommendation: "Segregate treasury from operational accounts. Use separate PDAs for different fund types."
};
var SOL2904_CREDIT_PROTOCOL_ADMIN = {
  id: "SOL2904",
  title: "Credit Protocol Admin Wallet Compromise",
  severity: "critical",
  description: "Decentralized credit protocol lost $4.5M after attacker gained admin wallet control. CrediX breach Aug 2025.",
  pattern: /credit.*admin|loan.*authority|underwriter.*key/i,
  antiPattern: /multisig|timelock|governance.*required/i,
  recommendation: "Implement governance-controlled admin actions. Use timelocks for sensitive credit operations."
};
var SOL2905_UNDERWRITING_AUTHORITY_BYPASS = {
  id: "SOL2905",
  title: "Underwriting Authority Bypass",
  severity: "high",
  description: "Credit protocols may allow bypassing underwriting checks when admin key is compromised.",
  pattern: /underwrite|credit.*limit|loan.*approve/i,
  antiPattern: /require.*signer|verify.*authority|check.*role/i,
  recommendation: "Implement strict authority checks for underwriting. Use role-based access control."
};
var SOL2906_CREDIT_POOL_DRAIN = {
  id: "SOL2906",
  title: "Credit Pool Emergency Drain Without Timelock",
  severity: "high",
  description: "Credit pools without withdrawal timelocks can be drained instantly by compromised admin.",
  pattern: /emergency.*withdraw|admin.*drain|pool.*empty/i,
  antiPattern: /timelock|delay|governance.*vote/i,
  recommendation: "Add timelock delays to emergency withdrawals. Require governance approval for large drains."
};
var SOL2907_EXCHANGE_HOT_WALLET_SECURITY = {
  id: "SOL2907",
  title: "Exchange Hot Wallet Security Failure",
  severity: "critical",
  description: "Centralized exchange hot wallet compromised. Upbit lost $36M in Solana assets Nov 2025.",
  pattern: /hot.*wallet|exchange.*deposit|custodial.*key/i,
  antiPattern: /threshold.*sign|mpc|cold.*storage.*rotation/i,
  recommendation: "Minimize hot wallet balances. Use MPC/threshold signatures. Implement real-time monitoring."
};
var SOL2908_DEPOSIT_ADDRESS_VALIDATION = {
  id: "SOL2908",
  title: "Deposit Address Validation Missing",
  severity: "high",
  description: "Insufficient validation of deposit addresses allows attackers to redirect funds.",
  pattern: /deposit.*address|receive.*account|incoming.*transfer/i,
  antiPattern: /whitelist|verified.*address|known.*sender/i,
  recommendation: "Validate deposit addresses against whitelist. Implement address verification workflows."
};
var SOL2909_COLD_STORAGE_MIGRATION = {
  id: "SOL2909",
  title: "Insecure Cold Storage Migration",
  severity: "high",
  description: "Moving assets to cold storage without proper verification can expose funds during transition.",
  pattern: /cold.*storage|migrate.*vault|transfer.*reserve/i,
  antiPattern: /verify.*destination|audit.*trail|multi.*approval/i,
  recommendation: "Implement multi-approval for cold storage migrations. Log all movements with audit trail."
};
var SOL2910_API_KEY_EXPOSURE = {
  id: "SOL2910",
  title: "API Key Exposure Leading to Fund Theft",
  severity: "critical",
  description: "API keys with withdrawal permissions compromised. SwissBorg lost $41M via API breach.",
  pattern: /api.*key|secret.*token|auth.*header/i,
  antiPattern: /rate.*limit|ip.*whitelist|2fa.*required/i,
  recommendation: "Implement API key rotation. Use IP whitelisting. Require 2FA for sensitive operations."
};
var SOL2911_WITHDRAWAL_API_ABUSE = {
  id: "SOL2911",
  title: "Withdrawal API Without Rate Limiting",
  severity: "critical",
  description: "Withdrawal APIs without rate limiting allow attackers to drain funds rapidly.",
  pattern: /withdraw.*api|transfer.*endpoint|send.*funds/i,
  antiPattern: /rate.*limit|cooldown|daily.*limit/i,
  recommendation: "Implement withdrawal rate limits. Add cooldown periods between large withdrawals."
};
var SOL2912_API_AUTHENTICATION_BYPASS = {
  id: "SOL2912",
  title: "API Authentication Bypass Vulnerability",
  severity: "critical",
  description: "Weak API authentication allows unauthorized access to sensitive endpoints.",
  pattern: /api.*auth|bearer.*token|session.*key/i,
  antiPattern: /jwt.*verify|signature.*check|hmac/i,
  recommendation: "Use strong authentication (JWT with proper verification). Implement request signing."
};
var SOL2913_TOKEN2022_MINT_AUTHORITY_EXPLOIT = {
  id: "SOL2913",
  title: "Token-2022 Mint Authority Exploitation",
  severity: "critical",
  description: "Token-2022 flaw enabled unlimited token minting. Critical vulnerability in Solana ecosystem 2025.",
  pattern: /mint_to|MintTo|token.*mint.*authority/i,
  antiPattern: /supply.*cap|max.*supply|mint.*disabled/i,
  recommendation: "Verify Token-2022 program version. Implement supply caps. Consider removing mint authority after launch."
};
var SOL2914_TOKEN2022_EXTENSION_INTERACTION = {
  id: "SOL2914",
  title: "Token-2022 Extension Interaction Bug",
  severity: "high",
  description: "Interactions between Token-2022 extensions can create unexpected vulnerabilities.",
  pattern: /extension.*init|transfer.*hook|interest.*bearing/i,
  antiPattern: /extension.*validate|compatibility.*check/i,
  recommendation: "Thoroughly test Token-2022 extension combinations. Check for reentrancy in transfer hooks."
};
var SOL2915_CONFIDENTIAL_TRANSFER_LEAK = {
  id: "SOL2915",
  title: "Token-2022 Confidential Transfer Data Leak",
  severity: "high",
  description: "Confidential transfer metadata can leak through improper handling of encrypted amounts.",
  pattern: /confidential.*transfer|encrypted.*amount|zk.*proof/i,
  antiPattern: /decrypt.*verify|proof.*validate/i,
  recommendation: "Properly validate ZK proofs. Never log decrypted amounts. Handle confidential data securely."
};
var SOL2916_NPM_CRYPTO_CLIPPER = {
  id: "SOL2916",
  title: "NPM Package Crypto-Clipper Attack",
  severity: "critical",
  description: "Sept 2025 attack compromised 18 npm packages (chalk, debug, etc.) with crypto-clipper malware altering Solana addresses.",
  pattern: /require\(["']chalk|require\(["']debug|import.*from.*["']chalk/i,
  antiPattern: /lockfile.*verify|integrity.*check|npm.*audit/i,
  recommendation: "Run npm audit regularly. Verify package integrity. Use lockfiles. Pin exact versions."
};
var SOL2917_BROWSER_API_HOOKING = {
  id: "SOL2917",
  title: "Browser API Hooking for Address Swap",
  severity: "critical",
  description: "Malware hooks browser APIs to replace wallet addresses during copy-paste operations.",
  pattern: /clipboard|navigator\.clipboard|execCommand.*copy/i,
  antiPattern: /address.*verify|checksum.*validate|qr.*scan/i,
  recommendation: "Implement address checksum validation. Use QR codes for address entry. Double-verify addresses."
};
var SOL2918_DEPENDENCY_INJECTION_ATTACK = {
  id: "SOL2918",
  title: "Dependency Injection in Build Pipeline",
  severity: "high",
  description: "Compromised dependencies injected during build can exfiltrate keys or alter transactions.",
  pattern: /postinstall|prebuild|prepare.*script/i,
  antiPattern: /ignore.*scripts|--ignore-scripts|sandbox.*build/i,
  recommendation: "Use --ignore-scripts during install. Audit postinstall scripts. Build in isolated environments."
};
var SOL2919_TYPOSQUATTING_PACKAGE = {
  id: "SOL2919",
  title: "NPM Typosquatting Attack Vector",
  severity: "high",
  description: "Typosquatted packages (e.g., @solana/web3js vs @solana/web3.js) can steal credentials.",
  pattern: /solana.*web3|anchor.*lang|metaplex/i,
  antiPattern: /exact.*version|scoped.*package|verified.*publisher/i,
  recommendation: "Use exact package names. Verify publisher. Use scoped packages from official organizations."
};
var SOL2920_BRIDGE_MESSAGE_REPLAY = {
  id: "SOL2920",
  title: "Cross-Chain Message Replay Attack",
  severity: "critical",
  description: "Bridge messages replayed across chains. Over $1.5B stolen via bridge exploits by mid-2025.",
  pattern: /bridge.*message|vaa.*process|cross.*chain.*relay/i,
  antiPattern: /nonce.*check|replay.*protection|message.*consumed/i,
  recommendation: "Implement strict nonce tracking. Mark processed messages. Check for replay across all chains."
};
var SOL2921_GUARDIAN_QUORUM_MANIPULATION = {
  id: "SOL2921",
  title: "Bridge Guardian Quorum Manipulation",
  severity: "critical",
  description: "Insufficient guardian verification allows fabricated cross-chain messages.",
  pattern: /guardian.*set|verify.*signatures|quorum.*check/i,
  antiPattern: /threshold.*verify|signature.*count|guardian.*active/i,
  recommendation: "Verify guardian set is current. Check signature count meets threshold. Validate guardian activity."
};
var SOL2922_FINALITY_ASSUMPTION_EXPLOIT = {
  id: "SOL2922",
  title: "Source Chain Finality Assumption Exploit",
  severity: "high",
  description: "Bridges assuming finality too early can be exploited during chain reorganizations.",
  pattern: /finality|confirmation.*count|block.*depth/i,
  antiPattern: /wait.*finality|confirmed.*slot|finalized.*block/i,
  recommendation: "Wait for proper finality on source chain. Use finalized (not confirmed) state. Handle reorgs."
};
var SOL2923_TOKEN_MAPPING_SPOOFING = {
  id: "SOL2923",
  title: "Bridge Token Mapping Spoofing",
  severity: "high",
  description: "Incorrect token mappings can cause users to receive worthless tokens for valuable deposits.",
  pattern: /token.*mapping|wrapped.*token|bridge.*mint/i,
  antiPattern: /verified.*mapping|canonical.*token|registry.*check/i,
  recommendation: "Use canonical token registries. Verify token mappings on both chains. Alert on unknown tokens."
};
var SOL2924_VALIDATOR_CONCENTRATION_ATTACK = {
  id: "SOL2924",
  title: "Validator Client Concentration Attack",
  severity: "high",
  description: "Jito client runs on 88% of validators. Single client bug could halt network or enable exploits.",
  pattern: /jito.*client|validator.*client|mev.*boost/i,
  antiPattern: /client.*diversity|fallback.*client/i,
  recommendation: "Monitor validator client distribution. Prepare fallback plans for client-specific issues."
};
var SOL2925_HOSTING_PROVIDER_CONCENTRATION = {
  id: "SOL2925",
  title: "Hosting Provider Stake Concentration",
  severity: "medium",
  description: "Teraswitch and Latitude.sh control ~43% of network stake. Infrastructure failure could affect consensus.",
  pattern: /validator.*host|data.*center|infrastructure.*provider/i,
  antiPattern: /geographic.*distribution|multi.*provider/i,
  recommendation: "Diversify validator hosting. Monitor provider concentration. Prepare for infrastructure failures."
};
var SOL2926_JIT_LIQUIDITY_MEV_ATTACK = {
  id: "SOL2926",
  title: "JIT Liquidity MEV Attack",
  severity: "high",
  description: "Just-in-time liquidity attacks frontrun trades by adding/removing liquidity in same transaction.",
  pattern: /add.*liquidity|remove.*liquidity|lp.*position/i,
  antiPattern: /mev.*protection|private.*rpc|jito.*bundle/i,
  recommendation: "Use MEV-protected RPCs. Submit via Jito bundles. Implement slippage protection."
};
var SOL2927_TIME_BANDIT_REORGANIZATION = {
  id: "SOL2927",
  title: "Time-Bandit Block Reorganization",
  severity: "high",
  description: "Attackers with significant stake could reorganize blocks to reverse transactions.",
  pattern: /slot.*leader|block.*production|fork.*choice/i,
  antiPattern: /finality.*wait|confirmation.*depth/i,
  recommendation: "Wait for finality before considering transactions permanent. Monitor for unusual forks."
};
var SOL2928_SETAUTHORITY_PHISHING = {
  id: "SOL2928",
  title: "SetAuthority Phishing Attack",
  severity: "critical",
  description: "Attackers trick users into signing SetAuthority transactions that transfer account ownership. $3M+ stolen per SlowMist.",
  pattern: /SetAuthority|set_authority|AuthorityType/i,
  antiPattern: /simulation.*warning|authority.*change.*alert/i,
  recommendation: "Always simulate transactions. Warn users about authority changes. Review transaction details carefully."
};
var SOL2929_MEMO_PHISHING = {
  id: "SOL2929",
  title: "Memo Field Phishing Lure",
  severity: "medium",
  description: "Attackers use memo fields to display phishing links or fake claims in wallet history.",
  pattern: /memo|spl.*memo|MemoTransfer/i,
  antiPattern: /sanitize.*memo|filter.*links/i,
  recommendation: "Sanitize memo display. Never click links in memos. Filter suspicious memo content."
};
var SOL2930_FAKE_AIRDROP_CLAIM = {
  id: "SOL2930",
  title: "Fake Airdrop Claim Transaction",
  severity: "high",
  description: "Fake airdrop claim transactions request approval for malicious token transfers.",
  pattern: /airdrop.*claim|claim.*reward|free.*token/i,
  antiPattern: /verify.*source|official.*site/i,
  recommendation: "Only claim airdrops from official sources. Verify contract addresses. Never approve unknown tokens."
};
var SOL2931_LENDING_HEALTH_FACTOR_BYPASS = {
  id: "SOL2931",
  title: "Lending Protocol Health Factor Bypass",
  severity: "critical",
  description: "Manipulating collateral values to bypass health factor checks and avoid liquidation.",
  pattern: /health.*factor|collateral.*ratio|ltv.*check/i,
  antiPattern: /oracle.*twap|price.*sanity|collateral.*verify/i,
  recommendation: "Use TWAP oracles for health calculations. Implement price sanity checks. Verify collateral sources."
};
var SOL2932_LIQUIDATION_FRONTRUNNING = {
  id: "SOL2932",
  title: "Liquidation Frontrunning Attack",
  severity: "high",
  description: "Liquidators frontrun price oracle updates to liquidate positions before users can repay.",
  pattern: /liquidate|liquidation.*bonus|bad.*debt/i,
  antiPattern: /private.*liquidation|grace.*period/i,
  recommendation: "Implement liquidation grace periods. Use private mempool for liquidations. Alert users before liquidation."
};
var SOL2933_VAULT_SHARE_INFLATION = {
  id: "SOL2933",
  title: "First Depositor Vault Share Inflation",
  severity: "high",
  description: "First depositor can inflate share price to steal from subsequent depositors.",
  pattern: /shares.*mint|vault.*deposit|first.*deposit/i,
  antiPattern: /minimum.*deposit|dead.*shares|initial.*liquidity/i,
  recommendation: "Require minimum initial deposit. Mint dead shares to zero address. Set minimum share price."
};
var SOL2934_INTEREST_RATE_MANIPULATION = {
  id: "SOL2934",
  title: "Interest Rate Model Manipulation",
  severity: "high",
  description: "Manipulating utilization rate to spike interest rates and liquidate borrowers.",
  pattern: /interest.*rate|utilization|borrow.*rate/i,
  antiPattern: /rate.*cap|utilization.*smooth|rate.*limit/i,
  recommendation: "Implement interest rate caps. Smooth utilization changes. Protect against flash manipulation."
};
var SOL2935_ORACLE_DEVIATION_EXPLOIT = {
  id: "SOL2935",
  title: "Oracle Price Deviation Exploit",
  severity: "critical",
  description: "Exploiting price deviations between multiple oracles or oracle vs AMM prices.",
  pattern: /price.*deviation|oracle.*diff|price.*delta/i,
  antiPattern: /deviation.*check|price.*band|oracle.*aggregate/i,
  recommendation: "Check price deviation between sources. Reject transactions with large deviations. Use aggregated prices."
};
var SOL2936_STAKE_POOL_COMMISSION_ABUSE = {
  id: "SOL2936",
  title: "Stake Pool Commission Rate Abuse",
  severity: "high",
  description: "Stake pool operators can change commission rates without notice, stealing staker rewards.",
  pattern: /commission.*rate|pool.*fee|manager.*fee/i,
  antiPattern: /commission.*cap|fee.*timelock|rate.*limit/i,
  recommendation: "Implement commission rate caps. Add timelock for fee changes. Alert stakers of changes."
};
var SOL2937_GOVERNANCE_FLASH_LOAN_VOTING = {
  id: "SOL2937",
  title: "Governance Flash Loan Voting Attack",
  severity: "critical",
  description: "Using flash loans to acquire governance tokens, vote, then return tokens in same transaction.",
  pattern: /governance.*token|voting.*power|proposal.*vote/i,
  antiPattern: /snapshot.*voting|token.*lock|vote.*delay/i,
  recommendation: "Use snapshot-based voting. Require token lock period. Implement vote delay after transfers."
};
var SOL2938_PROPOSAL_SPAM_DOS = {
  id: "SOL2938",
  title: "Governance Proposal Spam DoS",
  severity: "medium",
  description: "Spamming proposals to exhaust voter attention or governance processing capacity.",
  pattern: /create.*proposal|proposal.*count|new.*proposal/i,
  antiPattern: /proposal.*stake|proposal.*limit|spam.*prevention/i,
  recommendation: "Require stake to create proposals. Limit active proposals. Implement proposal cooldowns."
};
var SOL2939_NFT_METADATA_INJECTION = {
  id: "SOL2939",
  title: "NFT Metadata XSS/Injection Attack",
  severity: "medium",
  description: "Malicious scripts in NFT metadata can attack marketplace users viewing collections.",
  pattern: /metadata.*uri|json.*uri|external.*url/i,
  antiPattern: /sanitize.*metadata|csp.*header|escape.*html/i,
  recommendation: "Sanitize all metadata display. Use Content Security Policy. Never execute metadata scripts."
};
var SOL2940_COMPRESSED_NFT_PROOF_MANIPULATION = {
  id: "SOL2940",
  title: "Compressed NFT Merkle Proof Manipulation",
  severity: "high",
  description: "Invalid merkle proofs could allow minting or transferring cNFTs without authorization.",
  pattern: /merkle.*proof|verify.*proof|concurrent.*merkle/i,
  antiPattern: /proof.*verify|root.*check|canopy.*validate/i,
  recommendation: "Always verify merkle proofs. Check root matches on-chain state. Validate canopy depth."
};
var SOL2941_GAMING_RANDOMNESS_EXPLOIT = {
  id: "SOL2941",
  title: "On-Chain Gaming Randomness Exploit",
  severity: "high",
  description: "Predictable randomness in games allows attackers to always win valuable items.",
  pattern: /random|slot.*hash|recent.*blockhash/i,
  antiPattern: /vrf|switchboard.*vrf|chainlink.*vrf/i,
  recommendation: "Use verifiable random functions (VRF). Never use slot hashes for randomness. Use commit-reveal."
};
var SOL2942_BLIND_SIGNING_ATTACK = {
  id: "SOL2942",
  title: "Blind Signing Attack Vector",
  severity: "critical",
  description: "Users signing transactions without understanding contents can approve malicious actions.",
  pattern: /sign.*transaction|signTransaction|approve.*tx/i,
  antiPattern: /simulation|preview|human.*readable/i,
  recommendation: "Always simulate before signing. Show human-readable transaction summaries. Warn on unusual operations."
};
var SOL2943_SEED_PHRASE_EXTRACTION = {
  id: "SOL2943",
  title: "Seed Phrase Extraction from Memory",
  severity: "critical",
  description: "Malware extracting seed phrases from browser memory or unencrypted storage.",
  pattern: /mnemonic|seed.*phrase|bip39/i,
  antiPattern: /encrypted.*storage|secure.*enclave|memory.*wipe/i,
  recommendation: "Never store seed phrases in plaintext. Use encrypted storage. Clear memory after use."
};
var SOL2944_APPROVAL_DELEGATION_DRAIN = {
  id: "SOL2944",
  title: "Token Approval Delegation Drain",
  severity: "high",
  description: "Unlimited token approvals allow attackers to drain wallets long after initial approval.",
  pattern: /approve|delegation|allowance/i,
  antiPattern: /exact.*amount|revoke|zero.*allowance/i,
  recommendation: "Approve exact amounts needed. Revoke unused approvals. Monitor delegations regularly."
};
var SOL2945_RPC_PROVIDER_MANIPULATION = {
  id: "SOL2945",
  title: "Malicious RPC Provider Attack",
  severity: "high",
  description: "Compromised RPC providers can return false data or censor transactions.",
  pattern: /rpc.*endpoint|connection.*url|cluster.*url/i,
  antiPattern: /multi.*rpc|fallback.*provider|verify.*response/i,
  recommendation: "Use multiple RPC providers. Verify critical data across providers. Use reputable providers."
};
var SOL2946_WEBSOCKET_SUBSCRIPTION_POISONING = {
  id: "SOL2946",
  title: "WebSocket Subscription Data Poisoning",
  severity: "medium",
  description: "Malicious websocket data can trigger incorrect application behavior.",
  pattern: /accountSubscribe|logsSubscribe|onAccountChange/i,
  antiPattern: /verify.*data|validate.*response|sanity.*check/i,
  recommendation: "Validate all websocket data. Cross-check critical updates. Implement sanity checks."
};
var SOL2947_FRONTEND_DNS_HIJACKING = {
  id: "SOL2947",
  title: "Frontend DNS Hijacking Attack",
  severity: "critical",
  description: "DNS hijacking redirects users to fake frontends that steal credentials or drain wallets.",
  pattern: /domain|dns|frontend.*url/i,
  antiPattern: /dnssec|certificate.*pin|sri.*integrity/i,
  recommendation: "Use DNSSEC. Pin certificates. Implement Subresource Integrity (SRI) for scripts."
};
var SOL2948_PROGRAM_UPGRADE_HIJACK = {
  id: "SOL2948",
  title: "Program Upgrade Authority Hijack",
  severity: "critical",
  description: "Compromised upgrade authority can deploy malicious program versions.",
  pattern: /upgrade.*authority|program.*authority|bpf.*upgradeable/i,
  antiPattern: /multisig.*upgrade|timelock.*upgrade|governance.*upgrade/i,
  recommendation: "Use multisig for upgrade authority. Implement upgrade timelocks. Consider making programs immutable."
};
var SOL2949_REINITIALIZATION_VULNERABILITY = {
  id: "SOL2949",
  title: "Account Reinitialization Vulnerability",
  severity: "critical",
  description: "Accounts without proper initialization checks can be reinitialized with malicious data.",
  pattern: /init|initialize|is_initialized/i,
  antiPattern: /already.*initialized|discriminator.*check|init.*once/i,
  recommendation: "Check if account is already initialized. Use Anchor init constraints. Verify discriminator."
};
var SOL2950_CLOSE_ACCOUNT_RESURRECTION = {
  id: "SOL2950",
  title: "Closed Account Resurrection Attack",
  severity: "high",
  description: "Closed accounts can be resurrected in same transaction to bypass security checks.",
  pattern: /close.*account|AccountClose|lamports.*=.*0/i,
  antiPattern: /zero.*discriminator|clear.*data|same.*tx.*check/i,
  recommendation: "Zero discriminator when closing. Clear all account data. Check for same-transaction resurrection."
};
function checkBatch65Patterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  const patterns = [
    // Step Finance
    SOL2901_TREASURY_WALLET_COMPROMISE,
    SOL2902_EXECUTIVE_KEY_EXPOSURE,
    SOL2903_YIELD_AGGREGATOR_TREASURY,
    // CrediX
    SOL2904_CREDIT_PROTOCOL_ADMIN,
    SOL2905_UNDERWRITING_AUTHORITY_BYPASS,
    SOL2906_CREDIT_POOL_DRAIN,
    // Upbit
    SOL2907_EXCHANGE_HOT_WALLET_SECURITY,
    SOL2908_DEPOSIT_ADDRESS_VALIDATION,
    SOL2909_COLD_STORAGE_MIGRATION,
    // SwissBorg
    SOL2910_API_KEY_EXPOSURE,
    SOL2911_WITHDRAWAL_API_ABUSE,
    SOL2912_API_AUTHENTICATION_BYPASS,
    // Token-2022
    SOL2913_TOKEN2022_MINT_AUTHORITY_EXPLOIT,
    SOL2914_TOKEN2022_EXTENSION_INTERACTION,
    SOL2915_CONFIDENTIAL_TRANSFER_LEAK,
    // NPM Supply Chain
    SOL2916_NPM_CRYPTO_CLIPPER,
    SOL2917_BROWSER_API_HOOKING,
    SOL2918_DEPENDENCY_INJECTION_ATTACK,
    SOL2919_TYPOSQUATTING_PACKAGE,
    // Cross-Chain Bridge
    SOL2920_BRIDGE_MESSAGE_REPLAY,
    SOL2921_GUARDIAN_QUORUM_MANIPULATION,
    SOL2922_FINALITY_ASSUMPTION_EXPLOIT,
    SOL2923_TOKEN_MAPPING_SPOOFING,
    // Advanced Attacks
    SOL2924_VALIDATOR_CONCENTRATION_ATTACK,
    SOL2925_HOSTING_PROVIDER_CONCENTRATION,
    SOL2926_JIT_LIQUIDITY_MEV_ATTACK,
    SOL2927_TIME_BANDIT_REORGANIZATION,
    // Phishing
    SOL2928_SETAUTHORITY_PHISHING,
    SOL2929_MEMO_PHISHING,
    SOL2930_FAKE_AIRDROP_CLAIM,
    // DeFi
    SOL2931_LENDING_HEALTH_FACTOR_BYPASS,
    SOL2932_LIQUIDATION_FRONTRUNNING,
    SOL2933_VAULT_SHARE_INFLATION,
    SOL2934_INTEREST_RATE_MANIPULATION,
    SOL2935_ORACLE_DEVIATION_EXPLOIT,
    // Staking & Governance
    SOL2936_STAKE_POOL_COMMISSION_ABUSE,
    SOL2937_GOVERNANCE_FLASH_LOAN_VOTING,
    SOL2938_PROPOSAL_SPAM_DOS,
    // NFT & Gaming
    SOL2939_NFT_METADATA_INJECTION,
    SOL2940_COMPRESSED_NFT_PROOF_MANIPULATION,
    SOL2941_GAMING_RANDOMNESS_EXPLOIT,
    // Wallet
    SOL2942_BLIND_SIGNING_ATTACK,
    SOL2943_SEED_PHRASE_EXTRACTION,
    SOL2944_APPROVAL_DELEGATION_DRAIN,
    // Infrastructure
    SOL2945_RPC_PROVIDER_MANIPULATION,
    SOL2946_WEBSOCKET_SUBSCRIPTION_POISONING,
    SOL2947_FRONTEND_DNS_HIJACKING,
    // Program
    SOL2948_PROGRAM_UPGRADE_HIJACK,
    SOL2949_REINITIALIZATION_VULNERABILITY,
    SOL2950_CLOSE_ACCOUNT_RESURRECTION
  ];
  for (const p of patterns) {
    if (p.pattern.test(content)) {
      if (p.antiPattern && p.antiPattern.test(content)) {
        continue;
      }
      findings.push({
        id: p.id,
        title: p.title,
        severity: p.severity,
        description: p.description,
        location: { file: input.path },
        recommendation: p.recommendation
      });
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-66.ts
var SOL2951_FAKE_TICK_ACCOUNT_CREATION = {
  id: "SOL2951",
  title: "CLMM Fake Tick Account Creation",
  severity: "critical",
  description: "Attacker created fake tick account mimicking real tick structure. Crema Finance lost $8.8M by circumventing owner checks.",
  pattern: /tick.*account|tick_lower|tick_upper|tick.*state/i,
  antiPattern: /owner.*==.*program|has_one.*tick|tick.*verified/i,
  recommendation: "Verify tick accounts are owned by expected program. Use Anchor has_one constraints. Check tick address derivation."
};
var SOL2952_TICK_OWNER_CHECK_BYPASS = {
  id: "SOL2952",
  title: "Tick Account Owner Check Bypass",
  severity: "critical",
  description: "Writing initialized tick address into fake account bypassed owner verification. Critical CLMM vulnerability.",
  pattern: /tick.*owner|verify.*tick|check.*tick.*account/i,
  antiPattern: /strict.*owner|pda.*derivation|seed.*verify/i,
  recommendation: "Derive tick addresses from PDAs with verified seeds. Never trust user-provided tick accounts without full validation."
};
var SOL2953_FEE_ACCUMULATOR_MANIPULATION = {
  id: "SOL2953",
  title: "CLMM Fee Accumulator Manipulation",
  severity: "critical",
  description: "Replacing authentic fee data with faked values allows claiming massive fees. Core Crema exploit mechanism.",
  pattern: /fee.*accumulator|fee.*growth|accumulated.*fees/i,
  antiPattern: /fee.*integrity|verify.*fee.*data|fee.*calculation/i,
  recommendation: "Calculate fees based on verified tick data only. Implement fee accumulator integrity checks."
};
var SOL2954_FLASH_LOAN_FEE_CLAIM = {
  id: "SOL2954",
  title: "Flash Loan Amplified Fee Claim",
  severity: "critical",
  description: "Using flash loans to add liquidity, manipulate fees, then claim and repay in single transaction.",
  pattern: /flash.*loan|flashloan|borrow.*repay/i,
  antiPattern: /flash.*loan.*guard|atomic.*check|loan.*used.*flag/i,
  recommendation: "Track flash loan usage. Prevent fee claims in same transaction as flash loan. Add claim cooldowns."
};
var SOL2955_ACCOUNTINFO_OWNER_MISSING = {
  id: "SOL2955",
  title: "AccountInfo Owner Verification Missing",
  severity: "critical",
  description: "AccountInfo without owner check allows any program to provide malicious accounts.",
  pattern: /AccountInfo|account_info|remaining_accounts/i,
  antiPattern: /owner\s*==|owner\.eq|check.*owner|owner.*key/i,
  recommendation: "Always verify account.owner == expected_program_id. Use Anchor Account<> types when possible."
};
var SOL2956_DISCRIMINATOR_COLLISION = {
  id: "SOL2956",
  title: "Account Discriminator Hash Collision",
  severity: "high",
  description: "Similar account names may produce colliding 8-byte discriminators, enabling type confusion.",
  pattern: /discriminator|account.*type|#\[account\]/i,
  antiPattern: /unique.*discriminator|explicit.*discriminator/i,
  recommendation: "Use explicit discriminators. Avoid similar account names. Verify discriminator uniqueness."
};
var SOL2957_ACCOUNT_DATA_RACE = {
  id: "SOL2957",
  title: "Account Data Race Condition",
  severity: "high",
  description: "Reading account data, performing CPI, then using stale data can cause inconsistencies.",
  pattern: /data\.borrow|borrow_mut|account\.data/i,
  antiPattern: /reload|refresh|re.*fetch/i,
  recommendation: "Re-read account data after CPI calls. Never cache account data across CPI boundaries."
};
var SOL2958_USER_CONTROLLED_SEEDS = {
  id: "SOL2958",
  title: "User-Controlled PDA Seeds Without Validation",
  severity: "critical",
  description: "Allowing arbitrary user input in PDA seeds enables accessing unintended accounts.",
  pattern: /find_program_address|create_program_address|seeds.*user/i,
  antiPattern: /validate.*seed|seed.*whitelist|known.*seeds/i,
  recommendation: "Validate all seed inputs. Use fixed/known seeds where possible. Whitelist allowed seed values."
};
var SOL2959_BUMP_SEED_INJECTION = {
  id: "SOL2959",
  title: "Bump Seed Injection Attack",
  severity: "high",
  description: "Accepting user-provided bump seeds instead of canonical bumps can reference wrong accounts.",
  pattern: /bump|canonical_bump|find_program_address/i,
  antiPattern: /find.*bump|canonical|bump.*seed.*verified/i,
  recommendation: "Always use canonical bump from find_program_address. Never accept user-provided bumps."
};
var SOL2960_SEED_LENGTH_MANIPULATION = {
  id: "SOL2960",
  title: "Variable Seed Length Manipulation",
  severity: "medium",
  description: 'Variable-length seeds can collide. ["ab", "c"] and ["a", "bc"] may hash to same PDA.',
  pattern: /seeds.*=.*\[|push.*seed|seed.*vec/i,
  antiPattern: /fixed.*length.*seed|delimiter|seed.*separator/i,
  recommendation: "Use fixed-length seeds or include length delimiters. Avoid concatenating variable-length strings."
};
var SOL2961_UNCHECKED_CPI_PROGRAM = {
  id: "SOL2961",
  title: "Unchecked CPI Target Program",
  severity: "critical",
  description: "CPI to user-provided program ID allows calling arbitrary malicious programs.",
  pattern: /invoke|invoke_signed|CpiContext/i,
  antiPattern: /program_id\s*==|verify.*program|known.*program/i,
  recommendation: "Verify CPI target is expected program. Use Anchor Program<> types. Hardcode trusted program IDs."
};
var SOL2962_CPI_RETURN_DATA_SPOOFING = {
  id: "SOL2962",
  title: "CPI Return Data Spoofing",
  severity: "high",
  description: "Malicious programs can return fake data via CPI. Return data must be validated.",
  pattern: /get_return_data|return_data|cpi.*return/i,
  antiPattern: /verify.*return|validate.*response|trusted.*program/i,
  recommendation: "Only trust return data from verified programs. Validate return data structure and values."
};
var SOL2963_CPI_ACCOUNT_REORDERING = {
  id: "SOL2963",
  title: "CPI Account Array Reordering",
  severity: "high",
  description: "Incorrect account ordering in CPI can cause funds to go to wrong destinations.",
  pattern: /accounts.*=.*\[|AccountMeta|account.*infos/i,
  antiPattern: /named.*accounts|verify.*order|anchor.*context/i,
  recommendation: "Use named accounts (Anchor). Verify account ordering matches target program expectations."
};
var SOL2964_SIGNER_SEEDS_EXPOSURE = {
  id: "SOL2964",
  title: "Signer Seeds Exposed in Logs",
  severity: "medium",
  description: "Logging PDA signer seeds can leak sensitive derivation information.",
  pattern: /msg!.*seed|log.*seed|print.*seed|debug.*seed/i,
  antiPattern: /production.*build|release.*mode/i,
  recommendation: "Never log signer seeds. Remove debug logging in production. Use conditional compilation."
};
var SOL2965_DIVISION_TRUNCATION_THEFT = {
  id: "SOL2965",
  title: "Division Truncation Enabling Theft",
  severity: "critical",
  description: "Integer division truncation in fee/share calculations can be exploited for rounding attacks.",
  pattern: /\/ |\.div\(|checked_div/i,
  antiPattern: /round.*up|ceil|scale.*factor|precision/i,
  recommendation: "Use higher precision internally. Round in protocol's favor. Implement minimum amounts."
};
var SOL2966_SHARE_CALCULATION_ROUNDING = {
  id: "SOL2966",
  title: "Share Calculation Rounding Error",
  severity: "high",
  description: "Rounding errors in share calculations compound over time, draining pool value.",
  pattern: /shares|mint.*amount|burn.*amount|ratio/i,
  antiPattern: /round.*down.*withdraw|round.*up.*deposit|precision.*guard/i,
  recommendation: "Round against user on both deposit (down) and withdraw (up). Use sufficient decimal precision."
};
var SOL2967_INTEREST_ACCRUAL_MANIPULATION = {
  id: "SOL2967",
  title: "Interest Accrual Timing Manipulation",
  severity: "high",
  description: "Manipulating when interest accrues can extract value from lending protocols.",
  pattern: /accrue.*interest|interest.*rate|compound/i,
  antiPattern: /accrue.*before|update.*interest|rate.*sanity/i,
  recommendation: "Always accrue interest before state changes. Validate interest rate within bounds."
};
var SOL2968_PRICE_OVERFLOW_IN_MULTIPLICATION = {
  id: "SOL2968",
  title: "Price Calculation Overflow",
  severity: "critical",
  description: "Price * amount can overflow even with checked math if intermediates overflow.",
  pattern: /price.*\*|amount.*\*.*price|value.*=.*price/i,
  antiPattern: /u128|U256|checked.*mul.*then.*div|safe.*math/i,
  recommendation: "Use u128 or larger for price calculations. Check overflow at every step. Scale down early."
};
var SOL2969_SINGLE_ORACLE_DEPENDENCY = {
  id: "SOL2969",
  title: "Single Oracle Source Dependency",
  severity: "high",
  description: "Relying on single oracle allows manipulation via oracle-specific attacks.",
  pattern: /oracle.*price|get_price|price_feed/i,
  antiPattern: /multiple.*oracle|aggregate.*price|median.*price/i,
  recommendation: "Use multiple oracle sources. Implement median/TWAP. Check price deviation between sources."
};
var SOL2970_ORACLE_STALENESS_THRESHOLD = {
  id: "SOL2970",
  title: "Oracle Staleness Threshold Too High",
  severity: "high",
  description: "Accepting stale oracle data enables using outdated prices for profitable trades.",
  pattern: /staleness|max.*age|last.*update|timestamp.*diff/i,
  antiPattern: /staleness.*<.*60|fresh.*price|recent.*update/i,
  recommendation: "Set conservative staleness thresholds (< 60 seconds for DeFi). Reject stale prices."
};
var SOL2971_ORACLE_CONFIDENCE_INTERVAL = {
  id: "SOL2971",
  title: "Oracle Confidence Interval Ignored",
  severity: "medium",
  description: "Using oracle price without checking confidence interval accepts uncertain data.",
  pattern: /price.*\.|get.*price|oracle.*result/i,
  antiPattern: /confidence|price.*conf|uncertainty|deviation/i,
  recommendation: "Check oracle confidence intervals. Reject prices with low confidence. Widen price bands."
};
var SOL2972_TWAP_WINDOW_MANIPULATION = {
  id: "SOL2972",
  title: "TWAP Window Too Short",
  severity: "high",
  description: "Short TWAP windows can be manipulated within a single block.",
  pattern: /twap|time.*weighted|average.*price/i,
  antiPattern: /twap.*window.*>.*300|long.*twap|multi.*block/i,
  recommendation: "Use TWAP windows > 5 minutes. Implement manipulation detection. Use multiple price sources."
};
var SOL2973_STATE_MACHINE_VIOLATION = {
  id: "SOL2973",
  title: "State Machine Transition Violation",
  severity: "high",
  description: "Invalid state transitions can put protocol in inconsistent state.",
  pattern: /state|status|phase|stage/i,
  antiPattern: /valid.*transition|state.*machine|require.*state/i,
  recommendation: "Implement explicit state machine. Validate all transitions. Reject invalid state changes."
};
var SOL2974_INVARIANT_CHECK_MISSING = {
  id: "SOL2974",
  title: "Protocol Invariant Check Missing",
  severity: "high",
  description: "Missing invariant checks allow protocol to enter invalid states.",
  pattern: /total.*supply|balance|reserve|liquidity/i,
  antiPattern: /assert.*invariant|verify.*balance|check.*total/i,
  recommendation: "Define and check protocol invariants. Assert balance equations. Validate totals after operations."
};
var SOL2975_REENTRANCY_STATE_CORRUPTION = {
  id: "SOL2975",
  title: "Reentrancy Leading to State Corruption",
  severity: "critical",
  description: "State changes after CPI allow reentrancy to corrupt state.",
  pattern: /invoke|CpiContext|after.*cpi/i,
  antiPattern: /reentrancy.*guard|state.*before.*cpi|lock/i,
  recommendation: "Update state before CPI. Use reentrancy guards. Check state after CPI."
};
var SOL2976_MINT_AUTHORITY_NOT_REVOKED = {
  id: "SOL2976",
  title: "Mint Authority Not Revoked",
  severity: "high",
  description: "Active mint authority allows unlimited token minting.",
  pattern: /mint_authority|MintTo|mint.*tokens/i,
  antiPattern: /authority.*None|revoke.*mint|disable.*mint/i,
  recommendation: "Revoke mint authority after initial mint. Use governance for mint authority if needed."
};
var SOL2977_FREEZE_AUTHORITY_CENTRALIZATION = {
  id: "SOL2977",
  title: "Freeze Authority Centralization Risk",
  severity: "medium",
  description: "Single entity controlling freeze authority can freeze user funds.",
  pattern: /freeze_authority|FreezeAccount|freeze.*token/i,
  antiPattern: /freeze.*revoked|no.*freeze|decentralized.*freeze/i,
  recommendation: "Consider revoking freeze authority. Use governance for freeze decisions if needed."
};
var SOL2978_TOKEN_ACCOUNT_OWNER_MISMATCH = {
  id: "SOL2978",
  title: "Token Account Owner Mismatch",
  severity: "critical",
  description: "Not verifying token account owner allows sending tokens to wrong recipient.",
  pattern: /token.*account|TokenAccount|associated.*token/i,
  antiPattern: /owner.*==|verify.*owner|has_one.*owner/i,
  recommendation: "Verify token account owner matches expected recipient. Use Anchor token account constraints."
};
var SOL2979_ATA_CREATION_RACE = {
  id: "SOL2979",
  title: "ATA Creation Race Condition",
  severity: "medium",
  description: "Multiple transactions creating same ATA can fail or be front-run.",
  pattern: /create.*associated|get_associated|init.*if.*needed/i,
  antiPattern: /idempotent|check.*exists|try.*create/i,
  recommendation: "Use idempotent ATA creation. Check if ATA exists before creating. Handle creation failures."
};
var SOL2980_ADMIN_BACKDOOR = {
  id: "SOL2980",
  title: "Hidden Admin Backdoor Function",
  severity: "critical",
  description: "Hidden admin functions can bypass normal access controls.",
  pattern: /admin|owner|authority|superuser/i,
  antiPattern: /documented.*admin|audit.*admin|transparent.*authority/i,
  recommendation: "Document all admin functions. Make admin capabilities transparent. Use timelocks for admin actions."
};
var SOL2981_AUTHORITY_TRANSFER_NO_ACCEPTANCE = {
  id: "SOL2981",
  title: "Authority Transfer Without Acceptance",
  severity: "high",
  description: "Direct authority transfer without new owner acceptance can lock funds.",
  pattern: /transfer.*authority|set.*owner|change.*admin/i,
  antiPattern: /pending.*authority|accept.*authority|two.*step/i,
  recommendation: "Implement two-step authority transfer. Require new owner to accept. Add timelock for transfers."
};
var SOL2982_ROLE_PERMISSION_ESCALATION = {
  id: "SOL2982",
  title: "Role Permission Escalation",
  severity: "critical",
  description: "Lower-privilege roles can grant themselves higher privileges.",
  pattern: /grant.*role|add.*permission|set.*role/i,
  antiPattern: /role.*hierarchy|require.*admin|permission.*check/i,
  recommendation: "Implement strict role hierarchy. Only higher roles can grant permissions. Audit role changes."
};
var SOL2983_BORROW_EXCEEDS_COLLATERAL = {
  id: "SOL2983",
  title: "Borrow Amount Exceeds Collateral Value",
  severity: "critical",
  description: "Insufficient collateral checks allow under-collateralized borrows.",
  pattern: /borrow|loan|debt|collateral.*ratio/i,
  antiPattern: /check.*collateral|ltv.*check|health.*factor/i,
  recommendation: "Always verify collateral value before lending. Check LTV against limits. Use fresh oracle prices."
};
var SOL2984_LIQUIDATION_BONUS_EXPLOITATION = {
  id: "SOL2984",
  title: "Liquidation Bonus Exploitation",
  severity: "high",
  description: "Excessive liquidation bonus can make self-liquidation profitable.",
  pattern: /liquidation.*bonus|liquidation.*incentive|liquidate.*reward/i,
  antiPattern: /bonus.*cap|reasonable.*bonus|anti.*self.*liquidation/i,
  recommendation: "Cap liquidation bonus. Prevent self-liquidation. Use dynamic bonus based on health factor."
};
var SOL2985_BAD_DEBT_SOCIALIZATION = {
  id: "SOL2985",
  title: "Bad Debt Socialization Mechanism Missing",
  severity: "high",
  description: "Without bad debt handling, insolvency losses fall on last withdrawers.",
  pattern: /bad.*debt|underwater|insolvent|negative.*equity/i,
  antiPattern: /insurance.*fund|socialize.*loss|reserve.*fund/i,
  recommendation: "Implement insurance fund. Socialize bad debt across depositors. Reserve portion of interest."
};
var SOL2986_CONSTANT_PRODUCT_VIOLATION = {
  id: "SOL2986",
  title: "AMM Constant Product Invariant Violation",
  severity: "critical",
  description: "Violating x*y=k invariant allows extracting value from AMM.",
  pattern: /reserve.*\*.*reserve|constant.*product|x.*y.*k/i,
  antiPattern: /verify.*invariant|check.*product|assert.*k/i,
  recommendation: "Always verify constant product after swaps. Check invariant at start and end of operations."
};
var SOL2987_SANDWICH_ATTACK_VECTOR = {
  id: "SOL2987",
  title: "Sandwich Attack Vulnerability",
  severity: "high",
  description: "Large swaps without slippage protection are vulnerable to sandwich attacks.",
  pattern: /swap|exchange|trade|amm/i,
  antiPattern: /slippage.*check|min.*output|deadline|max.*impact/i,
  recommendation: "Implement slippage protection. Add deadline checks. Use private mempools or MEV protection."
};
var SOL2988_LP_TOKEN_INFLATION = {
  id: "SOL2988",
  title: "LP Token Inflation Attack",
  severity: "critical",
  description: "First depositor can inflate LP token price to steal from others.",
  pattern: /lp.*token|liquidity.*token|pool.*share/i,
  antiPattern: /minimum.*liquidity|dead.*shares|bootstrap/i,
  recommendation: "Mint minimum LP tokens to zero address. Require minimum initial liquidity. Set share price floor."
};
var SOL2989_FLASH_GOVERNANCE_ATTACK = {
  id: "SOL2989",
  title: "Flash Loan Governance Voting",
  severity: "critical",
  description: "Flash loans enable acquiring voting power, voting, and returning in same transaction.",
  pattern: /vote|proposal|governance.*token/i,
  antiPattern: /snapshot|voting.*escrow|lock.*period/i,
  recommendation: "Use snapshot-based voting. Require token lock period. Implement vote escrow (ve tokens)."
};
var SOL2990_PROPOSAL_EXECUTION_BYPASS = {
  id: "SOL2990",
  title: "Governance Proposal Execution Bypass",
  severity: "critical",
  description: "Executing proposals without proper approval enables unauthorized actions.",
  pattern: /execute.*proposal|proposal.*execute|run.*proposal/i,
  antiPattern: /quorum.*check|vote.*threshold|timelock.*passed/i,
  recommendation: "Verify quorum and approval before execution. Implement mandatory timelock. Check vote threshold."
};
var SOL2991_VOTER_BRIBERY_VECTOR = {
  id: "SOL2991",
  title: "Governance Vote Bribery Vector",
  severity: "medium",
  description: "Lack of vote privacy enables vote buying and bribery.",
  pattern: /cast.*vote|vote.*power|delegation/i,
  antiPattern: /private.*vote|commit.*reveal|encrypted.*vote/i,
  recommendation: "Consider private voting (commit-reveal). Make bribery coordination difficult. Monitor unusual voting patterns."
};
var SOL2992_CALLBACK_INJECTION = {
  id: "SOL2992",
  title: "Callback Function Injection",
  severity: "critical",
  description: "User-controlled callback addresses enable calling arbitrary code.",
  pattern: /callback|hook|handler|on_complete/i,
  antiPattern: /whitelist.*callback|verify.*callback|known.*programs/i,
  recommendation: "Whitelist allowed callbacks. Never accept arbitrary callback addresses. Use known program IDs."
};
var SOL2993_COMPOSABILITY_ASSUMPTION_EXPLOIT = {
  id: "SOL2993",
  title: "Cross-Protocol Composability Exploit",
  severity: "high",
  description: "Assumptions about other protocol behavior can be violated.",
  pattern: /external.*protocol|composable|integration/i,
  antiPattern: /defensive.*check|verify.*external|isolate.*call/i,
  recommendation: "Make defensive assumptions about external protocols. Verify external call results. Isolate integration points."
};
var SOL2994_PROGRAM_VERSION_MISMATCH = {
  id: "SOL2994",
  title: "Integrated Program Version Mismatch",
  severity: "medium",
  description: "Integrating with specific program versions that may be upgraded.",
  pattern: /program_id|integrated.*program|external.*call/i,
  antiPattern: /version.*check|upgrade.*handler|compatibility/i,
  recommendation: "Check integrated program versions. Handle upgrades gracefully. Test against multiple versions."
};
var SOL2995_RENT_EXEMPTION_CHECK = {
  id: "SOL2995",
  title: "Rent Exemption Check Missing",
  severity: "medium",
  description: "Accounts without rent exemption can be garbage collected.",
  pattern: /lamports|rent|account.*create/i,
  antiPattern: /rent.*exempt|minimum.*balance|exemption.*check/i,
  recommendation: "Ensure all accounts are rent-exempt. Check lamport balance on creation."
};
var SOL2996_SLOT_RANDOMNESS_PREDICTION = {
  id: "SOL2996",
  title: "Predictable Slot-Based Randomness",
  severity: "critical",
  description: "Using slot hashes for randomness is predictable by validators.",
  pattern: /recent.*blockhash|slot.*hash|random/i,
  antiPattern: /vrf|verifiable.*random|chainlink/i,
  recommendation: "Use VRF for randomness. Never use slot hashes. Consider commit-reveal schemes."
};
var SOL2997_DEBUG_CODE_IN_PRODUCTION = {
  id: "SOL2997",
  title: "Debug Code in Production",
  severity: "medium",
  description: "Debug code left in production can expose sensitive information or bypass checks.",
  pattern: /debug|test.*only|devnet|localhost/i,
  antiPattern: /cfg.*release|production.*build|feature.*flag/i,
  recommendation: "Remove debug code before deployment. Use conditional compilation. Audit for test bypasses."
};
var SOL2998_TIMESTAMP_MANIPULATION = {
  id: "SOL2998",
  title: "Clock Timestamp Manipulation",
  severity: "medium",
  description: "On-chain timestamps can be slightly manipulated by validators.",
  pattern: /Clock|unix_timestamp|timestamp/i,
  antiPattern: /timestamp.*tolerance|approximate.*time|slot.*based/i,
  recommendation: "Allow timestamp tolerance. Use slot numbers for ordering. Never rely on exact timestamps."
};
var SOL2999_COMPUTE_BUDGET_GRIEFING = {
  id: "SOL2999",
  title: "Compute Unit Exhaustion Griefing",
  severity: "medium",
  description: "Attackers can make transactions fail by exhausting compute units.",
  pattern: /loop|iterate|for.*in|while/i,
  antiPattern: /bound.*check|max.*iteration|limit.*loop/i,
  recommendation: "Bound all loops. Set maximum iterations. Test worst-case compute usage."
};
var SOL3000_ERROR_HANDLING_INFORMATION_LEAK = {
  id: "SOL3000",
  title: "Error Message Information Leak",
  severity: "low",
  description: "Detailed error messages can leak implementation details to attackers.",
  pattern: /err!|error!|msg!.*error/i,
  antiPattern: /generic.*error|sanitize.*error/i,
  recommendation: "Use generic error messages in production. Log details separately. Don't reveal internal state."
};
function checkBatch66Patterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  const patterns = [
    // Crema Finance
    SOL2951_FAKE_TICK_ACCOUNT_CREATION,
    SOL2952_TICK_OWNER_CHECK_BYPASS,
    SOL2953_FEE_ACCUMULATOR_MANIPULATION,
    SOL2954_FLASH_LOAN_FEE_CLAIM,
    // Account Ownership
    SOL2955_ACCOUNTINFO_OWNER_MISSING,
    SOL2956_DISCRIMINATOR_COLLISION,
    SOL2957_ACCOUNT_DATA_RACE,
    // PDA & Seeds
    SOL2958_USER_CONTROLLED_SEEDS,
    SOL2959_BUMP_SEED_INJECTION,
    SOL2960_SEED_LENGTH_MANIPULATION,
    // CPI Security
    SOL2961_UNCHECKED_CPI_PROGRAM,
    SOL2962_CPI_RETURN_DATA_SPOOFING,
    SOL2963_CPI_ACCOUNT_REORDERING,
    SOL2964_SIGNER_SEEDS_EXPOSURE,
    // Arithmetic
    SOL2965_DIVISION_TRUNCATION_THEFT,
    SOL2966_SHARE_CALCULATION_ROUNDING,
    SOL2967_INTEREST_ACCRUAL_MANIPULATION,
    SOL2968_PRICE_OVERFLOW_IN_MULTIPLICATION,
    // Oracle
    SOL2969_SINGLE_ORACLE_DEPENDENCY,
    SOL2970_ORACLE_STALENESS_THRESHOLD,
    SOL2971_ORACLE_CONFIDENCE_INTERVAL,
    SOL2972_TWAP_WINDOW_MANIPULATION,
    // State Management
    SOL2973_STATE_MACHINE_VIOLATION,
    SOL2974_INVARIANT_CHECK_MISSING,
    SOL2975_REENTRANCY_STATE_CORRUPTION,
    // Token Security
    SOL2976_MINT_AUTHORITY_NOT_REVOKED,
    SOL2977_FREEZE_AUTHORITY_CENTRALIZATION,
    SOL2978_TOKEN_ACCOUNT_OWNER_MISMATCH,
    SOL2979_ATA_CREATION_RACE,
    // Access Control
    SOL2980_ADMIN_BACKDOOR,
    SOL2981_AUTHORITY_TRANSFER_NO_ACCEPTANCE,
    SOL2982_ROLE_PERMISSION_ESCALATION,
    // Lending
    SOL2983_BORROW_EXCEEDS_COLLATERAL,
    SOL2984_LIQUIDATION_BONUS_EXPLOITATION,
    SOL2985_BAD_DEBT_SOCIALIZATION,
    // DEX/AMM
    SOL2986_CONSTANT_PRODUCT_VIOLATION,
    SOL2987_SANDWICH_ATTACK_VECTOR,
    SOL2988_LP_TOKEN_INFLATION,
    // Governance
    SOL2989_FLASH_GOVERNANCE_ATTACK,
    SOL2990_PROPOSAL_EXECUTION_BYPASS,
    SOL2991_VOTER_BRIBERY_VECTOR,
    // Cross-Program
    SOL2992_CALLBACK_INJECTION,
    SOL2993_COMPOSABILITY_ASSUMPTION_EXPLOIT,
    SOL2994_PROGRAM_VERSION_MISMATCH,
    // Misc
    SOL2995_RENT_EXEMPTION_CHECK,
    SOL2996_SLOT_RANDOMNESS_PREDICTION,
    SOL2997_DEBUG_CODE_IN_PRODUCTION,
    SOL2998_TIMESTAMP_MANIPULATION,
    SOL2999_COMPUTE_BUDGET_GRIEFING,
    SOL3000_ERROR_HANDLING_INFORMATION_LEAK
  ];
  for (const p of patterns) {
    if (p.pattern.test(content)) {
      if (p.antiPattern && p.antiPattern.test(content)) {
        continue;
      }
      findings.push({
        id: p.id,
        title: p.title,
        severity: p.severity,
        description: p.description,
        location: { file: input.path },
        recommendation: p.recommendation
      });
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-67.ts
function createFinding(id, title, severity, description, location, recommendation) {
  return { id, title, severity, description, location, recommendation };
}
function checkWhaleLiquidationCascade(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("liquidate") && !input.rust.content.includes("cascade_protection") && !input.rust.content.includes("max_liquidation_per_block")) {
    findings.push(createFinding(
      "SOL3001",
      "Whale Liquidation Cascade Vulnerability",
      "critical",
      "Liquidation logic lacks cascade protection. Large position liquidations can trigger cascading losses across DeFi protocols.",
      { file: input.path },
      "Implement max_liquidation_per_block limits and cascade circuit breakers"
    ));
  }
  return findings;
}
function checkMevValidatorDependency(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("jito") || input.rust.content.includes("bundle")) && !input.rust.content.includes("fallback_validator") && !input.rust.content.includes("mev_protection")) {
    findings.push(createFinding(
      "SOL3002",
      "MEV-Dependent Validator Concentration Risk",
      "high",
      "Protocol relies on MEV infrastructure (Jito) without fallback. 88% validator concentration creates systemic risk.",
      { file: input.path },
      "Implement MEV-agnostic transaction submission with fallback to standard validators"
    ));
  }
  return findings;
}
function checkInfrastructureConcentration(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("validator") && input.rust.content.includes("stake") && !input.rust.content.includes("geographic_distribution") && !input.rust.content.includes("provider_diversity")) {
    findings.push(createFinding(
      "SOL3003",
      "Infrastructure Provider Concentration",
      "medium",
      "Validator staking logic should consider hosting provider diversity to avoid systemic failures.",
      { file: input.path },
      "Add provider diversity checks and avoid concentration in single hosting providers"
    ));
  }
  return findings;
}
function checkHighSpeedAccountValidation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("parallel") || input.rust.content.includes("concurrent")) && input.rust.content.includes("AccountInfo") && !input.rust.content.includes("is_signer") && !input.rust.content.includes("owner ==")) {
    findings.push(createFinding(
      "SOL3004",
      "Account Validation Missing in Parallel Context",
      "critical",
      "Parallel processing context lacks proper account validation. High-speed execution can bypass safety checks.",
      { file: input.path },
      "Ensure all AccountInfo validations (signer, owner) are performed before parallel operations"
    ));
  }
  return findings;
}
function checkHighTvlOracleProtection(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("oracle") && input.rust.content.includes("price") && !input.rust.content.includes("twap") && !input.rust.content.includes("confidence_interval") && !input.rust.content.includes("staleness_check")) {
    findings.push(createFinding(
      "SOL3005",
      "Oracle Price Without Confidence/TWAP Protection",
      "critical",
      "Oracle price used without TWAP or confidence interval checks. $1.8B in 2025 losses were from oracle manipulation.",
      { file: input.path },
      "Implement TWAP averaging, confidence intervals, and staleness checks for all oracle reads"
    ));
  }
  return findings;
}
function checkAdminAccessControl(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const adminPatterns = /pub\s+fn\s+(admin_|set_|update_|configure_|withdraw_|emergency_)/g;
  const matches = input.rust.content.match(adminPatterns);
  if (matches && matches.length > 0) {
    if (!input.rust.content.includes("#[access_control") && !input.rust.content.includes("require!(ctx.accounts.authority") && !input.rust.content.includes("has_one = authority")) {
      findings.push(createFinding(
        "SOL3006",
        "Admin Function Missing Access Control",
        "critical",
        `Found ${matches.length} admin function(s) without explicit access control. 19% of 2025 audit findings were access control issues.`,
        { file: input.path },
        "Add #[access_control] or require!(authority) checks to all admin functions"
      ));
    }
  }
  return findings;
}
function checkCpiReentrancy(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("invoke(") || input.rust.content.includes("invoke_signed(")) {
    if (input.rust.content.includes(".try_borrow_mut") || input.rust.content.includes(".borrow_mut()")) {
      const cpiIndex = Math.max(
        input.rust.content.indexOf("invoke("),
        input.rust.content.indexOf("invoke_signed(")
      );
      const borrowIndex = Math.max(
        input.rust.content.indexOf(".try_borrow_mut"),
        input.rust.content.indexOf(".borrow_mut()")
      );
      if (borrowIndex > cpiIndex && !input.rust.content.includes("reentrancy_guard")) {
        findings.push(createFinding(
          "SOL3007",
          "Potential CPI Reentrancy Vulnerability",
          "critical",
          "Mutable account borrow occurs after CPI. Called program could re-enter and exploit stale state.",
          { file: input.path },
          "Complete all state updates before CPI or implement reentrancy guards"
        ));
      }
    }
  }
  return findings;
}
function checkArithmeticOverflow(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("+ ") || input.rust.content.includes("* ")) && input.rust.content.includes("u64") && !input.rust.content.includes("checked_add") && !input.rust.content.includes("checked_mul") && !input.rust.content.includes("saturating_") && !input.rust.content.includes("overflow-checks = true")) {
    findings.push(createFinding(
      "SOL3008",
      "Unchecked Arithmetic Operations",
      "high",
      "u64 arithmetic without checked_add/checked_mul. Overflow vulnerabilities remain 25% of audit findings.",
      { file: input.path },
      "Use checked_add, checked_mul, or saturating operations for all arithmetic"
    ));
  }
  return findings;
}
function checkInputValidationBounds(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const funcPattern = /pub\s+fn\s+\w+\([^)]*amount:\s*u64[^)]*\)/g;
  if (funcPattern.test(input.rust.content)) {
    if (!input.rust.content.includes("require!(amount >") && !input.rust.content.includes("require!(amount <") && !input.rust.content.includes("amount == 0")) {
      findings.push(createFinding(
        "SOL3009",
        "Missing Amount Bounds Validation",
        "high",
        "Amount parameters lack bounds validation. Input validation issues are 25% of findings.",
        { file: input.path },
        "Add minimum and maximum bounds checks for all amount parameters"
      ));
    }
  }
  return findings;
}
function checkStateTransitionValidation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("pub enum") && input.rust.content.includes("State") && !input.rust.content.includes("valid_transition") && !input.rust.content.includes("can_transition")) {
    findings.push(createFinding(
      "SOL3010",
      "State Machine Without Transition Validation",
      "high",
      "State enum found without transition validation. Business logic issues are 38.5% of findings.",
      { file: input.path },
      "Implement explicit state transition validation with can_transition() checks"
    ));
  }
  return findings;
}
function checkDataIntegrityRace(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("AccountInfo") && (input.rust.content.includes("mut") || input.rust.content.includes("RefMut")) && !input.rust.content.includes("try_lock") && !input.rust.content.includes("atomic")) {
    findings.push(createFinding(
      "SOL3011",
      "Potential Data Integrity Race Condition",
      "medium",
      "Mutable account access without explicit locking. Race conditions can cause data corruption.",
      { file: input.path },
      "Use atomic operations or explicit locking for shared mutable state"
    ));
  }
  return findings;
}
function checkUnboundedIteration(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("for ") || input.rust.content.includes(".iter()")) && input.rust.content.includes(".len()") && !input.rust.content.includes("MAX_") && !input.rust.content.includes(".take(")) {
    findings.push(createFinding(
      "SOL3012",
      "Unbounded Iteration DoS Risk",
      "high",
      "Iteration over dynamic-length collection without bounds. DoS/Liveness issues are 8.5% of findings.",
      { file: input.path },
      "Add MAX_ITEMS constant and use .take(MAX_ITEMS) or explicit bounds checking"
    ));
  }
  return findings;
}
function checkTransferHookReentrancy(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("transfer_hook") || input.rust.content.includes("TransferHook")) {
    if (!input.rust.content.includes("reentrancy_check") && !input.rust.content.includes("in_transfer")) {
      findings.push(createFinding(
        "SOL3013",
        "Transfer Hook Reentrancy Risk",
        "critical",
        "Token-2022 transfer hook without reentrancy protection. Hooks can be exploited for reentry attacks.",
        { file: input.path },
        "Implement reentrancy guard flag that prevents nested transfer hook execution"
      ));
    }
  }
  return findings;
}
function checkCnftProofValidation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("merkle") || input.rust.content.includes("bubblegum")) && input.rust.content.includes("proof") && !input.rust.content.includes("verify_proof") && !input.rust.content.includes("validate_proof")) {
    findings.push(createFinding(
      "SOL3014",
      "cNFT Merkle Proof Validation Missing",
      "critical",
      "Compressed NFT operations without proper Merkle proof verification.",
      { file: input.path },
      "Always verify Merkle proofs before any cNFT state changes"
    ));
  }
  return findings;
}
function checkGovernanceFlashLoan(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("governance") || input.rust.content.includes("vote")) && input.rust.content.includes("token_balance") && !input.rust.content.includes("snapshot") && !input.rust.content.includes("voting_escrow")) {
    findings.push(createFinding(
      "SOL3015",
      "Governance Flash Loan Voting Attack",
      "critical",
      "Governance uses current token balance for voting power. Flash loans can manipulate votes.",
      { file: input.path },
      "Use snapshot-based voting power or require time-locked tokens (veTokens)"
    ));
  }
  return findings;
}
function checkSingleAdminKey(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("admin") && input.rust.content.includes("Pubkey") && !input.rust.content.includes("multisig") && !input.rust.content.includes("threshold") && !input.rust.content.includes("signers")) {
    findings.push(createFinding(
      "SOL3016",
      "Single Admin Key Risk",
      "high",
      "Admin controlled by single key without multisig. Pump.fun lost $1.9M to insider attack.",
      { file: input.path },
      "Implement multisig with minimum 2-of-3 threshold for admin operations"
    ));
  }
  return findings;
}
function checkPrivateKeyExposure(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const keyPatterns = [
    /private_key/i,
    /secret_key/i,
    /keypair\s*=/,
    /seed_phrase/i,
    /mnemonic/i
  ];
  for (const pattern of keyPatterns) {
    if (pattern.test(input.rust.content)) {
      findings.push(createFinding(
        "SOL3017",
        "Potential Private Key Exposure",
        "critical",
        "Code references private key material. DEXX lost $30M due to private key server storage.",
        { file: input.path },
        "Never store or reference private keys in code. Use hardware wallets or secure enclaves."
      ));
      break;
    }
  }
  return findings;
}
function checkSupplyChainRisk(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("use ") && input.rust.content.includes("::")) {
    if (input.path.endsWith("Cargo.toml")) {
      if (!input.rust.content.includes("=") || input.rust.content.includes("*")) {
        findings.push(createFinding(
          "SOL3018",
          "Unpinned Dependency Version",
          "high",
          "Dependencies should use exact version pinning. Web3.js supply chain attack affected millions.",
          { file: input.path },
          'Pin all dependency versions exactly (e.g., "1.2.3" not "^1.2.3" or "*")'
        ));
      }
    }
  }
  return findings;
}
function checkBondingCurveFlashLoan(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("bonding_curve") && (input.rust.content.includes("buy") || input.rust.content.includes("sell"))) {
    if (!input.rust.content.includes("flash_loan_guard") && !input.rust.content.includes("same_block_restriction")) {
      findings.push(createFinding(
        "SOL3019",
        "Bonding Curve Flash Loan Vulnerability",
        "critical",
        "Bonding curve without flash loan protection. Nirvana lost $3.5M to flash loan + bonding curve exploit.",
        { file: input.path },
        "Implement same-block buy/sell restrictions or flash loan detection"
      ));
    }
  }
  return findings;
}
function checkBridgeGuardianValidation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("guardian") && input.rust.content.includes("signature")) {
    if (!input.rust.content.includes("guardian_set_index") || !input.rust.content.includes("quorum")) {
      findings.push(createFinding(
        "SOL3020",
        "Bridge Guardian Validation Incomplete",
        "critical",
        "Bridge guardian signature without proper set index and quorum validation. Wormhole lost $326M.",
        { file: input.path },
        "Validate guardian set index, check quorum requirements, and verify all signatures"
      ));
    }
  }
  return findings;
}
var BATCH_67_PATTERNS = [
  { id: "SOL3001", name: "Whale Liquidation Cascade", severity: "critical", run: checkWhaleLiquidationCascade },
  { id: "SOL3002", name: "MEV-Dependent Validator Risk", severity: "high", run: checkMevValidatorDependency },
  { id: "SOL3003", name: "Infrastructure Concentration", severity: "medium", run: checkInfrastructureConcentration },
  { id: "SOL3004", name: "High-Speed Account Validation", severity: "critical", run: checkHighSpeedAccountValidation },
  { id: "SOL3005", name: "High-TVL Oracle Protection", severity: "critical", run: checkHighTvlOracleProtection },
  { id: "SOL3006", name: "Admin Access Control", severity: "critical", run: checkAdminAccessControl },
  { id: "SOL3007", name: "CPI Reentrancy", severity: "critical", run: checkCpiReentrancy },
  { id: "SOL3008", name: "Arithmetic Overflow", severity: "high", run: checkArithmeticOverflow },
  { id: "SOL3009", name: "Input Bounds Validation", severity: "high", run: checkInputValidationBounds },
  { id: "SOL3010", name: "State Machine Validation", severity: "high", run: checkStateTransitionValidation },
  { id: "SOL3011", name: "Data Integrity Race", severity: "medium", run: checkDataIntegrityRace },
  { id: "SOL3012", name: "Unbounded Iteration DoS", severity: "high", run: checkUnboundedIteration },
  { id: "SOL3013", name: "Transfer Hook Reentrancy", severity: "critical", run: checkTransferHookReentrancy },
  { id: "SOL3014", name: "cNFT Proof Validation", severity: "critical", run: checkCnftProofValidation },
  { id: "SOL3015", name: "Governance Flash Loan", severity: "critical", run: checkGovernanceFlashLoan },
  { id: "SOL3016", name: "Single Admin Key", severity: "high", run: checkSingleAdminKey },
  { id: "SOL3017", name: "Private Key Exposure", severity: "critical", run: checkPrivateKeyExposure },
  { id: "SOL3018", name: "Supply Chain Risk", severity: "high", run: checkSupplyChainRisk },
  { id: "SOL3019", name: "Bonding Curve Flash Loan", severity: "critical", run: checkBondingCurveFlashLoan },
  { id: "SOL3020", name: "Bridge Guardian Validation", severity: "critical", run: checkBridgeGuardianValidation }
];
function checkBatch67Patterns(input) {
  const findings = [];
  for (const pattern of BATCH_67_PATTERNS) {
    findings.push(...pattern.run(input));
  }
  return findings;
}

// src/patterns/solana-batched-patterns-68.ts
function createFinding2(id, title, severity, description, location, recommendation) {
  return { id, title, severity, description, location, recommendation };
}
function checkOwnerPermissionPhishing(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("SetAuthority") && !input.rust.content.includes("owner_change_confirmation") && !input.rust.content.includes("transfer_ownership_warning")) {
    findings.push(createFinding2(
      "SOL3051",
      "Owner Permission Phishing Vulnerability",
      "critical",
      "SetAuthority operations without explicit user confirmation can be exploited in phishing attacks that bypass transaction simulations.",
      { file: input.path },
      "Add explicit ownership transfer confirmations and warnings before SetAuthority operations"
    ));
  }
  return findings;
}
function checkSilentAccountTransfer(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("owner") && input.rust.content.includes("transfer") && !input.rust.content.includes("emit_ownership_event") && !input.rust.content.includes("log_owner_change")) {
    findings.push(createFinding2(
      "SOL3052",
      "Silent Account Control Transfer",
      "critical",
      "Account ownership transfers without logging or events can be exploited silently in phishing attacks.",
      { file: input.path },
      "Emit events and logs for all ownership transfers to ensure visibility"
    ));
  }
  return findings;
}
function checkAnalyticsKeyHarvesting(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("analytics") || input.rust.content.includes("telemetry") || input.rust.content.includes("tracking")) && (input.rust.content.includes("private_key") || input.rust.content.includes("seed_phrase") || input.rust.content.includes("keypair"))) {
    findings.push(createFinding2(
      "SOL3053",
      "Analytics Library Key Harvesting Risk",
      "critical",
      "Analytics/telemetry code has access to key material. Compromised analytics libraries (like posthog-js) can exfiltrate wallet credentials.",
      { file: input.path },
      "Isolate analytics code from key material. Never allow analytics libraries access to sensitive cryptographic data."
    ));
  }
  return findings;
}
function checkThirdPartyCredentialExposure(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("extern crate") || input.rust.content.includes("use ")) && (input.rust.content.includes("wallet") || input.rust.content.includes("keypair")) && !input.rust.content.includes("audit") && !input.rust.content.includes("trusted")) {
    findings.push(createFinding2(
      "SOL3054",
      "Third-Party Library Credential Exposure",
      "high",
      "External libraries with wallet access can be supply chain attack vectors. Trust Wallet lost $7M via malicious library injection.",
      { file: input.path },
      "Audit all third-party dependencies that access wallet/key functionality. Use lockfiles and verify checksums."
    ));
  }
  return findings;
}
function checkSimulationBypassOwner(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("simulate") && !input.rust.content.includes("owner_field_check") && !input.rust.content.includes("authority_simulation")) {
    findings.push(createFinding2(
      "SOL3055",
      "Transaction Simulation Bypass via Owner Field",
      "high",
      "Owner permission changes may not appear in standard transaction simulations, enabling phishing attacks.",
      { file: input.path },
      "Implement specialized simulation for authority/ownership changes that explicitly displays permission modifications"
    ));
  }
  return findings;
}
function checkHotWalletKeyIsolation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("hot_wallet") && !input.rust.content.includes("hsm") && !input.rust.content.includes("key_isolation") && !input.rust.content.includes("hardware_security")) {
    findings.push(createFinding2(
      "SOL3056",
      "Hot Wallet Key Isolation Failure",
      "critical",
      "Hot wallet keys without HSM or hardware isolation are vulnerable to server-side compromises. Upbit lost $36M in similar scenario.",
      { file: input.path },
      "Use HSM (Hardware Security Modules) for hot wallet key storage with strict access controls"
    ));
  }
  return findings;
}
function checkDepositAddressValidation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("deposit") && input.rust.content.includes("address") && !input.rust.content.includes("whitelist") && !input.rust.content.includes("address_validation")) {
    findings.push(createFinding2(
      "SOL3057",
      "Exchange Deposit Address Validation Missing",
      "high",
      "Deposit operations without address whitelisting or validation can lead to fund redirection attacks.",
      { file: input.path },
      "Implement deposit address whitelisting and multi-signature approval for new addresses"
    ));
  }
  return findings;
}
function checkChromeExtensionSecurity(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("extension") || input.rust.content.includes("browser")) && input.rust.content.includes("wallet") && !input.rust.content.includes("content_security_policy") && !input.rust.content.includes("script_isolation")) {
    findings.push(createFinding2(
      "SOL3058",
      "Browser Extension Wallet Security Risk",
      "high",
      "Browser extension wallets are vulnerable to malicious code injection. Trust Wallet breach drained $7M via extension compromise.",
      { file: input.path },
      "Implement strict CSP, script isolation, and code signing for browser extension components"
    ));
  }
  return findings;
}
function checkConsensusVulnerabilityPattern(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("consensus") && (input.rust.content.includes("block") || input.rust.content.includes("slot")) && !input.rust.content.includes("validator_set_check") && !input.rust.content.includes("finality_confirmation")) {
    findings.push(createFinding2(
      "SOL3059",
      "Consensus Layer Vulnerability Pattern",
      "critical",
      "Consensus operations without proper validator set and finality checks can lead to network stalling attacks.",
      { file: input.path },
      "Ensure consensus operations include validator set verification and finality confirmation mechanisms"
    ));
  }
  return findings;
}
function checkNetworkStallingVector(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("network") && input.rust.content.includes("propagate") && !input.rust.content.includes("rate_limit") && !input.rust.content.includes("ddos_protection")) {
    findings.push(createFinding2(
      "SOL3060",
      "Network Stalling Attack Vector",
      "high",
      "Network propagation without rate limiting can be exploited to stall block production.",
      { file: input.path },
      "Implement rate limiting and DDoS protection for network propagation paths"
    ));
  }
  return findings;
}
function checkTransactionFeeManipulation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("priority_fee") && !input.rust.content.includes("fee_cap") && !input.rust.content.includes("max_priority")) {
    findings.push(createFinding2(
      "SOL3061",
      "Transaction Fee Manipulation Risk",
      "medium",
      "Priority fee handling without caps can lead to fee manipulation and transaction ordering attacks.",
      { file: input.path },
      "Implement priority fee caps and fair ordering mechanisms"
    ));
  }
  return findings;
}
function checkWalletProviderIntegration(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("phantom") || input.rust.content.includes("okx") || input.rust.content.includes("wallet_adapter")) && !input.rust.content.includes("version_check") && !input.rust.content.includes("signature_validation")) {
    findings.push(createFinding2(
      "SOL3062",
      "Wallet Provider Integration Security",
      "medium",
      "Wallet provider integrations should verify versions and signatures to prevent phishing attacks.",
      { file: input.path },
      "Validate wallet provider versions and implement signature verification for critical operations"
    ));
  }
  return findings;
}
function checkBridgeFundLaundering(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("bridge") && !input.rust.content.includes("monitoring") && !input.rust.content.includes("rate_limit_bridge")) {
    findings.push(createFinding2(
      "SOL3063",
      "Bridge Fund Exfiltration Risk",
      "high",
      "Bridge operations without monitoring or rate limits enable attackers to quickly move stolen funds cross-chain.",
      { file: input.path },
      "Implement bridge operation monitoring, rate limits, and pause mechanisms for suspicious activity"
    ));
  }
  return findings;
}
function checkIncidentResponseCapability(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("admin") && !input.rust.content.includes("pause") && !input.rust.content.includes("emergency_stop") && !input.rust.content.includes("circuit_breaker")) {
    findings.push(createFinding2(
      "SOL3064",
      "Missing Rapid Incident Response Capability",
      "medium",
      "Protocols without pause mechanisms cannot respond quickly to exploits. Modern attacks require sub-10-minute response.",
      { file: input.path },
      "Implement emergency pause/circuit breaker mechanisms controllable by multisig or guardian"
    ));
  }
  return findings;
}
function checkExternalAlertIntegration(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("oracle") || input.rust.content.includes("price")) {
    findings.push(createFinding2(
      "SOL3065",
      "External Security Alert Integration Recommended",
      "info",
      "Consider integrating external security alerts (CertiK, SlowMist) for early warning of oracle manipulation or exploits.",
      { file: input.path },
      "Subscribe to security monitoring services and implement automated pause on external alerts"
    ));
  }
  return findings;
}
function checkTokenMixerUsage(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if ((input.rust.content.includes("tornado") || input.rust.content.includes("mixer") || input.rust.content.includes("tumbler")) && !input.rust.content.includes("compliance")) {
    findings.push(createFinding2(
      "SOL3066",
      "Token Mixer Integration Risk",
      "high",
      "Integration with mixer services can facilitate money laundering and may violate compliance requirements.",
      { file: input.path },
      "Implement compliance checks and avoid direct integration with mixer services"
    ));
  }
  return findings;
}
function checkSlowMistPhishingPatterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("approve") && input.rust.content.includes("unlimited") && !input.rust.content.includes("approval_limit")) {
    findings.push(createFinding2(
      "SOL3067",
      "Unlimited Token Approval Phishing Risk",
      "high",
      "Unlimited token approvals are a primary phishing vector. SlowMist documented $3M+ in losses from approval drain attacks.",
      { file: input.path },
      "Limit token approvals to specific amounts and implement approval expiry mechanisms"
    ));
  }
  return findings;
}
function checkSetAuthorityPhishing(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("set_authority") || input.rust.content.includes("SetAuthority")) {
    if (!input.rust.content.includes("two_step") && !input.rust.content.includes("timelock") && !input.rust.content.includes("confirmation_required")) {
      findings.push(createFinding2(
        "SOL3068",
        "SetAuthority Phishing Attack Vector",
        "critical",
        "SetAuthority without two-step confirmation or timelock can be exploited in phishing attacks for immediate account takeover.",
        { file: input.path },
        "Implement two-step authority transfer with timelock and explicit user confirmation"
      ));
    }
  }
  return findings;
}
function checkMemoPhishing(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("memo") && !input.rust.content.includes("memo_sanitize") && !input.rust.content.includes("url_filter")) {
    findings.push(createFinding2(
      "SOL3069",
      "Memo-Based Phishing Vector",
      "medium",
      "Transaction memos containing URLs can be used for phishing. Fake airdrop scams commonly use memo links.",
      { file: input.path },
      "Sanitize memo content and warn users about URLs in transaction memos"
    ));
  }
  return findings;
}
function checkInsuranceFundProtection(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("insurance") && input.rust.content.includes("fund")) {
    if (!input.rust.content.includes("insurance_cap") && !input.rust.content.includes("insurance_min")) {
      findings.push(createFinding2(
        "SOL3070",
        "Insurance Fund Depletion Risk",
        "high",
        "Insurance funds without caps and minimums can be drained through repeated claims or manipulation.",
        { file: input.path },
        "Implement insurance fund caps, minimums, and claim rate limits"
      ));
    }
  }
  return findings;
}
function checkWhiteHatCoordination(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("admin") || input.rust.content.includes("authority")) {
    if (!input.rust.content.includes("contact") && !input.rust.content.includes("security_team")) {
      findings.push(createFinding2(
        "SOL3071",
        "White Hat Contact Information Missing",
        "info",
        "Protocols should publish security contact information for white hat coordination. Loopscale recovered $5.8M through negotiation.",
        { file: input.path },
        "Add security.txt or on-chain contact for responsible disclosure"
      ));
    }
  }
  return findings;
}
function checkReimbursementCapability(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("treasury") || input.rust.content.includes("vault")) {
    if (!input.rust.content.includes("emergency_fund") && !input.rust.content.includes("backup_treasury")) {
      findings.push(createFinding2(
        "SOL3072",
        "Reimbursement Capability Assessment",
        "info",
        "Protocols with emergency funds can fully reimburse users after exploits (Wormhole: $326M, Pump.fun: $1.9M).",
        { file: input.path },
        "Maintain emergency funds or insurance coverage for potential exploit reimbursement"
      ));
    }
  }
  return findings;
}
function checkInsiderThreatControls(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("admin") || input.rust.content.includes("operator")) {
    if (!input.rust.content.includes("multi_sig") && !input.rust.content.includes("timelock") && !input.rust.content.includes("approval_required")) {
      findings.push(createFinding2(
        "SOL3073",
        "Insider Threat Control Missing",
        "high",
        "Admin operations without multisig or timelock enable insider theft. Pump.fun lost $1.9M to employee exploit.",
        { file: input.path },
        "Require multisig and timelock for all privileged operations"
      ));
    }
  }
  return findings;
}
function checkPartialRecoveryMechanism(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("recovery") || input.rust.content.includes("compensation")) {
    if (!input.rust.content.includes("priority") && !input.rust.content.includes("pro_rata")) {
      findings.push(createFinding2(
        "SOL3074",
        "Partial Recovery Priority Undefined",
        "low",
        "Define recovery priorities for partial reimbursement scenarios (e.g., Raydium: 100% native pools, 90% others).",
        { file: input.path },
        "Document recovery priorities and pro-rata distribution mechanisms in advance"
      ));
    }
  }
  return findings;
}
function checkRealTimeMonitoring(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("transfer") || input.rust.content.includes("withdraw")) {
    if (!input.rust.content.includes("monitor") && !input.rust.content.includes("alert") && !input.rust.content.includes("anomaly")) {
      findings.push(createFinding2(
        "SOL3075",
        "Real-Time Monitoring Missing",
        "medium",
        "Protocols should implement real-time monitoring for rapid exploit detection. Response times have improved from hours to minutes.",
        { file: input.path },
        "Integrate real-time anomaly detection and alerting for critical operations"
      ));
    }
  }
  return findings;
}
function checkBatch68Patterns(input) {
  const allFindings = [];
  allFindings.push(...checkOwnerPermissionPhishing(input));
  allFindings.push(...checkSilentAccountTransfer(input));
  allFindings.push(...checkAnalyticsKeyHarvesting(input));
  allFindings.push(...checkThirdPartyCredentialExposure(input));
  allFindings.push(...checkSimulationBypassOwner(input));
  allFindings.push(...checkHotWalletKeyIsolation(input));
  allFindings.push(...checkDepositAddressValidation(input));
  allFindings.push(...checkChromeExtensionSecurity(input));
  allFindings.push(...checkConsensusVulnerabilityPattern(input));
  allFindings.push(...checkNetworkStallingVector(input));
  allFindings.push(...checkTransactionFeeManipulation(input));
  allFindings.push(...checkWalletProviderIntegration(input));
  allFindings.push(...checkBridgeFundLaundering(input));
  allFindings.push(...checkIncidentResponseCapability(input));
  allFindings.push(...checkExternalAlertIntegration(input));
  allFindings.push(...checkTokenMixerUsage(input));
  allFindings.push(...checkSlowMistPhishingPatterns(input));
  allFindings.push(...checkSetAuthorityPhishing(input));
  allFindings.push(...checkMemoPhishing(input));
  allFindings.push(...checkInsuranceFundProtection(input));
  allFindings.push(...checkWhiteHatCoordination(input));
  allFindings.push(...checkReimbursementCapability(input));
  allFindings.push(...checkInsiderThreatControls(input));
  allFindings.push(...checkPartialRecoveryMechanism(input));
  allFindings.push(...checkRealTimeMonitoring(input));
  return allFindings;
}

// src/patterns/solana-batched-patterns-69.ts
function createFinding3(id, title, severity, description, location, recommendation) {
  return { id, title, severity, description, location, recommendation };
}
function checkSolendAuthBypass(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("update_reserve") || content.includes("UpdateReserveConfig")) {
    if (!content.includes("lending_market_authority") || !content.includes("has_one = lending_market_owner")) {
      findings.push(createFinding3(
        "SOL3076",
        "Lending Market Authority Bypass Risk",
        "critical",
        "UpdateReserveConfig without proper lending market authority validation. Attacker can create fake lending market and bypass admin checks.",
        { file: input.path },
        "Validate lending_market_owner against trusted lending_market account, not user-provided account"
      ));
    }
  }
  return findings;
}
function checkLiquidationThresholdManipulation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("liquidation_threshold") && content.includes("set") || content.includes("update")) {
    if (!content.includes("timelock") && !content.includes("delay")) {
      findings.push(createFinding3(
        "SOL3077",
        "Liquidation Threshold Instant Update Risk",
        "high",
        "Liquidation threshold changes without timelock can instantly make user positions liquidatable.",
        { file: input.path },
        "Add timelock delay for liquidation threshold changes to give users time to adjust positions"
      ));
    }
  }
  return findings;
}
function checkLiquidationBonusInflation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("liquidation_bonus")) {
    if (!content.includes("max_liquidation_bonus") && !content.includes("MAX_BONUS")) {
      findings.push(createFinding3(
        "SOL3078",
        "Unbounded Liquidation Bonus",
        "high",
        "Liquidation bonus without maximum cap can be inflated to extract excessive value from liquidated positions.",
        { file: input.path },
        "Set maximum liquidation bonus cap (typically 10-20%) and validate in update functions"
      ));
    }
  }
  return findings;
}
function checkGuardianSignatureBypass(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("verify_signature") || content.includes("guardian")) {
    if (content.includes("external") || content.includes("unchecked") || !content.includes("solana_program::secp256k1_recover")) {
      findings.push(createFinding3(
        "SOL3079",
        "External Signature Verification Risk",
        "critical",
        "Signature verification using external contracts can be bypassed by forging inputs. Wormhole lost $326M due to this.",
        { file: input.path },
        "Use native Solana secp256k1 verification, not external contract calls that can be spoofed"
      ));
    }
  }
  return findings;
}
function checkVAASpoofing(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("vaa") || content.includes("VAA") || content.includes("message")) {
    if (!content.includes("guardian_set") || !content.includes("quorum")) {
      findings.push(createFinding3(
        "SOL3080",
        "Cross-Chain Message Verification Missing",
        "critical",
        "Cross-chain messages (VAAs) must verify against guardian quorum. Missing validation enables message spoofing.",
        { file: input.path },
        "Verify message against current guardian set with proper quorum (2/3+ guardians)"
      ));
    }
  }
  return findings;
}
function checkDeprecatedVerifySignatures(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  if (input.rust.content.includes("verify_signatures_address")) {
    findings.push(createFinding3(
      "SOL3081",
      "Deprecated Signature Verification Function",
      "critical",
      "verify_signatures_address is deprecated and can be bypassed. Wormhole $326M exploit used this.",
      { file: input.path },
      "Use current Solana native signature verification methods instead of deprecated functions"
    ));
  }
  return findings;
}
function checkInfiniteMintCollateral(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if ((content.includes("mint") || content.includes("Mint")) && (content.includes("collateral") || content.includes("backing"))) {
    if (!content.includes("validate_collateral") && !content.includes("verify_backing") && !content.includes("collateral_mint ==")) {
      findings.push(createFinding3(
        "SOL3082",
        "Collateral Validation Missing on Mint",
        "critical",
        "Minting without proper collateral validation enables infinite mint attacks. Cashio lost $52.8M to this.",
        { file: input.path },
        "Validate collateral mint address and amount match expected backing before any mint operation"
      ));
    }
  }
  return findings;
}
function checkNestedAccountTrust(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("lp_token") || content.includes("underlying") || content.includes("nested")) {
    if (!content.includes("root_of_trust") && !content.includes("trusted_program")) {
      findings.push(createFinding3(
        "SOL3083",
        "Nested Account Trust Chain Vulnerability",
        "critical",
        "Nested account references (LP tokens, wrapped assets) need root of trust validation to prevent fake account chains.",
        { file: input.path },
        "Establish root of trust - verify all accounts in chain trace back to trusted program/mint"
      ));
    }
  }
  return findings;
}
function checkLPTokenValidation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("lp_token") || content.includes("LP") || content.includes("pool_token")) {
    if (!content.includes("pool_program") && !content.includes("amm_id") && !content.includes("validate_lp_mint")) {
      findings.push(createFinding3(
        "SOL3084",
        "LP Token Authenticity Not Verified",
        "critical",
        "LP tokens must be validated against their source AMM/pool program. Fake LP tokens can bypass collateral checks.",
        { file: input.path },
        "Verify LP token mint was created by the claimed AMM program and matches expected pool"
      ));
    }
  }
  return findings;
}
function checkFakeTickAccount(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("tick") || content.includes("Tick") || content.includes("position")) {
    if (!content.includes("tick_account.owner") && !content.includes("validate_tick_owner")) {
      findings.push(createFinding3(
        "SOL3085",
        "CLMM Tick Account Owner Not Verified",
        "critical",
        "Tick accounts in CLMM protocols must verify owner is the pool program. Fake tick accounts enabled Crema $8.8M exploit.",
        { file: input.path },
        "Verify tick account owner matches pool program ID before reading tick data"
      ));
    }
  }
  return findings;
}
function checkFeeAccumulatorManipulation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("fee") && (content.includes("accumulator") || content.includes("growth"))) {
    if (!content.includes("validate_fee_source") && !content.includes("fee_account.owner")) {
      findings.push(createFinding3(
        "SOL3086",
        "Fee Accumulator Source Not Validated",
        "high",
        "Fee accumulator data must come from verified accounts. Manipulated fee data enabled excessive fee claims.",
        { file: input.path },
        "Validate fee accumulator account ownership and derive from trusted pool state"
      ));
    }
  }
  return findings;
}
function checkFlashLoanFeeClaim(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("claim_fee") || content.includes("collect_fees")) {
    if (!content.includes("flash_loan_guard") && !content.includes("same_slot_check")) {
      findings.push(createFinding3(
        "SOL3087",
        "Fee Claim Vulnerable to Flash Loan Attack",
        "high",
        "Fee claims without flash loan protection can be amplified using borrowed liquidity within same transaction.",
        { file: input.path },
        "Add flash loan guards - check position age, slot-based cooling periods, or cumulative claim limits"
      ));
    }
  }
  return findings;
}
function checkSelfTradingOracle(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("oracle") && (content.includes("perp") || content.includes("market"))) {
    if (!content.includes("twap") && !content.includes("external_oracle")) {
      findings.push(createFinding3(
        "SOL3088",
        "On-Chain Oracle Vulnerable to Self-Trading",
        "critical",
        "On-chain oracles based on trade prices can be manipulated via self-trading. Mango lost $116M to this attack.",
        { file: input.path },
        "Use external oracles (Pyth, Switchboard) with TWAP, or implement trade-based manipulation detection"
      ));
    }
  }
  return findings;
}
function checkUnrealizedPnLCollateral(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("unrealized") || content.includes("pnl") || content.includes("PnL")) {
    if (content.includes("collateral") || content.includes("borrow")) {
      if (!content.includes("realized_only") && !content.includes("pnl_discount")) {
        findings.push(createFinding3(
          "SOL3089",
          "Unrealized PnL Used as Full Collateral",
          "critical",
          "Unrealized PnL as full collateral enables infinite leverage via self-trading. Apply discount or require realization.",
          { file: input.path },
          "Discount unrealized PnL significantly (50%+) or exclude from borrowing power entirely"
        ));
      }
    }
  }
  return findings;
}
function checkPositionConcentration(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("position") && (content.includes("open") || content.includes("increase"))) {
    if (!content.includes("max_position") && !content.includes("position_limit") && !content.includes("concentration_limit")) {
      findings.push(createFinding3(
        "SOL3090",
        "No Position Concentration Limits",
        "high",
        "Missing position limits allow single user to dominate market and manipulate prices. Implement position caps.",
        { file: input.path },
        "Add maximum position size relative to pool liquidity (e.g., max 10% of open interest)"
      ));
    }
  }
  return findings;
}
function checkSeedPhraseLogging(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if ((content.includes("seed") || content.includes("mnemonic") || content.includes("private_key")) && (content.includes("log") || content.includes("println") || content.includes("msg!"))) {
    findings.push(createFinding3(
      "SOL3091",
      "Potential Key Material Logging",
      "critical",
      "Logging near key material operations. Slope wallet leaked $8M by logging seed phrases to telemetry.",
      { file: input.path },
      "Never log or transmit seed phrases, private keys, or any key derivation material"
    ));
  }
  return findings;
}
function checkUnencryptedKeyStorage(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("store") && (content.includes("key") || content.includes("secret"))) {
    if (!content.includes("encrypt") && !content.includes("cipher") && !content.includes("sealed")) {
      findings.push(createFinding3(
        "SOL3092",
        "Key Storage Without Encryption",
        "critical",
        "Storing keys without encryption enables theft if storage is compromised. Always encrypt sensitive material.",
        { file: input.path },
        "Use authenticated encryption (ChaCha20-Poly1305, AES-GCM) for all key storage"
      ));
    }
  }
  return findings;
}
function checkTelemetrySensitiveData(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("sentry") || content.includes("telemetry") || content.includes("analytics")) {
    if (content.includes("user") || content.includes("account") || content.includes("wallet")) {
      findings.push(createFinding3(
        "SOL3093",
        "Telemetry May Include Sensitive User Data",
        "high",
        "Telemetry services near user/wallet data can leak sensitive information. Slope leaked seeds via Sentry.",
        { file: input.path },
        "Strictly filter telemetry - never include keys, seeds, signatures, or user-identifying wallet data"
      ));
    }
  }
  return findings;
}
function checkGovernanceProposalValidation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("proposal") && (content.includes("execute") || content.includes("submit"))) {
    if (!content.includes("validate_proposal") && !content.includes("proposal_check")) {
      findings.push(createFinding3(
        "SOL3094",
        "Governance Proposal Validation Missing",
        "critical",
        "Proposals without proper validation can execute malicious instructions. Audius lost $6.1M to this.",
        { file: input.path },
        "Validate proposal instructions against allowlist, check signer permissions, add execution delay"
      ));
    }
  }
  return findings;
}
function checkTreasuryPermissionChange(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("treasury") && (content.includes("permission") || content.includes("authority"))) {
    if (!content.includes("timelock") && !content.includes("multi_sig")) {
      findings.push(createFinding3(
        "SOL3095",
        "Treasury Permission Changes Without Timelock",
        "critical",
        "Treasury permission changes need timelocks and multisig. Instant changes enable governance attacks.",
        { file: input.path },
        "Require timelock (7+ days) and multisig for any treasury permission modifications"
      ));
    }
  }
  return findings;
}
function checkBondingCurveFlashLoan2(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("bonding_curve") || content.includes("pricing_curve")) {
    if (!content.includes("flash_loan_protection") && !content.includes("cooldown")) {
      findings.push(createFinding3(
        "SOL3096",
        "Bonding Curve Vulnerable to Flash Loan",
        "critical",
        "Bonding curves without flash loan protection can be exploited to mint at manipulated rates. Nirvana lost $3.5M.",
        { file: input.path },
        "Add time-based cooldowns between large buys/sells, or use TWAP-based pricing"
      ));
    }
  }
  return findings;
}
function checkProgramCloseWithFunds(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("close") && content.includes("program")) {
    if (!content.includes("withdraw_all") && !content.includes("funds_check")) {
      findings.push(createFinding3(
        "SOL3097",
        "Program Close Without Fund Check",
        "critical",
        "Program close operations must verify all funds are withdrawn first. OptiFi locked $661K by closing with funds inside.",
        { file: input.path },
        "Require zero balance check or automatic withdrawal before any program/account closure"
      ));
    }
  }
  return findings;
}
function checkIrreversibleAction(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  const irreversibleActions = ["close", "destroy", "terminate", "delete", "burn_all"];
  for (const action of irreversibleActions) {
    if (content.includes(action)) {
      if (!content.includes("confirmation") && !content.includes("two_step")) {
        findings.push(createFinding3(
          "SOL3098",
          "Irreversible Action Without Safeguard",
          "high",
          `Irreversible action "${action}" without two-step confirmation. Add confirmation mechanism to prevent accidents.`,
          { file: input.path },
          "Implement two-step confirmation: initiate action, then confirm after delay"
        ));
        break;
      }
    }
  }
  return findings;
}
function checkHotWalletExposure(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("hot_wallet") || content.includes("custodial")) {
    if (!content.includes("hsm") && !content.includes("mpc") && !content.includes("cold_storage")) {
      findings.push(createFinding3(
        "SOL3099",
        "Hot Wallet Without HSM/MPC Protection",
        "critical",
        "Hot wallets storing significant funds need HSM or MPC protection. DEXX lost $30M via exposed hot wallet keys.",
        { file: input.path },
        "Use HSM for key storage, MPC for signing, and implement cold storage thresholds"
      ));
    }
  }
  return findings;
}
function checkCommingledFunds(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("deposit") && content.includes("user")) {
    if (!content.includes("user_account") && content.includes("pool") || content.includes("shared")) {
      findings.push(createFinding3(
        "SOL3100",
        "User Funds May Be Commingled",
        "high",
        "User deposits into shared pools without individual accounting can lead to fund attribution issues and theft.",
        { file: input.path },
        "Use individual user accounts or precise share accounting for deposited funds"
      ));
    }
  }
  return findings;
}
function checkInsiderAccessControls(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("admin") || content.includes("operator") || content.includes("employee")) {
    if (!content.includes("multi_sig") && !content.includes("time_lock")) {
      findings.push(createFinding3(
        "SOL3101",
        "Privileged Role Without Multi-Sig",
        "high",
        "Privileged roles (admin/operator) without multi-sig enable insider attacks. Pump.fun lost $1.9M to employee.",
        { file: input.path },
        "Require multi-sig (2-of-3 minimum) for all privileged operations"
      ));
    }
  }
  return findings;
}
function checkPrivilegedMonitoring(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("admin") && (content.includes("withdraw") || content.includes("transfer"))) {
    if (!content.includes("emit!") && !content.includes("event")) {
      findings.push(createFinding3(
        "SOL3102",
        "Privileged Operations Not Emitting Events",
        "medium",
        "Privileged operations should emit events for monitoring. Silent admin actions enable undetected insider abuse.",
        { file: input.path },
        "Emit events for all privileged operations to enable real-time monitoring and alerting"
      ));
    }
  }
  return findings;
}
function checkDatabaseInjection(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("query") || content.includes("database") || content.includes("db")) {
    if (!content.includes("sanitize") && !content.includes("parameterized")) {
      findings.push(createFinding3(
        "SOL3103",
        "Database Query Without Sanitization",
        "high",
        "Database queries without input sanitization enable injection attacks. Thunder Terminal lost $240K to MongoDB injection.",
        { file: input.path },
        "Use parameterized queries and input sanitization for all database operations"
      ));
    }
  }
  return findings;
}
function checkSessionTokenSecurity(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("session") || content.includes("token") && content.includes("auth")) {
    if (!content.includes("expire") && !content.includes("rotate")) {
      findings.push(createFinding3(
        "SOL3104",
        "Session Tokens Without Expiration/Rotation",
        "medium",
        "Session tokens need expiration and rotation. Long-lived tokens increase theft window.",
        { file: input.path },
        "Implement short session expiration (24h), automatic rotation, and invalidation on suspicious activity"
      ));
    }
  }
  return findings;
}
function checkTradingBotKeyStorage(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("bot") && (content.includes("key") || content.includes("wallet"))) {
    if (!content.includes("encrypted") && !content.includes("secure_enclave")) {
      findings.push(createFinding3(
        "SOL3105",
        "Trading Bot Keys Without Secure Storage",
        "critical",
        "Trading bot private keys need encrypted/enclave storage. Banana Gun lost $1.4M via exposed keys.",
        { file: input.path },
        "Use hardware enclaves or encrypted storage with access controls for bot signing keys"
      ));
    }
  }
  return findings;
}
function checkBotPaymentValidation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("payment") && content.includes("bot")) {
    if (!content.includes("verify_payment") && !content.includes("receipt")) {
      findings.push(createFinding3(
        "SOL3106",
        "Bot Payment Without Verification",
        "high",
        "Automated payments need verification before processing. Solareum lost $500K+ to payment exploitation.",
        { file: input.path },
        "Verify payment confirmation before executing any automated transactions"
      ));
    }
  }
  return findings;
}
function checkSubAccountIsolation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("sub_account") || content.includes("subaccount")) {
    if (!content.includes("isolation") && !content.includes("access_control")) {
      findings.push(createFinding3(
        "SOL3107",
        "Sub-Account Isolation Not Enforced",
        "high",
        "Sub-accounts need strict isolation and access controls. Cypher lost $1.35M via sub-account access bypass.",
        { file: input.path },
        "Enforce strict sub-account isolation with explicit permission grants per sub-account"
      ));
    }
  }
  return findings;
}
function checkSybilProtection(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("node") || content.includes("provider") || content.includes("worker")) {
    if (!content.includes("stake") && !content.includes("verification") && !content.includes("proof")) {
      findings.push(createFinding3(
        "SOL3108",
        "Node/Provider Without Sybil Protection",
        "high",
        "Node registration without stake or verification enables Sybil attacks. io.net was attacked with fake GPUs.",
        { file: input.path },
        "Require stake deposit, hardware verification, or proof-of-work for node registration"
      ));
    }
  }
  return findings;
}
function checkHoneypotSellRestriction(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("transfer") && content.includes("restrict")) {
    if (content.includes("buy") && !content.includes("sell_allowed")) {
      findings.push(createFinding3(
        "SOL3109",
        "Potential Honeypot - Asymmetric Transfer Restrictions",
        "critical",
        "Transfer restrictions that allow buying but restrict selling indicate honeypot. SVT token used this pattern.",
        { file: input.path },
        "Ensure transfer restrictions apply equally to buys and sells, or flag for review"
      ));
    }
  }
  return findings;
}
function checkUnnoticedProposal(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("proposal") && content.includes("execute")) {
    if (!content.includes("notice_period") && !content.includes("voting_period")) {
      findings.push(createFinding3(
        "SOL3110",
        "Proposal Without Notice Period",
        "high",
        "Proposals need notice periods to allow community review. Saga DAO lost $230K to unnoticed attack proposal.",
        { file: input.path },
        "Implement minimum notice period (72h+) and voting duration before proposal execution"
      ));
    }
  }
  return findings;
}
function checkSupplyChainKeyExfiltration(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("import") || content.includes("require") || content.includes("dependency")) {
    if (content.includes("sign") || content.includes("key")) {
      findings.push(createFinding3(
        "SOL3111",
        "External Dependency Near Signing Logic",
        "medium",
        "External dependencies near signing logic can be compromised. Web3.js supply chain attack stole $164K.",
        { file: input.path },
        "Audit dependencies near signing code, use lockfiles, verify package integrity"
      ));
    }
  }
  return findings;
}
function checkFrontendIntegrity(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("frontend") || content.includes("web") || content.includes("ui")) {
    findings.push(createFinding3(
      "SOL3112",
      "Frontend Security Consideration",
      "info",
      "Frontend compromises (CDN, DNS) can redirect users to phishing sites. Parcl was affected by front-end attack.",
      { file: input.path },
      "Use Subresource Integrity (SRI), secure DNS (DNSSEC), and educate users to verify contract addresses"
    ));
  }
  return findings;
}
function checkNetworkDoSVulnerability(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("loop") || content.includes("while") || content.includes("for")) {
    if (!content.includes("limit") && !content.includes("max_iterations")) {
      findings.push(createFinding3(
        "SOL3113",
        "Unbounded Loop DoS Risk",
        "high",
        "Unbounded loops can be exploited for DoS attacks. Grape, Candy Machine saw network-level DoS from such patterns.",
        { file: input.path },
        "Add iteration limits and compute budget checks to prevent DoS via resource exhaustion"
      ));
    }
  }
  if (content.includes("create") || content.includes("mint") || content.includes("register")) {
    if (!content.includes("rate_limit") && !content.includes("fee")) {
      findings.push(createFinding3(
        "SOL3114",
        "Spam-able Operation Without Rate Limiting",
        "medium",
        "Operations without rate limiting or meaningful fees can be spammed. Candy Machine zero-fee mints caused network issues.",
        { file: input.path },
        "Add rate limiting, minimum fees, or stake requirements for spam-able operations"
      ));
    }
  }
  return findings;
}
function checkJITCacheVulnerability(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("cache") && content.includes("jit") || content.includes("compiled")) {
    if (!content.includes("invalidate") && !content.includes("version_check")) {
      findings.push(createFinding3(
        "SOL3115",
        "JIT/Cache Invalidation Missing",
        "high",
        "JIT compilation or caching without proper invalidation can cause state inconsistency. Solana had 5h outage from JIT cache bug.",
        { file: input.path },
        "Implement proper cache invalidation and version checking for compiled/cached code"
      ));
    }
  }
  return findings;
}
function checkPTTokenPricing(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("pt_token") || content.includes("principal_token") || content.includes("yield_token")) {
    if (!content.includes("validate_pricing") && !content.includes("oracle_check")) {
      findings.push(createFinding3(
        "SOL3116",
        "Yield Token Pricing Validation Missing",
        "critical",
        "PT/YT token pricing must be validated against oracle. Loopscale lost $5.8M to PT token pricing manipulation.",
        { file: input.path },
        "Validate principal/yield token prices against external oracles with sanity bounds"
      ));
    }
  }
  return findings;
}
function checkFlashLoanCollateralization(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("collateral") && (content.includes("borrow") || content.includes("loan"))) {
    if (!content.includes("snapshot") && !content.includes("pre_flash")) {
      findings.push(createFinding3(
        "SOL3117",
        "Collateralization Check Vulnerable to Flash Loan",
        "critical",
        "Collateral checks within single transaction can be bypassed with flash loans. Check collateral before flash loan context.",
        { file: input.path },
        "Take collateral snapshots before flash loan context or use time-delayed collateral verification"
      ));
    }
  }
  return findings;
}
function checkWhiteHatRecovery(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("admin") || content.includes("pause") || content.includes("emergency")) {
    if (!content.includes("recovery") && !content.includes("freeze")) {
      findings.push(createFinding3(
        "SOL3118",
        "No Emergency Recovery Mechanism",
        "medium",
        "Emergency recovery mechanisms help negotiate with white hats. Loopscale recovered $5.8M through negotiation.",
        { file: input.path },
        "Implement pause/freeze capability and clear bounty communication channels for white hat recovery"
      ));
    }
  }
  return findings;
}
function checkAdvancedSecurityPatterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("withdraw") || content.includes("transfer")) {
    if (!content.includes("circuit_breaker") && !content.includes("max_daily")) {
      findings.push(createFinding3(
        "SOL3119",
        "No Circuit Breaker for Large Operations",
        "medium",
        "Large withdrawals/transfers should trigger circuit breakers. Implement daily limits and anomaly detection.",
        { file: input.path },
        "Add daily withdrawal limits and pause on anomalous activity"
      ));
    }
  }
  if (content.includes("invoke") && content.includes("callback")) {
    if (!content.includes("reentrancy_guard") && !content.includes("entered")) {
      findings.push(createFinding3(
        "SOL3120",
        "Cross-Contract Reentrancy Risk",
        "high",
        "CPI invocations with callbacks can enable cross-contract reentrancy. Use reentrancy guards.",
        { file: input.path },
        "Implement reentrancy guard pattern: check-effects-interactions and state locks"
      ));
    }
  }
  if (content.includes("fee") && (content.includes("/") || content.includes("div"))) {
    if (!content.includes("checked") && !content.includes("saturating")) {
      findings.push(createFinding3(
        "SOL3121",
        "Unchecked Arithmetic in Fee Calculation",
        "high",
        "Fee calculations with division can truncate to zero on small amounts, causing fee bypass.",
        { file: input.path },
        "Use checked arithmetic and ensure minimum fees cannot be bypassed via small amounts"
      ));
    }
  }
  if (content.includes("time") && content.includes("access") || content.includes("unlock")) {
    if (!content.includes("clock::Clock") && content.includes("sysvar")) {
      findings.push(createFinding3(
        "SOL3122",
        "Time-Based Logic Without Proper Clock Source",
        "medium",
        "Time-based logic should use Solana Clock sysvar, not custom timestamps that could be manipulated.",
        { file: input.path },
        "Use Clock::get()?.unix_timestamp for all time-based logic"
      ));
    }
  }
  if (content.includes("transaction") && content.includes("version")) {
    if (!content.includes("v0") && !content.includes("legacy_check")) {
      findings.push(createFinding3(
        "SOL3123",
        "Transaction Version Handling",
        "low",
        "Ensure compatibility with both legacy and versioned (v0) transactions for wide client support.",
        { file: input.path },
        "Handle both legacy and versioned transaction formats appropriately"
      ));
    }
  }
  if (content.includes("lookup_table") || content.includes("AddressLookupTable")) {
    if (!content.includes("validate_lookup") && !content.includes("trusted_table")) {
      findings.push(createFinding3(
        "SOL3124",
        "Address Lookup Table Without Validation",
        "high",
        "Lookup tables can be poisoned with malicious addresses. Validate lookup table contents.",
        { file: input.path },
        "Verify lookup table ownership and validate resolved addresses against expected accounts"
      ));
    }
  }
  if (content.includes("priority") && content.includes("fee")) {
    findings.push(createFinding3(
      "SOL3125",
      "Priority Fee Handling",
      "info",
      "Priority fees can be used for MEV extraction. Ensure users understand fee implications.",
      { file: input.path },
      "Document priority fee behavior and consider implementing fair ordering mechanisms"
    ));
  }
  return findings;
}
function checkBatch69Patterns(input) {
  return [
    ...checkSolendAuthBypass(input),
    ...checkLiquidationThresholdManipulation(input),
    ...checkLiquidationBonusInflation(input),
    ...checkGuardianSignatureBypass(input),
    ...checkVAASpoofing(input),
    ...checkDeprecatedVerifySignatures(input),
    ...checkInfiniteMintCollateral(input),
    ...checkNestedAccountTrust(input),
    ...checkLPTokenValidation(input),
    ...checkFakeTickAccount(input),
    ...checkFeeAccumulatorManipulation(input),
    ...checkFlashLoanFeeClaim(input),
    ...checkSelfTradingOracle(input),
    ...checkUnrealizedPnLCollateral(input),
    ...checkPositionConcentration(input),
    ...checkSeedPhraseLogging(input),
    ...checkUnencryptedKeyStorage(input),
    ...checkTelemetrySensitiveData(input),
    ...checkGovernanceProposalValidation(input),
    ...checkTreasuryPermissionChange(input),
    ...checkBondingCurveFlashLoan2(input),
    ...checkProgramCloseWithFunds(input),
    ...checkIrreversibleAction(input),
    ...checkHotWalletExposure(input),
    ...checkCommingledFunds(input),
    ...checkInsiderAccessControls(input),
    ...checkPrivilegedMonitoring(input),
    ...checkDatabaseInjection(input),
    ...checkSessionTokenSecurity(input),
    ...checkTradingBotKeyStorage(input),
    ...checkBotPaymentValidation(input),
    ...checkSubAccountIsolation(input),
    ...checkSybilProtection(input),
    ...checkHoneypotSellRestriction(input),
    ...checkUnnoticedProposal(input),
    ...checkSupplyChainKeyExfiltration(input),
    ...checkFrontendIntegrity(input),
    ...checkNetworkDoSVulnerability(input),
    ...checkJITCacheVulnerability(input),
    ...checkPTTokenPricing(input),
    ...checkFlashLoanCollateralization(input),
    ...checkWhiteHatRecovery(input),
    ...checkAdvancedSecurityPatterns(input)
  ];
}

// src/patterns/solana-batched-patterns-70.ts
function createFinding4(id, title, severity, description, location, recommendation) {
  return { id, title, severity, description, location, recommendation };
}
function checkStepFinanceKeyCompromise(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("treasury") || content.includes("vault") || content.includes("pool")) {
    if (content.includes("authority") && !content.includes("multisig") && !content.includes("multi_sig")) {
      if (content.includes("withdraw") || content.includes("transfer_all") || content.includes("drain")) {
        findings.push(createFinding4(
          "SOL3126",
          "Single Authority Treasury Access (Step Finance Pattern)",
          "critical",
          "Treasury/vault controlled by single authority without multisig. In Feb 2026, Step Finance lost $30M when hot wallet keys were compromised.",
          { file: input.path },
          "Implement multisig (2-of-3 or higher) for treasury operations. Use hardware wallets for signers."
        ));
      }
    }
  }
  return findings;
}
function checkOwnerPermissionPhishing2(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("set_authority") || content.includes("transfer_authority") || content.includes("change_owner") || content.includes("update_authority")) {
    if (!content.includes("pending_authority") && !content.includes("accept_authority") && !content.includes("two_step") && !content.includes("2_step")) {
      findings.push(createFinding4(
        "SOL3127",
        "Instant Authority Transfer (Phishing Vector)",
        "critical",
        "Authority transfer happens instantly without two-step confirmation. Jan 2026 phishing attacks exploited this to steal $3M+ by tricking users into signing owner transfer transactions.",
        { file: input.path },
        "Implement two-step authority transfer: propose -> accept. Add timelock for critical authority changes."
      ));
    }
    if (!content.includes("emit!") && !content.includes("msg!") && !content.includes("log_authority")) {
      findings.push(createFinding4(
        "SOL3128",
        "Silent Authority Transfer",
        "high",
        "Authority transfers without logging/events are harder to detect. Attackers prefer silent transfers to avoid detection.",
        { file: input.path },
        "Emit events for all authority changes: emit!(AuthorityChanged { old, new, timestamp })"
      ));
    }
  }
  return findings;
}
function checkAccountAssignAttack(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("AccountInfo") || content.includes("UncheckedAccount")) {
    if (content.includes("assign") || content.includes("system_program::assign")) {
      if (!content.includes("constraint = account.owner") && !content.includes("require!(account.owner")) {
        findings.push(createFinding4(
          "SOL3129",
          "Assign Instruction Vulnerability",
          "critical",
          "System program assign instruction can change account ownership. Without proper checks, attackers can reassign account ownership via phishing.",
          { file: input.path },
          "Verify account owner before any sensitive operation. Disallow owned accounts from being reassigned without explicit user confirmation."
        ));
      }
    }
  }
  return findings;
}
function checkSimulationDetectionBypass(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("simulation") || content.includes("preflight") || content.includes("simulate")) {
    if (content.includes("skip_preflight") || content.includes("commitment: processed")) {
      findings.push(createFinding4(
        "SOL3130",
        "Simulation Detection May Be Bypassed",
        "medium",
        "Anti-simulation checks can be bypassed by attackers using skip_preflight or processed commitment. Dont rely solely on simulation detection.",
        { file: input.path },
        "Use on-chain state verification instead of simulation detection for security-critical checks."
      ));
    }
  }
  return findings;
}
function checkPrivacyCoinLaundering(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("bridge") || content.includes("cross_chain") || content.includes("wormhole")) {
    if (!content.includes("kyc") && !content.includes("whitelist") && !content.includes("rate_limit")) {
      findings.push(createFinding4(
        "SOL3131",
        "Cross-Chain Bridge Without Rate Limiting",
        "medium",
        "Bridge without rate limits or whitelisting can be used for rapid fund extraction and laundering (as seen in Step Finance attack where funds were converted to Monero).",
        { file: input.path },
        "Implement rate limiting, withdrawal delays, and consider whitelisting for large transfers."
      ));
    }
  }
  return findings;
}
function checkHotWalletKeyRotation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("hot_wallet") || content.includes("operational_wallet")) {
    if (!content.includes("rotate_key") && !content.includes("key_rotation") && !content.includes("update_signer")) {
      findings.push(createFinding4(
        "SOL3132",
        "No Hot Wallet Key Rotation Mechanism",
        "high",
        "Hot wallets should support key rotation. If keys are compromised, there should be a way to rotate them immediately.",
        { file: input.path },
        "Implement key rotation: allow updating hot wallet authority with proper authorization."
      ));
    }
  }
  return findings;
}
function checkWithdrawalDelayBypass(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("withdraw") && content.includes("delay")) {
    if (content.includes("skip_delay") || content.includes("emergency_withdraw") || content.includes("admin_override")) {
      if (!content.includes("multisig") && !content.includes("timelock_admin")) {
        findings.push(createFinding4(
          "SOL3133",
          "Withdrawal Delay Bypass Without Multisig",
          "critical",
          "Emergency/admin withdrawal bypass without multisig protection. Single compromised key can drain funds instantly.",
          { file: input.path },
          "Require multisig approval for any delay bypass. Consider hardware wallet requirements for emergency actions."
        ));
      }
    }
  }
  return findings;
}
function checkInstructionIntrospection(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("set_authority") || content.includes("transfer_all") || content.includes("close_account")) {
    if (!content.includes("sysvar::instructions") && !content.includes("load_instruction_at") && !content.includes("get_instruction_relative")) {
      findings.push(createFinding4(
        "SOL3134",
        "No Instruction Introspection for Context Verification",
        "medium",
        "Sensitive operations should verify they are not bundled with malicious instructions (phishing attack vector).",
        { file: input.path },
        "Use instruction introspection to verify transaction context for critical operations."
      ));
    }
  }
  return findings;
}
function checkWalletDrainerPattern(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  const drainerPatterns = [
    "remaining_accounts",
    "batch_transfer",
    "sweep_all",
    "collect_all_tokens",
    "drain_wallet"
  ];
  for (const pattern of drainerPatterns) {
    if (content.includes(pattern)) {
      if (!content.includes("require!(signer") && !content.includes("Signer<")) {
        findings.push(createFinding4(
          "SOL3135",
          "Potential Wallet Drainer Pattern",
          "critical",
          `Pattern "${pattern}" detected without signer verification. Could be exploited in phishing attacks to drain wallets.`,
          { file: input.path },
          "Ensure all bulk/sweep operations require explicit signer verification and consider user intent confirmation."
        ));
      }
    }
  }
  return findings;
}
function checkDelegateAuthorityAbuse(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("approve") || content.includes("delegate") || content.includes("delegated_amount")) {
    if (content.includes("u64::MAX") || content.includes("u128::MAX") || content.includes("unlimited")) {
      findings.push(createFinding4(
        "SOL3136",
        "Unlimited Token Delegation",
        "high",
        "Unlimited token approvals create persistent attack surface. If delegate is compromised, all tokens are at risk.",
        { file: input.path },
        "Use minimal necessary approval amounts. Implement approval expiry and revocation mechanisms."
      ));
    }
    if (!content.includes("revoke") && !content.includes("set_delegate_amount(0)")) {
      findings.push(createFinding4(
        "SOL3137",
        "No Delegation Revocation Mechanism",
        "medium",
        "Token delegation without easy revocation. Users should be able to revoke approvals.",
        { file: input.path },
        "Provide clear revocation mechanism: allow setting delegate to None or amount to 0."
      ));
    }
  }
  return findings;
}
function checkTrustedFrontendAssumption(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("/// Frontend") || content.includes("// client") || content.includes("ui_amount")) {
    if (!content.includes("validate") && !content.includes("verify") && !content.includes("check")) {
      findings.push(createFinding4(
        "SOL3138",
        "Trusting Frontend-Provided Data",
        "high",
        "Program appears to trust frontend-provided values. All input must be validated on-chain regardless of source.",
        { file: input.path },
        "Never trust client/frontend input. Validate all parameters in the program regardless of expected source."
      ));
    }
  }
  return findings;
}
function checkMemorySafeLogicUnsafe(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("checked_") && (content.includes("price") || content.includes("rate") || content.includes("collateral"))) {
    if (!content.includes("sanity_check") && !content.includes("bounds_check") && !content.includes("validate_range")) {
      findings.push(createFinding4(
        "SOL3139",
        "Arithmetic Safety Without Business Logic Validation",
        "medium",
        "Using checked arithmetic is good, but business logic sanity checks are also needed (e.g., price within expected range, collateral ratio reasonable).",
        { file: input.path },
        "Add business logic validation: sanity check prices, rates, amounts against expected ranges."
      ));
    }
  }
  return findings;
}
function checkOracleSelfTrading(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("oracle") || content.includes("price_feed") || content.includes("get_price")) {
    if (content.includes("pool_price") || content.includes("amm_price") || content.includes("swap_price")) {
      if (!content.includes("twap") && !content.includes("multiple_sources") && !content.includes("median_price")) {
        findings.push(createFinding4(
          "SOL3140",
          "Single AMM Pool as Oracle (Self-Trading Vulnerability)",
          "critical",
          "Using single AMM pool price as oracle. Attacker can self-trade to manipulate price, borrow against inflated collateral (Mango Markets attack pattern).",
          { file: input.path },
          "Use TWAP, multiple oracle sources, or Pyth/Chainlink. Never rely on single pool spot price."
        ));
      }
    }
  }
  return findings;
}
function checkCLMMTickManipulation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("tick") && (content.includes("liquidity") || content.includes("position"))) {
    if (!content.includes("tick_account.owner") && !content.includes("validate_tick")) {
      findings.push(createFinding4(
        "SOL3141",
        "CLMM Tick Account Without Owner Validation",
        "critical",
        "Concentrated liquidity tick accounts must verify ownership. Crema Finance lost $8.8M when attackers created fake tick accounts.",
        { file: input.path },
        "Verify tick account ownership: require!(tick_account.owner == program_id). Validate tick data integrity."
      ));
    }
    if (content.includes("flash") && !content.includes("lock_tick") && !content.includes("tick_lock")) {
      findings.push(createFinding4(
        "SOL3142",
        "CLMM Tick Manipulation via Flash Loan",
        "high",
        "Flash loans can be used to temporarily manipulate tick positions. Consider tick locking during sensitive operations.",
        { file: input.path },
        "Lock tick state during flash loan operations. Verify tick state consistency before and after."
      ));
    }
  }
  return findings;
}
function checkBondingCurveFlashExploit(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("bonding_curve") || content.includes("bonding") && content.includes("curve")) {
    if (content.includes("mint") || content.includes("buy")) {
      if (!content.includes("flash_guard") && !content.includes("same_slot_check") && !content.includes("cooldown")) {
        findings.push(createFinding4(
          "SOL3143",
          "Bonding Curve Flash Loan Vulnerability",
          "critical",
          "Bonding curves can be exploited via flash loans (Nirvana Finance attack - $3.5M). Attacker flash loans, pumps curve, mints at inflated rate.",
          { file: input.path },
          "Implement flash loan protection: same-slot restrictions, price impact limits, or cooldown periods."
        ));
      }
    }
    if (!content.includes("max_price_impact") && !content.includes("slippage_limit") && !content.includes("price_limit")) {
      findings.push(createFinding4(
        "SOL3144",
        "No Price Impact Limits on Bonding Curve",
        "high",
        "Bonding curve without price impact limits. Large trades can dramatically move price.",
        { file: input.path },
        "Implement price impact limits: max_price_impact_bps, per-trade and per-block limits."
      ));
    }
  }
  return findings;
}
function checkGovernanceTimingAttack(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("governance") || content.includes("proposal") || content.includes("vote")) {
    if (content.includes("execute") || content.includes("finalize")) {
      if (!content.includes("min_voting_period") && !content.includes("quorum_check")) {
        findings.push(createFinding4(
          "SOL3145",
          "Governance Proposal Without Minimum Voting Period",
          "critical",
          "Proposals can be executed too quickly, not giving token holders time to react (Synthetify DAO attack pattern).",
          { file: input.path },
          "Enforce minimum voting period (e.g., 3-7 days) and quorum requirements."
        ));
      }
    }
    if (!content.includes("emit!") && !content.includes("notify") && !content.includes("proposal_created_event")) {
      findings.push(createFinding4(
        "SOL3146",
        "Silent Governance Proposals",
        "high",
        "Proposals without event emission are harder to monitor. Malicious proposals can slip through unnoticed.",
        { file: input.path },
        "Emit events for all proposal lifecycle: ProposalCreated, VoteCast, ProposalExecuted."
      ));
    }
  }
  return findings;
}
function checkRateXPTVulnerability(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("pt_token") || content.includes("principal_token") || content.includes("yield_token")) {
    if (content.includes("collateral") || content.includes("borrow") || content.includes("lending")) {
      if (!content.includes("oracle_price") && !content.includes("market_price") && !content.includes("fair_value")) {
        findings.push(createFinding4(
          "SOL3147",
          "Principal Token Without Proper Pricing Oracle",
          "critical",
          "PT tokens used as collateral without proper pricing mechanism. Loopscale lost $5.8M when RateX PT token was mispriced.",
          { file: input.path },
          "Use reliable oracle for PT token pricing. Consider time-to-maturity and underlying value."
        ));
      }
      if (!content.includes("ltv_check") && !content.includes("collateral_ratio") && !content.includes("health_factor")) {
        findings.push(createFinding4(
          "SOL3148",
          "Missing Collateralization Check for Novel Assets",
          "high",
          "Novel assets (like PT tokens) as collateral need strict LTV monitoring to prevent under-collateralization.",
          { file: input.path },
          "Implement conservative LTV limits for novel collateral types. Add price staleness checks."
        ));
      }
    }
  }
  return findings;
}
function checkTrustWalletStyle(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("wallet") || content.includes("sign") || content.includes("signature")) {
    if (content.includes("random") || content.includes("seed")) {
      if (!content.includes("getrandom") && !content.includes("rand::") && !content.includes("OsRng")) {
        findings.push(createFinding4(
          "SOL3149",
          "Potentially Weak Random Number Generation",
          "critical",
          "Wallet key generation must use cryptographically secure randomness. Weak RNG has led to massive wallet compromises.",
          { file: input.path },
          "Use getrandom or rand::OsRng for all cryptographic operations. Never use weak/predictable RNG."
        ));
      }
    }
    if (content.includes("derive") && content.includes("key")) {
      if (!content.includes("hardened") && !content.includes("'") && !content.includes("BIP44")) {
        findings.push(createFinding4(
          "SOL3150",
          "Non-Hardened Key Derivation",
          "high",
          "Key derivation should use hardened paths to prevent child key compromise from exposing parent keys.",
          { file: input.path },
          "Use hardened derivation paths (m/44h/501h/0h/0h) for wallet key generation."
        ));
      }
    }
  }
  return findings;
}
function checkDDoSProtection(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("rpc") || content.includes("endpoint") || content.includes("request")) {
    if (!content.includes("rate_limit") && !content.includes("throttle") && !content.includes("cooldown")) {
      findings.push(createFinding4(
        "SOL3151",
        "No Rate Limiting for RPC/API Endpoints",
        "medium",
        "Endpoints without rate limiting are vulnerable to DDoS attacks (Phantom Feb 2024 attack pattern).",
        { file: input.path },
        "Implement rate limiting per IP/account. Use circuit breakers for service protection."
      ));
    }
  }
  return findings;
}
function checkSeedPhraseExfiltration(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("mnemonic") || content.includes("seed_phrase") || content.includes("private_key")) {
    if (content.includes("log") || content.includes("trace") || content.includes("debug") || content.includes("telemetry")) {
      findings.push(createFinding4(
        "SOL3152",
        "Sensitive Data Near Logging Code",
        "critical",
        "Seed phrases or private keys should never be near logging code. Slope Wallet lost $8M when seed phrases were inadvertently logged.",
        { file: input.path },
        "Never log or transmit seed phrases/private keys. Use secure memory for sensitive data. Audit all telemetry."
      ));
    }
  }
  return findings;
}
function checkProgramClosePattern(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("program close") || content.includes("close_program") || content.includes("solana program close")) {
    findings.push(createFinding4(
      "SOL3153",
      "Program Close Command Usage",
      "critical",
      "Program close is IRREVERSIBLE and locks all funds in PDAs. OptiFi lost $661K this way. NEVER use in production scripts.",
      { file: input.path },
      "Never use `solana program close` on mainnet. Use upgrade authority instead. Implement peer review for all deployments."
    ));
  }
  if (content.includes("upgrade_authority") || content.includes("BpfUpgradeableLoader")) {
    if (!content.includes("multi_sig") && !content.includes("multisig")) {
      findings.push(createFinding4(
        "SOL3154",
        "Single Upgrade Authority",
        "high",
        "Single upgrade authority creates single point of failure. Compromise leads to malicious program upgrade.",
        { file: input.path },
        "Use multisig for program upgrade authority. Consider Squads or similar for upgrade governance."
      ));
    }
  }
  return findings;
}
function checkCrossChainBridgeVulnerability(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("bridge") || content.includes("cross_chain") || content.includes("cross-chain")) {
    if (!content.includes("verify_message") && !content.includes("validate_vaa") && !content.includes("signature_set")) {
      findings.push(createFinding4(
        "SOL3155",
        "Cross-Chain Message Without Signature Verification",
        "critical",
        "Bridge messages must be cryptographically verified. NoOnes lost $8M in Jan 2025 due to bridge vulnerability.",
        { file: input.path },
        "Verify all cross-chain messages with guardian/validator signatures. Use established bridge SDKs."
      ));
    }
    if (!content.includes("nonce") && !content.includes("sequence") && !content.includes("replay_protection")) {
      findings.push(createFinding4(
        "SOL3156",
        "Bridge Without Replay Protection",
        "critical",
        "Cross-chain messages can be replayed if no nonce/sequence tracking. Each message should only be processed once.",
        { file: input.path },
        "Implement sequence/nonce tracking for bridge messages. Mark messages as processed after execution."
      ));
    }
  }
  return findings;
}
function checkTradingBotVulnerability(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("bot") || content.includes("sniper") || content.includes("auto_trade")) {
    if (content.includes("user_balance") || content.includes("deposit")) {
      if (!content.includes("isolated") && !content.includes("segregated") && !content.includes("per_user_vault")) {
        findings.push(createFinding4(
          "SOL3157",
          "Trading Bot Without Fund Isolation",
          "critical",
          "Trading bot funds should be isolated per user. Banana Gun ($1.4M) and DEXX ($30M) exploits targeted shared/hot wallet funds.",
          { file: input.path },
          "Use per-user PDAs for fund storage. Never commingle user funds in hot wallets."
        ));
      }
    }
    if (!content.includes("encrypted_key") && !content.includes("secure_enclave") && !content.includes("vault_service")) {
      findings.push(createFinding4(
        "SOL3158",
        "Trading Bot Key Storage Concerns",
        "high",
        "Bot private keys stored without encryption. DEXX lost $30M due to private key exposure.",
        { file: input.path },
        "Use encrypted key storage, HSMs, or secure enclaves. Never store plaintext keys."
      ));
    }
  }
  return findings;
}
function checkBondingCurveLiquidityManipulation(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("bonding_curve") || content.includes("liquidity_pool") || content.includes("market_cap")) {
    if (content.includes("service_wallet") || content.includes("5PXxuZ") || content.includes("internal_wallet")) {
      findings.push(createFinding4(
        "SOL3159",
        "Privileged Service Wallet Pattern",
        "critical",
        "Internal service wallets with privileged access are attack vectors. Pump.fun lost $2M when employee exploited service wallet.",
        { file: input.path },
        "Minimize service wallet privileges. Use multisig. Implement time-locked actions for sensitive operations."
      ));
    }
    if (content.includes("withdraw_liquidity") || content.includes("remove_liquidity")) {
      if (!content.includes("lock_period") && !content.includes("time_lock") && !content.includes("vesting")) {
        findings.push(createFinding4(
          "SOL3160",
          "Liquidity Removal Without Time Lock",
          "high",
          "Liquidity can be removed instantly, enabling rug pulls or flash loan attacks.",
          { file: input.path },
          "Implement liquidity lock periods, especially for protocol-owned liquidity."
        ));
      }
    }
  }
  return findings;
}
function checkAdvancedDeFiPatterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("oracle") || content.includes("price_feed")) {
    if (!content.includes("staleness") && !content.includes("last_update") && !content.includes("max_age")) {
      findings.push(createFinding4(
        "SOL3161",
        "Oracle Without Staleness Check",
        "high",
        "Using stale oracle prices can lead to exploits during network congestion or oracle downtime.",
        { file: input.path },
        "Check oracle timestamp: require!(Clock::get()?.unix_timestamp - oracle.last_update < MAX_STALENESS)"
      ));
    }
  }
  if (content.includes("interest_rate") || content.includes("borrow_rate")) {
    if (!content.includes("min_rate") && !content.includes(">= 0") && !content.includes("saturating")) {
      findings.push(createFinding4(
        "SOL3162",
        "Interest Rate Without Floor",
        "medium",
        "Interest rates should have a minimum floor to prevent negative rates in edge cases.",
        { file: input.path },
        "Implement minimum interest rate floor: rate = max(calculated_rate, MIN_RATE)"
      ));
    }
  }
  if (content.includes("liquidate") || content.includes("liquidation")) {
    if (!content.includes("partial_liquidation") && !content.includes("max_liquidation_percent")) {
      findings.push(createFinding4(
        "SOL3163",
        "Full Liquidation Without Partial Option",
        "medium",
        "Allowing only full liquidations can cause cascade liquidations during volatile markets.",
        { file: input.path },
        "Implement partial liquidations with configurable max percentage (e.g., 50% per liquidation)."
      ));
    }
  }
  if (content.includes("redeem") || content.includes("redemption")) {
    if (!content.includes("min_output") && !content.includes("slippage") && !content.includes("deadline")) {
      findings.push(createFinding4(
        "SOL3164",
        "Redemption Without Slippage Protection",
        "high",
        "Redemptions without minimum output can be sandwiched for MEV extraction.",
        { file: input.path },
        "Add min_output_amount parameter and validate: require!(output >= min_output)"
      ));
    }
  }
  if (content.includes("lp_token") && content.includes("price")) {
    if (!content.includes("fair_lp_price") && !content.includes("underlying_value") && !content.includes("reserve_ratio")) {
      findings.push(createFinding4(
        "SOL3165",
        "LP Token Without Fair Pricing",
        "critical",
        "LP token pricing must use fair pricing formula based on reserves, not spot price (OtterSec $200M at risk finding).",
        { file: input.path },
        "Use fair LP pricing: lp_price = sqrt(reserve0 * reserve1) / total_supply"
      ));
    }
  }
  if (content.includes("vault") && (content.includes("shares") || content.includes("deposit"))) {
    if (content.includes("first_deposit") || content.includes("initial_deposit")) {
      if (!content.includes("min_shares") && !content.includes("dead_shares") && !content.includes("virtual_shares")) {
        findings.push(createFinding4(
          "SOL3166",
          "First Deposit Share Manipulation",
          "high",
          "First depositor can manipulate share price by depositing tiny amount then donating tokens.",
          { file: input.path },
          "Use virtual shares or require minimum first deposit to prevent share price manipulation."
        ));
      }
    }
  }
  if (content.includes("leverage") || content.includes("margin")) {
    if (!content.includes("max_leverage") && !content.includes("leverage_limit")) {
      findings.push(createFinding4(
        "SOL3167",
        "No Maximum Leverage Limit",
        "high",
        "Unlimited leverage creates systemic risk during volatile markets (see $258M Solana whale liquidation).",
        { file: input.path },
        "Set maximum leverage limits based on asset volatility and liquidity."
      ));
    }
  }
  if (content.includes("insurance") || content.includes("insurance_fund")) {
    if (!content.includes("min_insurance") && !content.includes("insurance_ratio")) {
      findings.push(createFinding4(
        "SOL3168",
        "Insurance Fund Without Minimum Threshold",
        "medium",
        "Insurance fund should maintain minimum ratio to total protocol TVL for protection.",
        { file: input.path },
        "Set minimum insurance fund ratio (e.g., 5% of TVL) and halt risky operations when below threshold."
      ));
    }
  }
  if (content.includes("swap") || content.includes("trade") || content.includes("order")) {
    if (!content.includes("private") && !content.includes("commit_reveal") && !content.includes("batch")) {
      findings.push(createFinding4(
        "SOL3169",
        "Trade Without MEV Protection",
        "medium",
        "Trades without MEV protection can be front-run or sandwiched. Consider private mempools or batch auctions.",
        { file: input.path },
        "Consider Jito bundles for MEV protection, commit-reveal schemes, or batch auction mechanisms."
      ));
    }
  }
  if (content.includes("protocol") || content.includes("pool")) {
    if (!content.includes("circuit_breaker") && !content.includes("pause") && !content.includes("emergency_stop")) {
      findings.push(createFinding4(
        "SOL3170",
        "No Circuit Breaker Mechanism",
        "high",
        "Protocols need circuit breakers to halt operations during attacks or extreme volatility.",
        { file: input.path },
        "Implement pausable pattern with authorized pausers and automatic triggers for anomalies."
      ));
    }
  }
  return findings;
}
function check2026EmergingPatterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("agent") || content.includes("ai_wallet") || content.includes("autonomous")) {
    if (!content.includes("spending_limit") && !content.includes("allowance")) {
      findings.push(createFinding4(
        "SOL3171",
        "AI Agent Without Spending Limits",
        "high",
        "AI agents controlling wallets should have strict spending limits to prevent runaway transactions.",
        { file: input.path },
        "Implement per-transaction and daily spending limits for AI-controlled wallets."
      ));
    }
  }
  if (content.includes("compressed") || content.includes("merkle_tree") || content.includes("bubblegum")) {
    if (!content.includes("verify_leaf") && !content.includes("verify_proof")) {
      findings.push(createFinding4(
        "SOL3172",
        "cNFT Without Merkle Proof Verification",
        "critical",
        "Compressed NFTs must verify merkle proofs to prevent fake asset claims.",
        { file: input.path },
        "Always verify merkle proofs for cNFT operations using Bubblegum CPI."
      ));
    }
  }
  if (content.includes("token_2022") || content.includes("Token2022") || content.includes("token-2022")) {
    if (content.includes("transfer_hook") && !content.includes("validate_hook")) {
      findings.push(createFinding4(
        "SOL3173",
        "Token-2022 Transfer Hook Without Validation",
        "high",
        "Transfer hooks can contain malicious logic. Validate hook program before accepting Token-2022 tokens.",
        { file: input.path },
        "Whitelist approved transfer hooks or verify hook program source."
      ));
    }
    if (content.includes("confidential") && !content.includes("audit_trail")) {
      findings.push(createFinding4(
        "SOL3174",
        "Confidential Transfers Without Audit Capability",
        "medium",
        "Confidential transfers complicate compliance. Ensure audit trail capabilities if needed.",
        { file: input.path },
        "Consider compliance requirements for confidential transfer implementations."
      ));
    }
  }
  if (content.includes("blink") || content.includes("actions.json") || content.includes("action_url")) {
    if (!content.includes("action_identity") && !content.includes("verify_action_url")) {
      findings.push(createFinding4(
        "SOL3175",
        "Solana Action Without Identity Verification",
        "high",
        "Solana Actions (Blinks) should verify action provider identity to prevent phishing.",
        { file: input.path },
        "Verify action provider identity. Display clear transaction details before signing."
      ));
    }
  }
  if (content.includes("stake") || content.includes("validator")) {
    if (content.includes("delegate") && !content.includes("diversify") && !content.includes("max_single_validator")) {
      findings.push(createFinding4(
        "SOL3176",
        "Stake Delegation Without Concentration Limits",
        "medium",
        "Delegating all stake to single validator creates concentration risk. Top validators control 43% of stake.",
        { file: input.path },
        "Diversify stake across multiple validators. Set maximum per-validator limits."
      ));
    }
  }
  if (content.includes("jito") || content.includes("mev") || content.includes("bundle")) {
    if (!content.includes("fallback") && !content.includes("alternative_client")) {
      findings.push(createFinding4(
        "SOL3177",
        "Jito Dependency Without Fallback",
        "low",
        "Jito client has 88% validator dominance. Consider fallback options for client diversity.",
        { file: input.path },
        "Implement fallback to standard client if Jito services are unavailable."
      ));
    }
  }
  if (content.includes("rwa") || content.includes("real_world_asset") || content.includes("tokenized")) {
    if (!content.includes("off_chain_verification") && !content.includes("attestation")) {
      findings.push(createFinding4(
        "SOL3178",
        "RWA Without Off-Chain Attestation",
        "high",
        "Tokenized real-world assets need trusted attestation for backing verification.",
        { file: input.path },
        "Implement oracle-based attestation for RWA backing. Use trusted attesters or ZK proofs."
      ));
    }
  }
  if (content.includes("yield") && content.includes("aggregate")) {
    if (!content.includes("route_verification") && !content.includes("max_hops")) {
      findings.push(createFinding4(
        "SOL3179",
        "Yield Aggregator Without Route Limits",
        "medium",
        "Complex yield routes increase attack surface and gas costs. Limit route complexity.",
        { file: input.path },
        "Set maximum hops for yield routes. Verify each protocol in the route is trusted."
      ));
    }
  }
  if (content.includes("social_recovery") || content.includes("guardian")) {
    if (!content.includes("threshold") && !content.includes("m_of_n")) {
      findings.push(createFinding4(
        "SOL3180",
        "Social Recovery Without Threshold",
        "high",
        "Social recovery should require threshold of guardians, not single guardian approval.",
        { file: input.path },
        "Implement m-of-n guardian scheme (e.g., 3-of-5) for social recovery."
      ));
    }
  }
  return findings;
}
function checkProtocolSpecificPatterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("lending") || content.includes("borrow")) {
    if (content.includes("round") && !content.includes("round_down") && !content.includes("floor")) {
      findings.push(createFinding4(
        "SOL3181",
        "Lending Protocol Rounding Direction",
        "high",
        "Lending protocols must round against user: interest up, collateral down (Neodyme $2.6B at risk finding).",
        { file: input.path },
        "Always round in protocol favor: interest = ceil(calculated), collateral_value = floor(calculated)"
      ));
    }
  }
  if (content.includes("stake_pool") || content.includes("StakePool")) {
    if (content.includes("withdraw") && !content.includes("consistent_withdraw")) {
      findings.push(createFinding4(
        "SOL3182",
        "Stake Pool Semantic Inconsistency Risk",
        "medium",
        "Stake pool operations should have consistent semantics (Sec3 Stake Pool vulnerability).",
        { file: input.path },
        "Ensure withdraw/deposit semantics are consistent. Document expected behavior clearly."
      ));
    }
  }
  if (content.includes("metaplex") || content.includes("Metadata") || content.includes("nft")) {
    if (content.includes("creator") && !content.includes("verified_creator") && !content.includes("is_verified")) {
      findings.push(createFinding4(
        "SOL3183",
        "NFT Creator Without Verification Check",
        "high",
        "NFT creator addresses should check is_verified flag. Anyone can add themselves as unverified creator.",
        { file: input.path },
        "Check creator.verified == true when validating NFT authenticity."
      ));
    }
  }
  if (content.includes("unstake") || content.includes("withdrawal_delay")) {
    if (!content.includes("epoch_delay") && !content.includes("cooling_period")) {
      findings.push(createFinding4(
        "SOL3184",
        "Liquid Staking Without Proper Delay",
        "medium",
        "Liquid staking should mirror native staking delays to prevent instant arbitrage.",
        { file: input.path },
        "Implement epoch-based delay for unstaking operations."
      ));
    }
  }
  if (content.includes("whirlpool") || content.includes("concentrated_liquidity")) {
    if (content.includes("tick_array") && !content.includes("verify_tick_array_pda")) {
      findings.push(createFinding4(
        "SOL3185",
        "Whirlpool Tick Array Without PDA Verification",
        "high",
        "Tick arrays should be verified as PDAs derived from the pool.",
        { file: input.path },
        'Verify tick array PDAs: seeds = ["tick_array", pool, tick_index]'
      ));
    }
  }
  if (content.includes("order_book") || content.includes("phoenix") || content.includes("limit_order")) {
    if (!content.includes("self_trade_prevention") && !content.includes("wash_trading")) {
      findings.push(createFinding4(
        "SOL3186",
        "Order Book Without Self-Trade Prevention",
        "medium",
        "Order books should prevent self-trading to avoid wash trading and manipulation.",
        { file: input.path },
        "Implement self-trade prevention: check maker != taker for all matches."
      ));
    }
  }
  if (content.includes("oracle") && content.includes("perp")) {
    if (!content.includes("oracle_guardrail") && !content.includes("price_band")) {
      findings.push(createFinding4(
        "SOL3187",
        "Perpetual Without Oracle Guardrails",
        "high",
        "Perpetual protocols need oracle guardrails to prevent manipulation (Drift protocol pattern).",
        { file: input.path },
        "Implement price bands: require oracle price within X% of mark price."
      ));
    }
  }
  if (content.includes("aggregator") || content.includes("route") || content.includes("jupiter")) {
    if (!content.includes("verify_route") && !content.includes("trusted_amm")) {
      findings.push(createFinding4(
        "SOL3188",
        "DEX Aggregator Without Route Verification",
        "high",
        "Aggregator routes should only include verified/trusted AMMs to prevent malicious swaps.",
        { file: input.path },
        "Maintain allowlist of trusted AMM programs. Verify each hop in aggregation route."
      ));
    }
  }
  if (content.includes("pyth") || content.includes("price_account")) {
    if (content.includes("price") && !content.includes("confidence") && !content.includes("conf")) {
      findings.push(createFinding4(
        "SOL3189",
        "Pyth Oracle Without Confidence Check",
        "high",
        "Pyth prices have confidence intervals. Wide confidence indicates uncertain price.",
        { file: input.path },
        "Check Pyth confidence: require!(price.conf / price.price < MAX_CONFIDENCE_RATIO)"
      ));
    }
  }
  if (content.includes("switchboard") || content.includes("aggregator_account")) {
    if (!content.includes("min_oracle_results") && !content.includes("result_count")) {
      findings.push(createFinding4(
        "SOL3190",
        "Switchboard Without Minimum Results",
        "medium",
        "Switchboard aggregators should require minimum oracle responses for reliability.",
        { file: input.path },
        "Check aggregator has sufficient responses: require!(result_count >= MIN_REQUIRED)"
      ));
    }
  }
  if (content.includes("squads") || content.includes("multisig")) {
    if (content.includes("execute") && !content.includes("threshold_check")) {
      findings.push(createFinding4(
        "SOL3191",
        "Multisig Execute Without Threshold Verification",
        "critical",
        "Multisig execution must verify threshold signatures are met.",
        { file: input.path },
        "Verify signature count meets threshold before executing multisig transactions."
      ));
    }
  }
  if (content.includes("emit!") || content.includes("Event")) {
    if (content.includes("amount") || content.includes("value")) {
      findings.push(createFinding4(
        "SOL3192",
        "Event Emission Without State Verification",
        "low",
        "Events should reflect actual state changes, not just input parameters.",
        { file: input.path },
        "Emit events after state mutation, using actual resulting values."
      ));
    }
  }
  if (content.includes("cpi_guard") || content.includes("CpiGuard")) {
    if (!content.includes("toggle_off") && !content.includes("disable_guard")) {
      findings.push(createFinding4(
        "SOL3193",
        "CPI Guard Without Disable Option",
        "info",
        "CPI guard should have authorized disable for legitimate use cases.",
        { file: input.path },
        "Allow authorized users to toggle CPI guard when needed for legitimate protocols."
      ));
    }
  }
  if (content.includes("token_account") || content.includes("TokenAccount")) {
    if (content.includes("authority") && !content.includes("delegate") && !content.includes("close_authority")) {
      findings.push(createFinding4(
        "SOL3194",
        "Token Account Authority Incomplete Check",
        "medium",
        "Token accounts have owner, delegate, and close_authority. Check all relevant authorities.",
        { file: input.path },
        "Verify all token account authority fields as needed: owner, delegate, close_authority."
      ));
    }
  }
  if (content.includes("account") && content.includes("close")) {
    if (!content.includes("rent_epoch") && !content.includes("data_is_empty")) {
      findings.push(createFinding4(
        "SOL3195",
        "Account Close Without Rent Epoch Check",
        "low",
        "Check rent_epoch for account lifecycle patterns to detect account resurrection.",
        { file: input.path },
        "Monitor rent_epoch changes for security-sensitive account operations."
      ));
    }
  }
  if (content.includes("lamports") && content.includes("token")) {
    if (!content.includes("native_mint") && !content.includes("NATIVE_MINT")) {
      findings.push(createFinding4(
        "SOL3196",
        "Native SOL Handling May Be Missing",
        "low",
        "Programs handling tokens should also handle native SOL (WSOL) cases.",
        { file: input.path },
        "Handle native SOL: check for NATIVE_MINT and sync_native for wrapped SOL."
      ));
    }
  }
  if (content.includes("realloc") || content.includes("resize")) {
    if (!content.includes("MAX_PERMITTED_DATA_INCREASE") && !content.includes("max_size")) {
      findings.push(createFinding4(
        "SOL3197",
        "Account Reallocation Without Size Limit",
        "medium",
        "Account reallocation should respect MAX_PERMITTED_DATA_INCREASE (10KB per transaction).",
        { file: input.path },
        "Limit reallocation: require!(new_size - old_size <= 10240)"
      ));
    }
  }
  if (content.includes("compute") || content.includes("cu_limit")) {
    if (!content.includes("estimate_compute") && !content.includes("set_compute_unit_limit")) {
      findings.push(createFinding4(
        "SOL3198",
        "Missing Compute Unit Estimation",
        "low",
        "Complex operations should estimate compute units to avoid transaction failures.",
        { file: input.path },
        "Estimate and set appropriate compute unit limits for complex transactions."
      ));
    }
  }
  if (content.includes("v0") || content.includes("versioned")) {
    if (content.includes("lookup_table") && !content.includes("verify_table_authority")) {
      findings.push(createFinding4(
        "SOL3199",
        "Lookup Table Without Authority Verification",
        "high",
        "Address lookup tables can be modified by authority. Verify table authority or use immutable tables.",
        { file: input.path },
        "Freeze lookup tables after creation or verify authority before each use."
      ));
    }
  }
  if (content.includes("recent_blockhash") || content.includes("blockhash")) {
    if (!content.includes("get_latest_blockhash") && !content.includes("blockhash_valid")) {
      findings.push(createFinding4(
        "SOL3200",
        "Blockhash Freshness Not Verified",
        "low",
        "Transactions with old blockhashes will fail. Use recent blockhashes (< 150 slots old).",
        { file: input.path },
        "Always fetch fresh blockhash before signing. Consider durable nonces for long-lived transactions."
      ));
    }
  }
  return findings;
}
function checkBatch70Patterns(input) {
  return [
    ...checkStepFinanceKeyCompromise(input),
    ...checkOwnerPermissionPhishing2(input),
    ...checkAccountAssignAttack(input),
    ...checkSimulationDetectionBypass(input),
    ...checkPrivacyCoinLaundering(input),
    ...checkHotWalletKeyRotation(input),
    ...checkWithdrawalDelayBypass(input),
    ...checkInstructionIntrospection(input),
    ...checkWalletDrainerPattern(input),
    ...checkDelegateAuthorityAbuse(input),
    ...checkTrustedFrontendAssumption(input),
    ...checkMemorySafeLogicUnsafe(input),
    ...checkOracleSelfTrading(input),
    ...checkCLMMTickManipulation(input),
    ...checkBondingCurveFlashExploit(input),
    ...checkGovernanceTimingAttack(input),
    ...checkRateXPTVulnerability(input),
    ...checkTrustWalletStyle(input),
    ...checkDDoSProtection(input),
    ...checkSeedPhraseExfiltration(input),
    ...checkProgramClosePattern(input),
    ...checkCrossChainBridgeVulnerability(input),
    ...checkTradingBotVulnerability(input),
    ...checkBondingCurveLiquidityManipulation(input),
    ...checkAdvancedDeFiPatterns(input),
    ...check2026EmergingPatterns(input),
    ...checkProtocolSpecificPatterns(input)
  ];
}

// src/patterns/solana-batched-patterns-71.ts
function createFinding5(id, title, severity, description, location, recommendation) {
  return { id, title, severity, description, location, recommendation };
}
function checkMissingSignerCheck(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  const lines = content.split("\n");
  if (content.includes("AccountInfo") && !content.includes("Signer<")) {
    if ((content.includes("authority") || content.includes("admin") || content.includes("owner")) && !content.includes(".is_signer") && !content.includes("is_signer()")) {
      findings.push(createFinding5(
        "SOL3201",
        "AccountInfo Without Signer Verification (Solend Pattern)",
        "critical",
        "Using AccountInfo for authority without is_signer check. Solend Aug 2021: attacker passed admin pubkey without signing, nearly stole $2M.",
        { file: input.path },
        "Use Signer<'info> in Anchor, or verify: if !authority.is_signer() { return Err(ProgramError::MissingRequiredSignature); }"
      ));
    }
  }
  lines.forEach((line, idx) => {
    if ((line.includes("withdraw") || line.includes("transfer_from")) && !content.includes("require_signer") && !content.includes("Signer<")) {
      if (line.includes("authority") || line.includes("from")) {
        findings.push(createFinding5(
          "SOL3202",
          "Withdrawal Operation Missing Signer Check",
          "critical",
          "Fund withdrawal operations must verify the signer. Pattern: attacker passes pubkey without owning private key.",
          { file: input.path, line: idx + 1 },
          "Add explicit signer requirement: pub authority: Signer<'info>"
        ));
      }
    }
  });
  if ((content.includes("update_config") || content.includes("set_param") || content.includes("admin_")) && !content.includes("Signer<") && !content.includes("is_signer")) {
    findings.push(createFinding5(
      "SOL3203",
      "Admin Function Without Signer Verification",
      "critical",
      "Administrative functions must verify signer ownership. Attackers can call admin functions by just knowing the admin pubkey.",
      { file: input.path },
      "All admin functions need: #[access_control(admin_check(...))] or Signer<'info>"
    ));
  }
  if (content.includes("if authority.key() ==") && !content.includes("is_signer")) {
    findings.push(createFinding5(
      "SOL3204",
      "Key Comparison Without Signer Check",
      "critical",
      "Checking key equality is not enough - anyone can pass any pubkey. Must also verify is_signer.",
      { file: input.path },
      "Always combine: authority.key() == expected_key && authority.is_signer()"
    ));
  }
  const structMatches = content.match(/pub struct \w+<'info>\s*\{[^}]+\}/g);
  if (structMatches) {
    structMatches.forEach((struct) => {
      if ((struct.includes("authority") || struct.includes("admin") || struct.includes("payer")) && !struct.includes("Signer<'info>")) {
        findings.push(createFinding5(
          "SOL3205",
          "Account Struct Authority Without Signer Type",
          "high",
          "Authority/admin accounts in instruction context should use Signer<'info> type for automatic verification.",
          { file: input.path },
          "Change: pub authority: AccountInfo<'info> \u2192 pub authority: Signer<'info>"
        ));
      }
    });
  }
  return findings;
}
function checkMissingOwnerCheck(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("AccountInfo") && !content.includes("Account<")) {
    if (!content.includes(".owner") && !content.includes("owner()") && !content.includes("owner ==") && !content.includes("owner !=")) {
      if (content.includes("data") || content.includes("deserialize") || content.includes("try_from_slice")) {
        findings.push(createFinding5(
          "SOL3206",
          "Account Data Read Without Owner Verification (Crema Pattern)",
          "critical",
          "Reading account data without verifying owner. Crema Finance ($8.8M): attacker created fake tick accounts with false price data.",
          { file: input.path },
          "Verify owner: if account.owner() != program_id { return Err(ProgramError::IllegalOwner); }"
        ));
      }
    }
  }
  if (content.includes("UncheckedAccount") || content.includes("/// CHECK:")) {
    findings.push(createFinding5(
      "SOL3207",
      "UncheckedAccount May Skip Owner Validation",
      "high",
      "UncheckedAccount bypasses Anchor's automatic owner checks. Manual verification required.",
      { file: input.path },
      "If using UncheckedAccount, add explicit owner check: require!(account.owner == &expected_program)"
    ));
  }
  if (content.includes("price") || content.includes("oracle") || content.includes("feed")) {
    if (!content.includes("owner ==") && !content.includes("pyth") && !content.includes("switchboard")) {
      findings.push(createFinding5(
        "SOL3208",
        "Price/Oracle Account Without Owner Verification",
        "critical",
        "Oracle accounts must verify owner is the expected oracle program. Attackers can create fake oracle accounts with manipulated prices.",
        { file: input.path },
        "Verify: price_account.owner == &pyth_program_id OR use verified oracle libraries"
      ));
    }
  }
  if (content.includes("TokenAccount") || content.includes("token::Token")) {
    if (content.includes("owner") && !content.includes("token_account.owner")) {
      findings.push(createFinding5(
        "SOL3209",
        "Token Account Owner Field Confusion",
        "medium",
        "Token accounts have both an account owner (Token Program) and a data owner field. Ensure you're checking the right one.",
        { file: input.path },
        "Account owner = Token Program; Data owner = wallet that controls tokens. Verify both as needed."
      ));
    }
  }
  if (content.includes("system_program") && content.includes("transfer")) {
    if (!content.includes("Account<") && content.includes("AccountInfo")) {
      findings.push(createFinding5(
        "SOL3210",
        "SystemProgram Transfer Without Type Safety",
        "high",
        "System program operations should use typed accounts. Raw AccountInfo can accept fake system-owned accounts.",
        { file: input.path },
        "Use: pub system_program: Program<'info, System> instead of AccountInfo"
      ));
    }
  }
  return findings;
}
function checkAccountDataMatching(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("TokenAccount") || content.includes("token_account")) {
    if (!content.includes("constraint = ") && !content.includes(".mint ==") && !content.includes("mint ==")) {
      if (!content.includes("mint =")) {
        findings.push(createFinding5(
          "SOL3211",
          "Token Account Without Mint Constraint (Solend Pattern)",
          "critical",
          "Token account accepted without verifying mint. Solend Nov 2022: attacker substituted manipulatable USDH pool, inflated price from $1 to $8.80.",
          { file: input.path },
          "Add constraint: #[account(constraint = token_account.mint == expected_mint)]"
        ));
      }
    }
  }
  if (content.includes("pool") && content.includes("token")) {
    if (!content.includes("pool.token_account") && !content.includes("token_account == pool")) {
      findings.push(createFinding5(
        "SOL3212",
        "Pool-Token Account Relationship Not Verified",
        "high",
        "Pool and token account relationship must be validated. Attackers can substitute their own controlled accounts.",
        { file: input.path },
        "Validate: require!(user_token.key() == pool.token_account)"
      ));
    }
  }
  if (content.includes("oracle") || content.includes("price_feed")) {
    if (!content.includes("has_one") && !content.includes("constraint =") && !content.includes("feed_id") && !content.includes("price_feed ==")) {
      findings.push(createFinding5(
        "SOL3213",
        "Oracle Feed Source Not Validated",
        "critical",
        "Oracle feed must be the specific expected feed, not just any valid oracle account.",
        { file: input.path },
        "Add: #[account(constraint = oracle.key() == expected_oracle_pubkey)]"
      ));
    }
  }
  if (content.includes("user") && (content.includes("vault") || content.includes("position"))) {
    if (!content.includes("has_one = user") && !content.includes("user.key()")) {
      findings.push(createFinding5(
        "SOL3214",
        "User-Owned Account Relationship Not Verified",
        "high",
        "User's vault/position must verify the user relationship. Attackers may access other users' accounts.",
        { file: input.path },
        "Add: #[account(has_one = user)] or constraint = vault.owner == user.key()"
      ));
    }
  }
  if (content.includes("price") && !content.includes("twap") && !content.includes("aggregate")) {
    if (content.match(/oracle|price_feed/gi)?.length === 1) {
      findings.push(createFinding5(
        "SOL3215",
        "Single Oracle Price Source",
        "high",
        "Using single price source is vulnerable to manipulation. Solend attack used single Saber pool while keeping Orca price stable.",
        { file: input.path },
        "Use multiple price sources: aggregate(pyth_price, switchboard_price) or implement TWAP"
      ));
    }
  }
  return findings;
}
function checkTypeCosplay(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("try_from_slice") || content.includes("deserialize")) {
    if (!content.includes("discriminator") && !content.includes("[0..8]")) {
      findings.push(createFinding5(
        "SOL3216",
        "Manual Deserialization Without Discriminator Check",
        "critical",
        "Deserializing account data without checking discriminator. Attacker can pass different account type with aligned fields.",
        { file: input.path },
        "Check first 8 bytes: if &data[0..8] != EXPECTED_DISCRIMINATOR { return Err(...) }"
      ));
    }
  }
  if (content.includes("AccountInfo") && content.includes("as *const")) {
    findings.push(createFinding5(
      "SOL3217",
      "Unsafe AccountInfo Casting",
      "critical",
      "Casting AccountInfo data directly is dangerous. Different account types may have overlapping memory layouts.",
      { file: input.path },
      "Use Anchor Account<'info, T> or verify discriminator before casting"
    ));
  }
  const structDefs = content.match(/#\[account\]\s*pub struct \w+ \{[^}]+\}/g);
  if (structDefs && structDefs.length >= 2) {
    const patterns = structDefs.map((s) => {
      const fields = s.match(/pub \w+: (Pubkey|u64|u8|bool)/g);
      return fields?.join(",");
    });
    if (new Set(patterns).size < patterns.length) {
      findings.push(createFinding5(
        "SOL3218",
        "Account Types With Similar Layouts (Cosplay Risk)",
        "medium",
        "Multiple account types have similar field layouts. Ensure discriminators are unique and always checked.",
        { file: input.path },
        "Anchor automatically adds discriminators, but verify custom types have unique first 8 bytes"
      ));
    }
  }
  if (content.includes("AccountInfo") && !content.includes("#[derive(Accounts)]")) {
    if (content.includes("borrow_mut") || content.includes("borrow()")) {
      findings.push(createFinding5(
        "SOL3219",
        "Raw Account Access Without Framework Protection",
        "high",
        "Accessing account data without Anchor's type system increases type cosplay risk.",
        { file: input.path },
        "Use Account<'info, T> or implement discriminator checks manually"
      ));
    }
  }
  if (content.includes("[0u8; 8]") || content.includes("== [0, 0, 0")) {
    findings.push(createFinding5(
      "SOL3220",
      "Zero Discriminator May Allow Uninitialized Accounts",
      "high",
      "Checking for zero discriminator may accept uninitialized accounts.",
      { file: input.path },
      "Use non-zero discriminators and check for initialization flag separately"
    ));
  }
  return findings;
}
function checkBumpCanonicalization(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("bump") && content.includes("instruction_data")) {
    if (!content.includes("find_program_address") && !content.includes("canonical")) {
      findings.push(createFinding5(
        "SOL3221",
        "User-Provided Bump Without Canonicalization",
        "critical",
        "Accepting bump from user input allows creation of shadow PDAs at different addresses.",
        { file: input.path },
        "Always use find_program_address to get canonical bump, or store and verify bump in account"
      ));
    }
  }
  if (content.includes("create_program_address") || content.includes("pda")) {
    if (content.includes("seeds") && !content.includes("bump") && !content.includes("nonce")) {
      findings.push(createFinding5(
        "SOL3222",
        "PDA Bump Not Stored For Verification",
        "high",
        "Without storing canonical bump, subsequent operations may accept non-canonical PDAs.",
        { file: input.path },
        "Store bump in account: pub bump: u8, and verify on access: seeds = [..., &[account.bump]]"
      ));
    }
  }
  if (content.includes("create_program_address") && !content.includes("find_program_address")) {
    findings.push(createFinding5(
      "SOL3223",
      "create_program_address Without find_program_address",
      "medium",
      "create_program_address can succeed with non-canonical bumps. Use find_program_address to get canonical bump first.",
      { file: input.path },
      "Use find_program_address for initialization, store bump, verify with create_program_address"
    ));
  }
  if (content.includes("#[account(") && content.includes("seeds =")) {
    if (!content.includes("bump")) {
      findings.push(createFinding5(
        "SOL3224",
        "Anchor Seeds Without Bump Constraint",
        "medium",
        "PDA seeds should include bump constraint for verification. Anchor will use canonical bump.",
        { file: input.path },
        "Add bump constraint: seeds = [...], bump or seeds = [...], bump = account.bump"
      ));
    }
  }
  if (content.includes("init") && content.includes("pda")) {
    if (content.includes("bump =") && content.includes("ctx.bumps")) {
    } else if (!content.includes("bump")) {
      findings.push(createFinding5(
        "SOL3225",
        "PDA Initialization Without Canonical Bump",
        "high",
        "PDA initialization should use canonical bump from ctx.bumps to prevent shadow accounts.",
        { file: input.path },
        "Use: bump = ctx.bumps.account_name in Anchor"
      ));
    }
  }
  return findings;
}
function checkReinitialization(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("initialize") || content.includes("init_")) {
    if (!content.includes("init,") && !content.includes("init_if_needed")) {
      if (!content.includes("is_initialized") && !content.includes("discriminator")) {
        findings.push(createFinding5(
          "SOL3226",
          "Initialize Function Without Existence Check",
          "critical",
          "Initialize can be called on existing accounts, overwriting data. Attacker can reset authority to themselves.",
          { file: input.path },
          "Use Anchor init (fails if exists) or check: if account.is_initialized { return Err(...) }"
        ));
      }
    }
  }
  if (content.includes("init_if_needed")) {
    findings.push(createFinding5(
      "SOL3227",
      "init_if_needed Has Race Condition Risk",
      "high",
      "init_if_needed can race between check and initialize. Prefer explicit two-phase: check + init.",
      { file: input.path },
      "Consider separate initialize instruction with proper checks, or use careful constraint ordering"
    ));
  }
  if (content.includes("close") && content.includes("init")) {
    findings.push(createFinding5(
      "SOL3228",
      "Close-Reinitialize Pattern May Allow Account Resurrection",
      "high",
      "If same account can be closed and reinitialized in same transaction, attacker may resurrect with modified data.",
      { file: input.path },
      "Add delay between close and reinitialize, or use different PDA seeds after close"
    ));
  }
  if (content.includes("[0; 8]") && content.includes("discriminator")) {
    findings.push(createFinding5(
      "SOL3229",
      "Zero Discriminator as Initialization Check",
      "medium",
      "Relying on zero discriminator is fragile. Accounts can be partially written.",
      { file: input.path },
      "Use explicit is_initialized field: pub is_initialized: bool"
    ));
  }
  if (content.includes("try_from_slice") && !content.includes("Initialized")) {
    if (content.includes("write") || content.includes("serialize_into")) {
      findings.push(createFinding5(
        "SOL3230",
        "Deserialization Without Initialization Guard",
        "high",
        "Deserializing and writing without checking initialization allows overwrite attacks.",
        { file: input.path },
        "Check initialization before any write: require!(account.data_is_empty() || !is_initialized)"
      ));
    }
  }
  return findings;
}
function checkArbitraryCPI(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("invoke") || content.includes("invoke_signed")) {
    if (content.includes("program_id") && !content.includes("token::ID") && !content.includes("system_program::ID") && !content.includes("::id()")) {
      findings.push(createFinding5(
        "SOL3231",
        "CPI With Potentially User-Controlled Program ID",
        "critical",
        "Invoking a program ID from user input allows attacker to redirect calls to malicious program.",
        { file: input.path },
        "Hardcode expected program IDs: invoke(&ix, accounts, &token::ID)"
      ));
    }
  }
  if (content.includes("CpiContext") || content.includes("cpi::")) {
    if (content.includes("AccountInfo") && !content.includes("Program<")) {
      findings.push(createFinding5(
        "SOL3232",
        "CPI Program Account Not Type-Verified",
        "high",
        "CPI target program should use Program<'info, T> for automatic ID verification.",
        { file: input.path },
        "Use: pub token_program: Program<'info, Token> instead of AccountInfo"
      ));
    }
  }
  if (content.includes("transfer") && content.includes("token")) {
    if (!content.includes("anchor_spl::token") && !content.includes("spl_token::")) {
      if (content.includes("invoke")) {
        findings.push(createFinding5(
          "SOL3233",
          "Token Transfer CPI Without SPL Token Verification",
          "critical",
          "Token transfer must verify it's invoking the real SPL Token program.",
          { file: input.path },
          "Use anchor_spl::token::transfer or verify: program.key() == &spl_token::ID"
        ));
      }
    }
  }
  if (content.includes("invoke_signed") && content.includes("seeds")) {
    if (!content.includes('b"') && content.includes("instruction_data")) {
      findings.push(createFinding5(
        "SOL3234",
        "CPI Seeds May Include User-Controlled Data",
        "high",
        "CPI signer seeds should be deterministic. User-controlled seeds may authorize unintended accounts.",
        { file: input.path },
        "Use fixed seeds or validate user-provided seed components strictly"
      ));
    }
  }
  if (content.includes("accounts") && content.includes("invoke")) {
    if (!content.includes("verify_account_order") && !content.includes("key() ==")) {
      findings.push(createFinding5(
        "SOL3235",
        "CPI Account Order May Be Manipulated",
        "medium",
        "CPI account ordering should be explicit. Attackers may reorder accounts to exploit index-based access.",
        { file: input.path },
        "Verify account keys explicitly before CPI, or use named accounts in Anchor"
      ));
    }
  }
  return findings;
}
function checkStepFinancePatterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("treasury") && (content.includes("withdraw") || content.includes("transfer"))) {
    if (!content.includes("multisig") && !content.includes("threshold") && !content.includes("signatures")) {
      findings.push(createFinding5(
        "SOL3236",
        "Centralized Treasury (Step Finance Attack Vector)",
        "critical",
        "Step Finance Jan 2026: $30M stolen via single key compromise. Treasury had no multisig.",
        { file: input.path },
        "Implement multisig: require minimum 2-of-3 or 3-of-5 signatures for treasury operations"
      ));
    }
  }
  if (content.includes("commission") || content.includes("fee_vault")) {
    if (!content.includes("timelock") && !content.includes("delay")) {
      findings.push(createFinding5(
        "SOL3237",
        "Commission Fund Without Withdrawal Delay",
        "high",
        "Step Finance: commission funds were drained instantly. Add timelock for large withdrawals.",
        { file: input.path },
        "Add withdrawal delay: require!(current_time >= request_time + WITHDRAWAL_DELAY)"
      ));
    }
  }
  if (content.includes("unstake") && content.includes("authority")) {
    if (!content.includes("cooldown") && !content.includes("epoch")) {
      findings.push(createFinding5(
        "SOL3238",
        "Unstaking Without Cooldown Period",
        "high",
        "Step Finance: attackers unstaked all SOL immediately. Add cooldown/unbonding period.",
        { file: input.path },
        "Implement unbonding: stake cannot be withdrawn until cooldown_end timestamp"
      ));
    }
  }
  if ((content.includes("withdraw") || content.includes("transfer")) && content.includes("amount")) {
    if (!content.includes("max_withdrawal") && !content.includes("daily_limit") && !content.includes("withdrawal_limit")) {
      findings.push(createFinding5(
        "SOL3239",
        "Unlimited Withdrawal Amount",
        "high",
        "No withdrawal limits allows complete fund drainage in single transaction.",
        { file: input.path },
        "Add limits: require!(amount <= MAX_SINGLE_WITHDRAWAL); track daily/weekly limits"
      ));
    }
  }
  if (content.includes("authority") && content.includes("Pubkey")) {
    if (content.includes("// TODO") || content.includes("hot wallet") || content.includes("hot_wallet")) {
      findings.push(createFinding5(
        "SOL3240",
        "Hot Wallet Authority (Key Compromise Risk)",
        "critical",
        "Using hot wallet for treasury authority. Step Finance lost $30M via hot key compromise.",
        { file: input.path },
        "Use hardware wallet (Ledger/Trezor) or MPC solution for treasury authorities"
      ));
    }
  }
  if (content.includes("withdraw") || content.includes("transfer")) {
    if (!content.includes("paused") && !content.includes("frozen") && !content.includes("emergency")) {
      findings.push(createFinding5(
        "SOL3241",
        "No Emergency Pause Mechanism",
        "high",
        "Cannot pause operations during attack. Step Finance couldn't stop drainage.",
        { file: input.path },
        'Add emergency pause: require!(!state.is_paused, "Protocol paused")'
      ));
    }
  }
  if (content.includes("treasury") && !content.includes("monitor") && !content.includes("alert")) {
    findings.push(createFinding5(
      "SOL3242",
      "No Anomaly Detection for Treasury Operations",
      "medium",
      "Large treasury movements should trigger alerts. Step Finance attack was detected hours later.",
      { file: input.path },
      "Implement monitoring: emit event with size flags for off-chain alerting"
    ));
  }
  if (content.includes("transfer") && !content.includes("destination_check")) {
    findings.push(createFinding5(
      "SOL3243",
      "No Destination Validation for Large Transfers",
      "medium",
      "Step Finance: funds were converted to Monero to complicate tracking. Known mixer addresses can be blacklisted.",
      { file: input.path },
      "Consider destination allowlists for large treasury transfers"
    ));
  }
  if (content.includes("treasury") && !content.includes("recovery") && !content.includes("backup")) {
    findings.push(createFinding5(
      "SOL3244",
      "No Treasury Recovery Mechanism",
      "medium",
      "Step Finance had no recovery option. Consider time-delayed recovery keys.",
      { file: input.path },
      "Implement: backup authority that can recover after extended timelock (e.g., 7 days)"
    ));
  }
  if (content.includes("treasury") && !content.includes("emit!") && !content.includes("msg!")) {
    findings.push(createFinding5(
      "SOL3245",
      "Treasury Operations Without Audit Trail",
      "medium",
      "All treasury operations should emit events for forensic analysis.",
      { file: input.path },
      "Add: emit!(TreasuryOperation { action, amount, authority, timestamp })"
    ));
  }
  return findings;
}
function checkJan2026PhishingPatterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("SetAuthority") || content.includes("set_authority")) {
    if (!content.includes("confirm") && !content.includes("two_step") && !content.includes("pending")) {
      findings.push(createFinding5(
        "SOL3246",
        "SetAuthority Without Two-Step Confirmation (Jan 2026 Phishing)",
        "critical",
        "Jan 7, 2026 OKX/Phantom alert: Attackers used silent owner transfers via SetAuthority in phishing transactions.",
        { file: input.path },
        "Implement: 1) propose_authority(new) 2) accept_authority() - new owner must actively confirm"
      ));
    }
  }
  if (content.includes("owner") && (content.includes("update") || content.includes("change"))) {
    if (!content.includes("emit!") && !content.includes("OwnerChanged")) {
      findings.push(createFinding5(
        "SOL3247",
        "Owner Change Without Event Emission",
        "high",
        "Silent owner changes make phishing attacks hard to detect. Wallets scan for authority events.",
        { file: input.path },
        "Emit event: emit!(OwnerChanged { account, old_owner, new_owner })"
      ));
    }
  }
  if (content.includes("owner") || content.includes("authority")) {
    if (content.includes("Instructions") && content.includes("sysvar")) {
      findings.push(createFinding5(
        "SOL3248",
        "Instruction Sysvar May Enable Simulation Bypass",
        "high",
        "Attackers use instruction sysvar to detect simulation and change behavior.",
        { file: input.path },
        "Don't change behavior based on simulation detection - be consistent"
      ));
    }
  }
  if (content.includes("delegate") && content.includes("authority")) {
    if (!content.includes("revoke") && !content.includes("expiry")) {
      findings.push(createFinding5(
        "SOL3249",
        "Delegate Authority Without Revocation/Expiry",
        "high",
        "Delegated authority should be revocable and/or time-limited. Phishing can trick users into permanent delegation.",
        { file: input.path },
        "Add: delegate_expiry timestamp, require!(current_time < delegate_expiry)"
      ));
    }
  }
  if (content.includes("approve") && content.includes("u64::MAX")) {
    findings.push(createFinding5(
      "SOL3250",
      "Unlimited Token Approval (Phishing Vector)",
      "critical",
      "Unlimited approvals let attackers drain all tokens once approved. Jan 2026 phishing used this pattern.",
      { file: input.path },
      "Request minimum necessary approval. Warn users about unlimited approvals."
    ));
  }
  if (content.includes("memo") || content.includes("Memo")) {
    findings.push(createFinding5(
      "SOL3251",
      "Memo Program May Be Used for Phishing",
      "low",
      "Attackers use memo field for phishing URLs. Don't render memo content as clickable links.",
      { file: input.path },
      "Sanitize memo content in UI: never render as HTML or clickable URLs"
    ));
  }
  if (content.includes("claim") && content.includes("airdrop")) {
    if (!content.includes("merkle") && !content.includes("whitelist")) {
      findings.push(createFinding5(
        "SOL3252",
        "Airdrop Claim Without Verification",
        "medium",
        "Fake airdrops are common phishing vector. Verify eligibility via merkle proof.",
        { file: input.path },
        "Use merkle proof for airdrop eligibility verification"
      ));
    }
  }
  if (content.includes("sign") && !content.includes("verify") && !content.includes("display")) {
    findings.push(createFinding5(
      "SOL3253",
      "Transaction May Enable Blind Signing Attack",
      "medium",
      "Users signing transactions they don't understand. Ensure clear transaction display.",
      { file: input.path },
      "Implement clear transaction preview showing all state changes"
    ));
  }
  if (content.includes("session") && content.includes("key")) {
    if (!content.includes("expiry") && !content.includes("scope")) {
      findings.push(createFinding5(
        "SOL3254",
        "Session Key Without Expiry/Scope Limits",
        "high",
        "Session keys should have limited lifetime and action scope to minimize phishing impact.",
        { file: input.path },
        "Add: session_expiry, allowed_actions[], max_amount per session"
      ));
    }
  }
  if (content.includes("connect") || content.includes("approval")) {
    findings.push(createFinding5(
      "SOL3255",
      "DApp Connection Permissions Review",
      "info",
      "Users should regularly review and revoke connected dApp permissions. Common phishing recovery step.",
      { file: input.path },
      "Implement permission review UI and easy revocation"
    ));
  }
  return findings;
}
function checkArithmeticPatterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if ((content.includes("+ ") || content.includes("- ") || content.includes("* ")) && !content.includes("checked_") && !content.includes("saturating_") && !content.includes("require_") && !content.includes(".unwrap_or")) {
    if (content.includes("balance") || content.includes("amount") || content.includes("fee")) {
      findings.push(createFinding5(
        "SOL3256",
        "Unchecked Arithmetic on Financial Values",
        "critical",
        "Arithmetic on balances/amounts without overflow checks. In release mode, Rust wraps instead of panicking.",
        { file: input.path },
        "Use checked arithmetic: balance.checked_add(amount).ok_or(ProgramError::ArithmeticOverflow)?"
      ));
    }
  }
  if (content.includes("as u64") && content.includes("u128")) {
    findings.push(createFinding5(
      "SOL3257",
      "u128 to u64 Truncation Risk",
      "high",
      "Casting u128 to u64 silently truncates. High bits are lost, potentially reducing large values.",
      { file: input.path },
      "Use try_into() with error handling: amount.try_into().map_err(|_| TruncationError)?"
    ));
  }
  if (content.match(/\/.*\*/)) {
    findings.push(createFinding5(
      "SOL3258",
      "Division Before Multiplication (Precision Loss)",
      "high",
      "Dividing before multiplying causes precision loss. a/b*c != a*c/b in integer math.",
      { file: input.path },
      "Reorder: (a * c) / b instead of (a / b) * c"
    ));
  }
  if (content.includes("fee") && content.includes("*") && content.includes("/")) {
    if (!content.includes("checked") && !content.includes("u128")) {
      findings.push(createFinding5(
        "SOL3259",
        "Fee Calculation May Overflow",
        "high",
        "fee = amount * fee_rate / 10000 can overflow before division. Cast to u128 first.",
        { file: input.path },
        "Use: fee = (amount as u128 * fee_rate as u128 / 10000) as u64"
      ));
    }
  }
  if (content.includes("share") || content.includes("ratio")) {
    if (content.includes("/") && !content.includes("ceil") && !content.includes("round")) {
      findings.push(createFinding5(
        "SOL3260",
        "Share Calculation Uses Floor Division",
        "medium",
        "Integer division always floors. For deposits, ceil is fairer; for withdrawals, floor is fairer.",
        { file: input.path },
        "Choose rounding direction carefully: (a + b - 1) / b for ceiling division"
      ));
    }
  }
  if (content.includes("interest") && content.includes("rate")) {
    if (!content.includes("max_rate") && !content.includes("cap")) {
      findings.push(createFinding5(
        "SOL3261",
        "Interest Rate Without Maximum Cap",
        "high",
        "Uncapped interest rates can spike to extreme values during utilization spikes.",
        { file: input.path },
        "Add: rate = min(calculated_rate, MAX_INTEREST_RATE)"
      ));
    }
  }
  if (content.includes("price") && (content.includes("*") || content.includes("/"))) {
    if (!content.includes("PRECISION") && !content.includes("decimals") && !content.includes("1e")) {
      findings.push(createFinding5(
        "SOL3262",
        "Price Calculation Without Precision Handling",
        "high",
        "Price calculations need proper decimal handling. Different tokens have different decimals.",
        { file: input.path },
        "Normalize: price * 10^(target_decimals - source_decimals)"
      ));
    }
  }
  if (content.includes("timestamp") && content.includes("i32")) {
    findings.push(createFinding5(
      "SOL3263",
      "Timestamp Using i32 (Year 2038 Problem)",
      "medium",
      "i32 timestamps overflow in 2038. Use i64 or u64 for timestamps.",
      { file: input.path },
      "Use i64 for timestamps: let timestamp: i64 = clock.unix_timestamp;"
    ));
  }
  if (content.includes("- ") && (content.includes("balance") || content.includes("amount"))) {
    if (!content.includes("checked_sub") && !content.includes("saturating_sub") && !content.includes("require!(")) {
      findings.push(createFinding5(
        "SOL3264",
        "Subtraction Without Underflow Check",
        "critical",
        "Subtracting more than available causes underflow/wrap in release mode.",
        { file: input.path },
        "Use: balance.checked_sub(amount).ok_or(InsufficientFunds)?"
      ));
    }
  }
  if (content.includes("supply") && content.includes("+")) {
    if (!content.includes("MAX_SUPPLY") && !content.includes("checked_add")) {
      findings.push(createFinding5(
        "SOL3265",
        "Token Supply Addition Without Max Check",
        "critical",
        "Unchecked supply addition enables infinite mint via overflow.",
        { file: input.path },
        "Add: require!(new_supply <= MAX_SUPPLY); use checked arithmetic"
      ));
    }
  }
  return findings;
}
function checkCertik2026Patterns(input) {
  const findings = [];
  if (!input.rust?.content) return findings;
  const content = input.rust.content;
  if (content.includes("private") || content.includes("secret") || content.includes("seed")) {
    if (content.includes("log") || content.includes("print") || content.includes("msg!")) {
      findings.push(createFinding5(
        "SOL3266",
        "Potential Private Key/Seed Logging",
        "critical",
        "CertiK Jan 2026: Key exposure was #1 attack vector. Never log secrets.",
        { file: input.path },
        "Remove ALL logging of private keys, seeds, or secrets. Use environment variables."
      ));
    }
  }
  if (content.includes("admin") || content.includes("owner")) {
    if (!content.includes("require!") && !content.includes("constraint")) {
      findings.push(createFinding5(
        "SOL3267",
        "Admin/Owner Check May Be Missing",
        "critical",
        "CertiK reports access control bypass as major 2026 attack category.",
        { file: input.path },
        "Add: require!(ctx.accounts.authority.key() == state.admin)"
      ));
    }
  }
  if (content.includes("withdraw_all") || content.includes("drain") || content.includes("emergency_withdraw")) {
    if (!content.includes("multisig") && !content.includes("timelock")) {
      findings.push(createFinding5(
        "SOL3268",
        "Potential Exit Scam Function (Drain All)",
        "critical",
        "Functions that drain all funds should require multisig + timelock.",
        { file: input.path },
        "Add multisig requirement and 24-48hr timelock for drain functions"
      ));
    }
  }
  if (content.includes("bridge") || content.includes("cross_chain")) {
    if (!content.includes("merkle") && !content.includes("guardian") && !content.includes("relayer")) {
      findings.push(createFinding5(
        "SOL3269",
        "Bridge Without Multi-Party Verification",
        "critical",
        "Bridge exploits caused massive losses. Require multiple verifiers.",
        { file: input.path },
        "Implement: merkle proofs + guardian signatures + relayer confirmation"
      ));
    }
  }
  if (content.includes("borrow") && content.includes("repay") || content.includes("flash")) {
    if (!content.includes("callback") && !content.includes("reentrancy")) {
      findings.push(createFinding5(
        "SOL3270",
        "Flash Loan Implementation Without Reentrancy Guard",
        "high",
        "Flash loans require careful reentrancy protection.",
        { file: input.path },
        "Add reentrancy guard: set flag before callback, check after"
      ));
    }
  }
  if (content.includes("pool") && content.includes("swap")) {
    if (!content.includes("slippage") && !content.includes("min_out")) {
      findings.push(createFinding5(
        "SOL3271",
        "Pool Swap Without Slippage Protection",
        "high",
        "Swaps without slippage protection are vulnerable to sandwich attacks.",
        { file: input.path },
        "Add: require!(amount_out >= min_amount_out)"
      ));
    }
  }
  if (content.includes("governance") || content.includes("proposal")) {
    if (!content.includes("voting_period") && !content.includes("execution_delay")) {
      findings.push(createFinding5(
        "SOL3272",
        "Governance Without Time Delays",
        "high",
        "Flash loan governance attacks use instant voting. Add delays.",
        { file: input.path },
        "Add: voting_period >= 3 days, execution_delay >= 24 hours"
      ));
    }
  }
  if (content.includes("price") || content.includes("oracle")) {
    if (!content.includes("fallback") && !content.includes("secondary")) {
      findings.push(createFinding5(
        "SOL3273",
        "Single Oracle Without Fallback",
        "high",
        "Oracle failures/manipulations caused major losses. Have fallback.",
        { file: input.path },
        "Implement fallback: if (primary_oracle_stale) use secondary_oracle"
      ));
    }
  }
  if (content.includes("upgrade") || content.includes("migrate")) {
    if (!content.includes("timelock") && !content.includes("multisig")) {
      findings.push(createFinding5(
        "SOL3274",
        "Program Upgrade Without Protection",
        "critical",
        "Instant upgrades enable backdoor deployment. Add timelock.",
        { file: input.path },
        "Use upgrade authority with: multisig + 48hr timelock + announcement"
      ));
    }
  }
  if (content.includes("protocol") || content.includes("lending") || content.includes("pool")) {
    if (!content.includes("insurance") && !content.includes("reserve") && !content.includes("backstop")) {
      findings.push(createFinding5(
        "SOL3275",
        "Protocol Without Insurance/Reserve Fund",
        "medium",
        "DeFi protocols should maintain reserve fund for bad debt/exploits.",
        { file: input.path },
        "Allocate portion of fees to insurance fund for user protection"
      ));
    }
  }
  return findings;
}
function checkBatch71Patterns(input) {
  return [
    ...checkMissingSignerCheck(input),
    ...checkMissingOwnerCheck(input),
    ...checkAccountDataMatching(input),
    ...checkTypeCosplay(input),
    ...checkBumpCanonicalization(input),
    ...checkReinitialization(input),
    ...checkArbitraryCPI(input),
    ...checkStepFinancePatterns(input),
    ...checkJan2026PhishingPatterns(input),
    ...checkArithmeticPatterns(input),
    ...checkCertik2026Patterns(input)
  ];
}

// src/patterns/solana-batched-patterns-72.ts
function createFinding6(id, title, severity, description, path, line, recommendation) {
  return {
    id,
    title,
    severity,
    description,
    location: { file: path, line },
    recommendation
  };
}
function checkBatch72Patterns(input) {
  const findings = [];
  const { rust, path } = input;
  if (!rust?.content) return findings;
  const content = rust.content;
  const lines = content.split("\n");
  const revertExploitPatterns = [
    /invoke_signed.*\?/g,
    // CPI that can fail
    /try_borrow_mut/g,
    // Operations that can fail
    /checked_.*\.unwrap\(\)/g
    // Checked ops with unwrap
  ];
  for (const pattern of revertExploitPatterns) {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      const surroundingCode = content.substring(Math.max(0, match.index - 200), match.index + 200);
      if (!surroundingCode.includes("revert") && !surroundingCode.includes("rollback")) {
        findings.push(createFinding6(
          "SOL3276",
          "Reverting Transaction Exploitation Risk",
          "high",
          "Operations that can revert may be exploitable in gambling/lottery contexts. Attackers can submit transactions that revert on unfavorable outcomes.",
          path,
          lineNum,
          "Implement commit-reveal schemes or use randomness sources that cannot be front-run"
        ));
        break;
      }
    }
  }
  if (content.includes("random") || content.includes("lottery") || content.includes("roulette")) {
    if (!content.includes("commit") || !content.includes("reveal")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("random") || l.includes("lottery") || l.includes("roulette")
      ) + 1;
      findings.push(createFinding6(
        "SOL3277",
        "Missing Commit-Reveal for Randomness",
        "critical",
        "Random/lottery operations without commit-reveal are exploitable via reverting transactions",
        path,
        lineNum,
        "Implement two-phase commit-reveal where users commit to choices before randomness is revealed"
      ));
    }
  }
  const simDetectionIndicators = [
    /get_clock/g,
    /Clock::get/g,
    /slot\s*[<>=]/g
  ];
  let hasSimDetection = false;
  for (const pattern of simDetectionIndicators) {
    if (pattern.test(content)) {
      hasSimDetection = true;
      break;
    }
  }
  if (content.includes("preflight") || content.includes("simulate")) {
    const lineNum = content.split("\n").findIndex(
      (l) => l.includes("preflight") || l.includes("simulate")
    ) + 1;
    findings.push(createFinding6(
      "SOL3278",
      "Transaction Simulation Detection Pattern",
      "medium",
      "Code attempts to detect simulation mode which may be bypassed by attackers",
      path,
      lineNum,
      "Do not rely on simulation detection for security; use proper authorization"
    ));
  }
  if (/slot.*%/.test(content) || /slot.*rand/.test(content)) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("slot")) + 1;
    findings.push(createFinding6(
      "SOL3279",
      "Slot-Based Randomness Exploitation",
      "critical",
      "Using slot number for randomness is exploitable as validators can manipulate slot timing",
      path,
      lineNum,
      "Use VRF (Verifiable Random Function) like Switchboard VRF for secure randomness"
    ));
  }
  if (content.includes("result") && content.includes("payout")) {
    if (!content.includes("committed") && !content.includes("hash")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("payout")) + 1;
      findings.push(createFinding6(
        "SOL3280",
        "Missing Outcome Commitment Before Reveal",
        "high",
        "Payouts without prior commitment allow attackers to revert losing transactions",
        path,
        lineNum,
        "Require users to commit to outcomes in a separate transaction before revealing results"
      ));
    }
  }
  const breakPatterns = /for\s+.*\{[\s\S]*?break[\s\S]*?\}/g;
  let breakMatch;
  while ((breakMatch = breakPatterns.exec(content)) !== null) {
    const matchContent = breakMatch[0];
    if (!matchContent.includes("if") || matchContent.includes("break;") && !matchContent.includes("found")) {
      const lineNum = content.substring(0, breakMatch.index).split("\n").length;
      findings.push(createFinding6(
        "SOL3281",
        "Premature Break Statement May Skip Processing",
        "high",
        "Break statement in loop may exit early, leaving items unprocessed. This was the root cause of the Jet Protocol vulnerability.",
        path,
        lineNum,
        "Ensure break only exits when all relevant items are processed or use continue instead"
      ));
    }
  }
  const unconditionalBreak = /\n\s*break\s*;/g;
  let uncondBreakMatch;
  while ((uncondBreakMatch = unconditionalBreak.exec(content)) !== null) {
    const lineNum = content.substring(0, uncondBreakMatch.index).split("\n").length;
    findings.push(createFinding6(
      "SOL3282",
      "Unconditional Break in Loop",
      "medium",
      "Break without condition will exit loop immediately, potentially skipping items",
      path,
      lineNum,
      "Add condition to break or verify single iteration is intended"
    ));
  }
  if (content.includes("for") && content.includes("break")) {
    if (content.includes("total") || content.includes("sum") || content.includes("balance")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("break")) + 1;
      findings.push(createFinding6(
        "SOL3283",
        "Loop Exit May Leave Accounting Incomplete",
        "high",
        "Break in loop with accounting operations may leave totals incorrect",
        path,
        lineNum,
        "Process all items before calculating totals, or ensure break only occurs after all accounting"
      ));
    }
  }
  if (content.includes("round") && !content.includes("round_down") && !content.includes("round_up")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("round")) + 1;
    findings.push(createFinding6(
      "SOL3284",
      "Generic Round May Cause $2.6B+ Risk",
      "critical",
      "Using round() instead of floor/ceil can be exploited in lending protocols. Neodyme discovered this put $2.6B at risk in SPL Lending.",
      path,
      lineNum,
      "Use floor (round_down) for amounts going to users, ceil (round_up) for amounts taken from users"
    ));
  }
  const divMulPattern = /\/[^;]*\*/g;
  if (divMulPattern.test(content)) {
    const lineNum = content.split("\n").findIndex((l) => /\/[^;]*\*/.test(l)) + 1;
    findings.push(createFinding6(
      "SOL3285",
      "Division Before Multiplication Precision Loss",
      "high",
      "Dividing before multiplying causes precision loss which can be exploited",
      path,
      lineNum,
      "Always multiply before dividing: (a * b) / c instead of (a / c) * b"
    ));
  }
  if (content.includes("collateral") || content.includes("borrow") || content.includes("lending")) {
    if (content.includes("/") && !content.includes("checked_div") && !content.includes("floor") && !content.includes("ceil")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("/")) + 1;
      findings.push(createFinding6(
        "SOL3286",
        "Lending Math Without Rounding Direction",
        "high",
        "Lending protocol math without explicit rounding direction is exploitable",
        path,
        lineNum,
        "Use checked_div_floor or checked_div_ceil depending on who should benefit from remainder"
      ));
    }
  }
  if (content.includes("interest") && content.includes("/")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("interest")) + 1;
    findings.push(createFinding6(
      "SOL3287",
      "Interest Calculation Rounding Risk",
      "medium",
      "Interest calculations with division can accumulate rounding errors over time",
      path,
      lineNum,
      "Round interest in favor of the protocol to prevent drain attacks"
    ));
  }
  if ((content.includes("shares") || content.includes("share")) && content.includes("/")) {
    if (!content.includes("floor") && !content.includes("saturating")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("share")) + 1;
      findings.push(createFinding6(
        "SOL3288",
        "Share Calculation Without Floor Protection",
        "high",
        "Share calculations should use floor to prevent minting extra shares",
        path,
        lineNum,
        "Use floor when calculating shares to mint, ceil when calculating shares to burn"
      ));
    }
  }
  let vulnCount = 0;
  if (content.includes("UncheckedAccount")) vulnCount++;
  if (content.includes("AccountInfo") && !content.includes("Account<")) vulnCount++;
  if (!content.includes("owner") && content.includes("data")) vulnCount++;
  if (content.includes("invoke") && !content.includes("program_id")) vulnCount++;
  if (vulnCount >= 2) {
    findings.push(createFinding6(
      "SOL3289",
      "Multiple Minor Issues May Chain to Critical Exploit",
      "high",
      `Found ${vulnCount} minor security issues that could be chained together for a larger exploit (Schrodinger's NFT pattern)`,
      path,
      1,
      "Address all minor issues as they can combine into critical vulnerabilities"
    ));
  }
  if (content.includes("TokenAccount") || content.includes("token_account")) {
    const hasOwnerCheck = content.includes(".owner") || content.includes("owner =");
    const hasMintCheck = content.includes(".mint") || content.includes("mint =");
    const hasAmountCheck = content.includes(".amount") || content.includes("amount >=");
    if (!hasOwnerCheck || !hasMintCheck || !hasAmountCheck) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("TokenAccount") || l.includes("token_account")
      ) + 1;
      findings.push(createFinding6(
        "SOL3290",
        "Incomplete Token Account Validation",
        "critical",
        "Token account missing owner, mint, or amount validation can be exploited",
        path,
        lineNum,
        "Validate owner, mint, and amount for all token accounts"
      ));
    }
  }
  if (content.includes("burn") && content.includes("nft")) {
    if (!content.includes("owner") || !content.includes("authority")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("burn")) + 1;
      findings.push(createFinding6(
        "SOL3291",
        "NFT Burn Without Full Authorization",
        "critical",
        "NFT burn operations must verify owner authority to prevent unauthorized destruction",
        path,
        lineNum,
        "Require owner signature and verify authority before burning NFTs"
      ));
    }
  }
  if (content.includes("reload") || content.includes("refresh")) {
  } else if (content.includes("account") && content.includes("transfer")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("transfer")) + 1;
    findings.push(createFinding6(
      "SOL3292",
      "Stale Account State Before Transfer",
      "high",
      "Account state should be reloaded before transfers to prevent double-spend",
      path,
      lineNum,
      "Reload account state immediately before transfers"
    ));
  }
  if (content.includes("candy_machine") || content.includes("CandyMachine")) {
    if (content.includes("UncheckedAccount") || content.includes("AccountInfo")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("candy_machine") || l.includes("CandyMachine")
      ) + 1;
      findings.push(createFinding6(
        "SOL3293",
        "Candy Machine Unchecked Account Vulnerability",
        "critical",
        'Candy machine with unchecked accounts allows attackers to mint unlimited NFTs. This was the "Smashing the Candy Machine" exploit.',
        path,
        lineNum,
        "Use #[account(zero)] for newly initialized accounts, not #[account]"
      ));
    }
  }
  if (content.includes("mint_count") || content.includes("items_redeemed")) {
    if (!content.includes("checked_add") && !content.includes("saturating_add")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("mint_count") || l.includes("items_redeemed")
      ) + 1;
      findings.push(createFinding6(
        "SOL3294",
        "NFT Mint Counter Without Overflow Protection",
        "high",
        "Mint counter without overflow protection can wrap around, allowing unlimited mints",
        path,
        lineNum,
        "Use checked_add or saturating_add for mint counters"
      ));
    }
  }
  if (content.includes("whitelist") || content.includes("allowlist")) {
    if (!content.includes("merkle") && !content.includes("proof")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("whitelist") || l.includes("allowlist")
      ) + 1;
      findings.push(createFinding6(
        "SOL3295",
        "Whitelist Without Merkle Proof Verification",
        "high",
        "Whitelist systems should use Merkle proofs for efficient on-chain verification",
        path,
        lineNum,
        "Implement Merkle tree whitelist with proof verification"
      ));
    }
  }
  if ((content.includes("phase") || content.includes("stage")) && content.includes("mint")) {
    if (!content.includes("require") && !content.includes("assert")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("phase") || l.includes("stage")
      ) + 1;
      findings.push(createFinding6(
        "SOL3296",
        "Mint Phase Without Enforcement",
        "medium",
        "Mint phases without require/assert can be bypassed",
        path,
        lineNum,
        "Enforce mint phases with require! or assert! macros"
      ));
    }
  }
  if (content.includes("stake_pool") || content.includes("StakePool")) {
    if (content.includes("exchange_rate") || content.includes("pool_token")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("exchange_rate") || l.includes("pool_token")
      ) + 1;
      findings.push(createFinding6(
        "SOL3297",
        "Stake Pool Exchange Rate Manipulation Risk",
        "high",
        "Stake pool exchange rates can be manipulated if not properly protected",
        path,
        lineNum,
        "Validate rate changes are within expected bounds and use time-weighted averages"
      ));
    }
  }
  if (content.includes("update") && content.includes("state")) {
    const updateMatches = content.match(/\.\s*(\w+)\s*=/g) || [];
    if (updateMatches.length > 3) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("update")) + 1;
      findings.push(createFinding6(
        "SOL3298",
        "Multiple State Updates May Be Semantically Inconsistent",
        "medium",
        `${updateMatches.length} state field updates detected. Ensure all updates maintain consistent invariants.`,
        path,
        lineNum,
        "Verify state invariants are maintained across all updates"
      ));
    }
  }
  if (content.includes("validator") && (content.includes("select") || content.includes("choose"))) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("validator")) + 1;
    findings.push(createFinding6(
      "SOL3299",
      "Validator Selection May Be Manipulatable",
      "medium",
      "Validator selection algorithms can be gamed if predictable",
      path,
      lineNum,
      "Use weighted random selection with VRF for validator assignment"
    ));
  }
  if (content.includes("delegate") || content.includes("delegation")) {
    if (!content.includes("minimum") && !content.includes("MIN")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("delegate") || l.includes("delegation")
      ) + 1;
      findings.push(createFinding6(
        "SOL3300",
        "Missing Minimum Delegation Amount",
        "low",
        "Delegation without minimum amounts can lead to dust attacks",
        path,
        lineNum,
        "Enforce minimum delegation amounts"
      ));
    }
  }
  if (content.includes("lending_market") || content.includes("LendingMarket")) {
    if (content.includes("AccountInfo") && !content.includes("has_one")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("lending_market") || l.includes("LendingMarket")
      ) + 1;
      findings.push(createFinding6(
        "SOL3301",
        "Lending Market Without Ownership Constraint",
        "critical",
        "Lending market account without has_one constraint allows malicious market injection (Solend pattern)",
        path,
        lineNum,
        "Use has_one constraint to bind reserve to lending market"
      ));
    }
  }
  if (content.includes("reserve") && content.includes("config")) {
    if (!content.includes("authority") || !content.includes("signer")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("reserve") && l.includes("config")
      ) + 1;
      findings.push(createFinding6(
        "SOL3302",
        "Reserve Config Update Without Authority Check",
        "critical",
        "Reserve configuration updates must require authority signature",
        path,
        lineNum,
        "Require lending market authority to update reserve config"
      ));
    }
  }
  if (content.includes("collateral_factor") || content.includes("loan_to_value")) {
    if (!content.includes("max") && !content.includes("MAX") && !content.includes("<=")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("collateral_factor") || l.includes("loan_to_value")
      ) + 1;
      findings.push(createFinding6(
        "SOL3303",
        "Collateral Factor Without Upper Bound",
        "high",
        "Collateral factors without bounds can be set to exploit lending protocol",
        path,
        lineNum,
        "Enforce maximum collateral factor (e.g., 90%)"
      ));
    }
  }
  if (content.includes("interest_rate") || content.includes("borrow_rate")) {
    if (!content.includes("validate") && !content.includes("check")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("interest_rate") || l.includes("borrow_rate")
      ) + 1;
      findings.push(createFinding6(
        "SOL3304",
        "Interest Rate Without Validation",
        "medium",
        "Interest rate changes should be validated to prevent extreme values",
        path,
        lineNum,
        "Validate interest rates are within reasonable bounds"
      ));
    }
  }
  if (content.includes("approve") || content.includes("Approve")) {
    if (content.includes("u64::MAX") || content.includes("MAX_AMOUNT")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("approve")) + 1;
      findings.push(createFinding6(
        "SOL3305",
        "Unlimited Token Approval",
        "high",
        "Approving u64::MAX allows delegate unlimited access to tokens",
        path,
        lineNum,
        "Approve only the minimum necessary amount"
      ));
    }
  }
  if (content.includes("approve") && !content.includes("revoke")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("approve")) + 1;
    findings.push(createFinding6(
      "SOL3306",
      "Token Approval Without Revoke",
      "medium",
      "Token approvals should be revoked after use to minimize exposure",
      path,
      lineNum,
      "Revoke approvals immediately after the operation completes"
    ));
  }
  if (content.includes("delegate") && !content.includes("close")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("delegate")) + 1;
    findings.push(createFinding6(
      "SOL3307",
      "Delegate May Persist After Use",
      "low",
      "Delegate accounts should be cleared after operations",
      path,
      lineNum,
      "Clear delegate field or close accounts after use"
    ));
  }
  if (content.includes("lp_token") || content.includes("pool_token")) {
    if (content.includes("reserve") && (content.includes("price") || content.includes("value"))) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("lp_token") || l.includes("pool_token")
      ) + 1;
      findings.push(createFinding6(
        "SOL3308",
        "LP Token Price Derived from Reserves ($200M Risk)",
        "critical",
        "LP token prices derived from pool reserves can be manipulated via flash loans (OtterSec $200M Bluff)",
        path,
        lineNum,
        "Use fair LP pricing: price = 2 * sqrt(reserve0 * reserve1 * price0 * price1) / totalSupply"
      ));
    }
  }
  if (content.includes("oracle") || content.includes("price_feed")) {
    if (!content.includes("twap") && !content.includes("TWAP") && !content.includes("time_weighted")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("oracle") || l.includes("price_feed")
      ) + 1;
      findings.push(createFinding6(
        "SOL3309",
        "Oracle Without TWAP Protection",
        "high",
        "Spot price oracles without TWAP can be manipulated in single transactions",
        path,
        lineNum,
        "Use Time-Weighted Average Price (TWAP) for oracle resistance to manipulation"
      ));
    }
  }
  if (content.includes("reserve0") && content.includes("reserve1")) {
    if (content.includes("price") && !content.includes("external") && !content.includes("oracle")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("reserve")) + 1;
      findings.push(createFinding6(
        "SOL3310",
        "AMM Reserve Ratio Used as Price",
        "critical",
        "Using reserve0/reserve1 ratio as price is manipulatable via flash loans",
        path,
        lineNum,
        "Use external oracle prices, not AMM reserve ratios"
      ));
    }
  }
  if (content.includes("pool") && content.includes("price")) {
    if (!content.includes("max_deviation") && !content.includes("check") && !content.includes("valid")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("pool") && l.includes("price")) + 1;
      findings.push(createFinding6(
        "SOL3311",
        "Pool Price Without Deviation Check",
        "high",
        "Pool prices should be checked against oracle prices for deviation",
        path,
        lineNum,
        "Compare pool price to oracle price and reject if deviation > threshold (e.g., 5%)"
      ));
    }
  }
  if (content.includes("data_len") || content.includes("data.len()")) {
  } else if (content.includes(".data") && content.includes("try_borrow")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes(".data")) + 1;
    findings.push(createFinding6(
      "SOL3312",
      "Account Data Access Without Length Check",
      "high",
      "Account data should be length-checked before parsing to prevent buffer overflows",
      path,
      lineNum,
      "Check data.len() >= EXPECTED_SIZE before parsing"
    ));
  }
  if (content.includes("AccountDeserialize") || content.includes("try_deserialize")) {
    if (!content.includes("discriminator") && !content.includes("DISCRIMINATOR")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("AccountDeserialize") || l.includes("try_deserialize")
      ) + 1;
      findings.push(createFinding6(
        "SOL3313",
        "Deserialization Without Discriminator Check",
        "critical",
        "Account deserialization without discriminator allows type confusion attacks",
        path,
        lineNum,
        "Verify 8-byte discriminator before deserializing"
      ));
    }
  }
  if (content.includes("info.owner") || content.includes("account_info.owner")) {
  } else if (content.includes("AccountInfo") && !content.includes("owner")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("AccountInfo")) + 1;
    findings.push(createFinding6(
      "SOL3314",
      "AccountInfo Without Owner Check (Neodyme Level 0)",
      "critical",
      "AccountInfo must have owner verified to prevent passing arbitrary accounts",
      path,
      lineNum,
      "Add: require!(account.owner == expected_program_id)"
    ));
  }
  if (content.includes("is_signer")) {
  } else if (content.includes("authority") && !content.includes("Signer")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("authority")) + 1;
    findings.push(createFinding6(
      "SOL3315",
      "Authority Without Signer Check (Neodyme Level 1)",
      "critical",
      "Authority accounts must be verified as signers",
      path,
      lineNum,
      "Use Signer<'info> type or check is_signer"
    ));
  }
  if (content.includes("data") && content.includes("parse")) {
    if (!content.includes("validate") && !content.includes("check")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("parse")) + 1;
      findings.push(createFinding6(
        "SOL3316",
        "Data Parsed Without Validation (Neodyme Level 2)",
        "high",
        "Parsed data should be validated before use",
        path,
        lineNum,
        "Add validation logic after parsing data"
      ));
    }
  }
  if (content.includes("invoke") || content.includes("CPI")) {
    if (!content.includes("check") && !content.includes("verify") && !content.includes("validate")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("invoke")) + 1;
      findings.push(createFinding6(
        "SOL3317",
        "CPI Without Account Validity Verification (Kudelski)",
        "high",
        "Kudelski audit methodology requires verifying validity of all CPI accounts",
        path,
        lineNum,
        "Verify all accounts before CPI calls"
      ));
    }
  }
  if (content.includes("Program") && content.includes("entrypoint")) {
    const hasOwnerCheck = content.includes("owner");
    const hasSignerCheck = content.includes("signer") || content.includes("is_signer");
    const hasErrorHandling = content.includes("Error") || content.includes("err!");
    if (!hasOwnerCheck || !hasSignerCheck || !hasErrorHandling) {
      findings.push(createFinding6(
        "SOL3318",
        "Missing Basic Security Patterns (OtterSec Methodology)",
        "high",
        "Program missing fundamental security: owner check, signer check, or error handling",
        path,
        1,
        "Ensure all three: owner validation, signer verification, proper error handling"
      ));
    }
  }
  const arithmeticOps = /[+\-*\/][^=]/g;
  let arithmeticMatch;
  let unsafeArithmetic = false;
  while ((arithmeticMatch = arithmeticOps.exec(content)) !== null) {
    const surroundingCode = content.substring(Math.max(0, arithmeticMatch.index - 50), arithmeticMatch.index);
    if (!surroundingCode.includes("checked_") && !surroundingCode.includes("saturating_")) {
      unsafeArithmetic = true;
      break;
    }
  }
  if (unsafeArithmetic) {
    findings.push(createFinding6(
      "SOL3319",
      "Arithmetic Without Checked/Saturating (Sec3 Methodology)",
      "high",
      "Sec3 recommends using checked_ or saturating_ for all arithmetic",
      path,
      1,
      "Replace +,-,*,/ with checked_add, checked_sub, checked_mul, checked_div"
    ));
  }
  if (content.includes("#[program]") || content.includes("declare_id!")) {
    if (content.includes("init_if_needed")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("init_if_needed")) + 1;
      findings.push(createFinding6(
        "SOL3320",
        "init_if_needed Vulnerability (Zellic)",
        "high",
        "Zellic identifies init_if_needed as a common vulnerability pattern - allows reinitialization attacks",
        path,
        lineNum,
        "Use separate init instruction or add proper initialization checks"
      ));
    }
  }
  if (content.includes("find_program_address") || content.includes("create_program_address")) {
    const seedsMatch = content.match(/seeds\s*=\s*\[([^\]]+)\]/);
    if (seedsMatch && seedsMatch[1].split(",").length < 2) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("seeds")) + 1;
      findings.push(createFinding6(
        "SOL3321",
        "PDA Seeds With Insufficient Entropy",
        "medium",
        "PDA with single seed may have collision risk",
        path,
        lineNum,
        "Use multiple seeds to ensure PDA uniqueness"
      ));
    }
  }
  if (content.includes("invoke") && content.includes("serialize")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("invoke")) + 1;
    findings.push(createFinding6(
      "SOL3322",
      "Cross-Program State Serialization Risk",
      "medium",
      "State serialization before CPI may become inconsistent if CPI fails",
      path,
      lineNum,
      "Serialize state after successful CPI or use proper rollback"
    ));
  }
  if (content.includes("clock.unix_timestamp") || content.includes("Clock::get")) {
    if (content.includes("price") || content.includes("rate") || content.includes("reward")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("clock")) + 1;
      findings.push(createFinding6(
        "SOL3323",
        "Timestamp-Dependent Financial Calculation",
        "medium",
        "Financial calculations depending on timestamps can be manipulated by validators",
        path,
        lineNum,
        "Use slot numbers instead of timestamps for time-sensitive operations"
      ));
    }
  }
  if (content.includes("transfer") || content.includes("mint") || content.includes("burn")) {
    if (!content.includes("amount > 0") && !content.includes("amount != 0") && !content.includes("require!")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("transfer") || l.includes("mint") || l.includes("burn")
      ) + 1;
      findings.push(createFinding6(
        "SOL3324",
        "Token Operation Without Zero-Amount Check",
        "low",
        "Zero-amount transfers/mints/burns should be rejected to prevent event spam",
        path,
        lineNum,
        "Add require!(amount > 0) before token operations"
      ));
    }
  }
  if (/account\.\s*\w+\s*=\s*account/.test(content)) {
    const lineNum = content.split("\n").findIndex((l) => /account\.\s*\w+\s*=\s*account/.test(l)) + 1;
    findings.push(createFinding6(
      "SOL3325",
      "Self-Referential Account Assignment",
      "high",
      "Account referencing itself may create circular dependencies",
      path,
      lineNum,
      "Verify account references are to distinct accounts"
    ));
  }
  if (content.includes("Result<") && content.includes("let _ =")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("let _ =")) + 1;
    findings.push(createFinding6(
      "SOL3326",
      "Ignored Result Return Value",
      "high",
      "Ignoring Result return values may hide errors",
      path,
      lineNum,
      "Handle Result with ? operator or explicit match"
    ));
  }
  if (content.includes("as *const") || content.includes("as *mut")) {
    const lineNum = content.split("\n").findIndex(
      (l) => l.includes("as *const") || l.includes("as *mut")
    ) + 1;
    findings.push(createFinding6(
      "SOL3327",
      "Unsafe Pointer Cast",
      "critical",
      "Pointer casts can lead to memory corruption",
      path,
      lineNum,
      "Avoid raw pointers; use safe Rust abstractions"
    ));
  }
  if (content.includes("vec!") || content.includes("Vec::with_capacity")) {
    if (!content.includes("MAX") && !content.includes("limit")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("vec!") || l.includes("Vec::with_capacity")
      ) + 1;
      findings.push(createFinding6(
        "SOL3328",
        "Unbounded Vector Allocation",
        "high",
        "Vector allocation without size limit can exhaust compute units",
        path,
        lineNum,
        "Add maximum size limit for vector allocations"
      ));
    }
  }
  if (content.includes("epoch") && (content.includes("reward") || content.includes("stake"))) {
    if (!content.includes("boundary") && !content.includes("transition")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("epoch")) + 1;
      findings.push(createFinding6(
        "SOL3329",
        "Missing Epoch Boundary Handling",
        "medium",
        "Epoch-based operations should handle boundary transitions",
        path,
        lineNum,
        "Add epoch boundary detection and handling logic"
      ));
    }
  }
  if (content.includes("bump") && content.includes("find_program_address")) {
    if (!content.includes("bump =") && !content.includes("bump:")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("bump")) + 1;
      findings.push(createFinding6(
        "SOL3330",
        "PDA Bump Not Stored",
        "low",
        "PDA bump should be stored to avoid recalculation",
        path,
        lineNum,
        "Store bump seed in account data for efficiency"
      ));
    }
  }
  if (content.includes("invoke_signed") || content.includes("invoke")) {
    if (!content.includes("program_id") && !content.includes("key()")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("invoke")) + 1;
      findings.push(createFinding6(
        "SOL3331",
        "CPI Without Program ID Verification",
        "critical",
        "CPI target program ID must be verified to prevent calling malicious programs",
        path,
        lineNum,
        "Verify program_id matches expected program before CPI"
      ));
    }
  }
  if (content.includes("mint_authority") || content.includes("MintTo")) {
    if (!content.includes("Some(authority)") && !content.includes("mint_authority.is_some()")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("mint")) + 1;
      findings.push(createFinding6(
        "SOL3332",
        "Mint Authority Not Properly Verified",
        "critical",
        "Mint authority must be verified to prevent unauthorized minting",
        path,
        lineNum,
        "Verify mint_authority matches expected authority"
      ));
    }
  }
  if (content.includes("freeze_authority")) {
    if (!content.includes("None") && !content.includes("is_none")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("freeze_authority")) + 1;
      findings.push(createFinding6(
        "SOL3333",
        "Freeze Authority May Be Set",
        "medium",
        "Tokens with freeze authority can be frozen by the authority",
        path,
        lineNum,
        "Consider requiring freeze_authority = None for trustless tokens"
      ));
    }
  }
  if (content.includes("create_account") || content.includes("allocate")) {
    if (!content.includes("rent_exempt") && !content.includes("minimum_balance")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("create_account") || l.includes("allocate")
      ) + 1;
      findings.push(createFinding6(
        "SOL3334",
        "Account Creation Without Rent Exemption Check",
        "medium",
        "New accounts should be rent-exempt to prevent deletion",
        path,
        lineNum,
        "Use Rent::get()?.minimum_balance(space) for rent-exempt lamports"
      ));
    }
  }
  if (content.includes("close") || content.includes("Close")) {
    if (!content.includes("destination") && !content.includes("refund")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("close")) + 1;
      findings.push(createFinding6(
        "SOL3335",
        "Account Close Without Lamport Destination",
        "high",
        "Closing accounts must specify where lamports go",
        path,
        lineNum,
        "Specify close destination account for lamport recovery"
      ));
    }
  }
  if (content.includes("flash_loan") || content.includes("FlashLoan")) {
    if (!content.includes("callback") || !content.includes("verify")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("flash")) + 1;
      findings.push(createFinding6(
        "SOL3336",
        "Flash Loan Without Callback Validation",
        "critical",
        "Flash loans must verify callback repayment",
        path,
        lineNum,
        "Implement and verify flash loan callback"
      ));
    }
  }
  if (content.includes("proposal") || content.includes("Proposal")) {
    if (!content.includes("deposit") && !content.includes("stake")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("proposal")) + 1;
      findings.push(createFinding6(
        "SOL3337",
        "Governance Without Proposal Cost",
        "medium",
        "Proposals without deposit requirement can spam governance",
        path,
        lineNum,
        "Require deposit for proposal creation"
      ));
    }
  }
  if (content.includes("vote") && content.includes("power")) {
    if (!content.includes("snapshot") && !content.includes("checkpoint")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("vote")) + 1;
      findings.push(createFinding6(
        "SOL3338",
        "Vote Power Without Snapshot",
        "high",
        "Vote power should be snapshotted to prevent flash loan voting",
        path,
        lineNum,
        "Snapshot voting power at proposal creation time"
      ));
    }
  }
  if (content.includes("swap") || content.includes("exchange")) {
    if (!content.includes("min_amount") && !content.includes("slippage")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("swap") || l.includes("exchange")
      ) + 1;
      findings.push(createFinding6(
        "SOL3339",
        "Swap Without Slippage Protection",
        "high",
        "Swaps without minimum output amount are vulnerable to sandwich attacks",
        path,
        lineNum,
        "Require min_amount_out parameter for slippage protection"
      ));
    }
  }
  if (content.includes("pool") && content.includes("swap")) {
    if (!content.includes("k") && !content.includes("invariant")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("pool")) + 1;
      findings.push(createFinding6(
        "SOL3340",
        "AMM Missing K Invariant Check",
        "critical",
        "AMM must verify x*y=k invariant after swaps",
        path,
        lineNum,
        "Verify reserve0 * reserve1 >= k_prev after swap"
      ));
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-73.ts
function createFinding7(id, title, severity, description, path, line, recommendation) {
  return {
    id,
    title,
    severity,
    description,
    location: { file: path, line },
    recommendation
  };
}
function checkBatch73Patterns(input) {
  const findings = [];
  const { rust, path } = input;
  if (!rust?.content) return findings;
  const content = rust.content;
  const lines = content.split("\n");
  if (content.includes("guardian") || content.includes("Guardian")) {
    if (!content.includes("num_signatures") && !content.includes("quorum")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("guardian")) + 1;
      findings.push(createFinding7(
        "SOL3376",
        "Guardian Quorum Not Enforced ($326M Risk)",
        "critical",
        "Bridge guardians without quorum check were exploited in Wormhole hack",
        path,
        lineNum,
        "Require 2/3 guardian signatures for message validation"
      ));
    }
  }
  if (content.includes("vaa") || content.includes("VAA")) {
    if (!content.includes("verify") || !content.includes("signature")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("vaa") || l.includes("VAA")
      ) + 1;
      findings.push(createFinding7(
        "SOL3377",
        "VAA Without Complete Signature Verification",
        "critical",
        "VAA (Verified Action Approval) must verify all guardian signatures",
        path,
        lineNum,
        "Implement full VAA signature verification"
      ));
    }
  }
  if (content.includes("ed25519") || content.includes("Ed25519")) {
    if (!content.includes("verify") && !content.includes("valid")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("ed25519")) + 1;
      findings.push(createFinding7(
        "SOL3378",
        "Ed25519 Signature Without Proper Verification",
        "critical",
        "Ed25519 signatures must be properly verified using the precompile",
        path,
        lineNum,
        "Use ed25519_dalek verify() or Solana precompile for validation"
      ));
    }
  }
  if (content.includes("SignatureSet") || content.includes("signature_set")) {
    if (!content.includes("owner") && !content.includes("program_id")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("SignatureSet") || l.includes("signature_set")
      ) + 1;
      findings.push(createFinding7(
        "SOL3379",
        "SignatureSet Without Owner Validation (Wormhole Pattern)",
        "critical",
        "SignatureSet accounts must verify owner to prevent spoofing",
        path,
        lineNum,
        "Verify SignatureSet is owned by the expected program"
      ));
    }
  }
  if (content.includes("bridge") || content.includes("Bridge")) {
    if (!content.includes("nonce") && !content.includes("sequence") && !content.includes("used")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("bridge")) + 1;
      findings.push(createFinding7(
        "SOL3380",
        "Bridge Message Without Replay Protection",
        "critical",
        "Bridge messages must have nonce/sequence to prevent replay attacks",
        path,
        lineNum,
        "Track message nonce and reject duplicates"
      ));
    }
  }
  if (content.includes("chain_id") || content.includes("source_chain")) {
    if (!content.includes("validate") && !content.includes("allowed")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("chain")) + 1;
      findings.push(createFinding7(
        "SOL3381",
        "Cross-Chain Source Not Validated",
        "high",
        "Messages from other chains must verify the source chain ID",
        path,
        lineNum,
        "Whitelist allowed source chains"
      ));
    }
  }
  if (content.includes("wrapped") || content.includes("Wrapped")) {
    if (content.includes("mint_authority") && !content.includes("bridge")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("wrapped")) + 1;
      findings.push(createFinding7(
        "SOL3382",
        "Wrapped Token Mint Authority Not Bridge",
        "high",
        "Wrapped token mint authority should be the bridge program",
        path,
        lineNum,
        "Set mint_authority to bridge PDA"
      ));
    }
  }
  if (content.includes("bridge") && (content.includes("transfer") || content.includes("withdraw"))) {
    if (!content.includes("finalized") && !content.includes("confirmed")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("transfer")) + 1;
      findings.push(createFinding7(
        "SOL3383",
        "Bridge Transfer Without Finality Check",
        "high",
        "Bridge transfers must wait for source chain finality",
        path,
        lineNum,
        "Verify source transaction is finalized before processing"
      ));
    }
  }
  if (content.includes("guardian_set") || content.includes("update_guardian")) {
    if (!content.includes("delay") && !content.includes("timelock")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("guardian")) + 1;
      findings.push(createFinding7(
        "SOL3384",
        "Guardian Set Update Without Timelock",
        "high",
        "Guardian set changes should have timelock for emergency response",
        path,
        lineNum,
        "Add minimum delay (e.g., 24h) for guardian set updates"
      ));
    }
  }
  if ((content.includes("bridge") || content.includes("cross_chain")) && content.includes("decimals")) {
    if (!content.includes("normalize") && !content.includes("convert")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("decimals")) + 1;
      findings.push(createFinding7(
        "SOL3385",
        "Cross-Chain Decimal Normalization Missing",
        "high",
        "Different chains may have different decimal standards",
        path,
        lineNum,
        "Normalize decimals when bridging tokens across chains"
      ));
    }
  }
  if (content.includes("transfer_hook") || content.includes("TransferHook")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("transfer_hook")) + 1;
    findings.push(createFinding7(
      "SOL3386",
      "Transfer Hook Reentrancy Risk",
      "critical",
      "Transfer hooks execute arbitrary code during transfers, enabling reentrancy",
      path,
      lineNum,
      "Use reentrancy guards when interacting with tokens that have transfer hooks"
    ));
  }
  if (content.includes("confidential") || content.includes("Confidential")) {
    if (content.includes("log") || content.includes("msg!") || content.includes("emit")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("confidential") || l.includes("Confidential")
      ) + 1;
      findings.push(createFinding7(
        "SOL3387",
        "Confidential Transfer Amount Logged",
        "high",
        "Logging confidential transfer details defeats the privacy purpose",
        path,
        lineNum,
        "Do not log confidential transfer amounts or parties"
      ));
    }
  }
  if (content.includes("permanent_delegate") || content.includes("PermanentDelegate")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("delegate")) + 1;
    findings.push(createFinding7(
      "SOL3388",
      "Permanent Delegate Enabled (Potential Rug Risk)",
      "high",
      "Permanent delegate can transfer tokens from any holder at any time",
      path,
      lineNum,
      "Warn users about permanent delegate; consider if truly necessary"
    ));
  }
  if (content.includes("non_transferable") || content.includes("NonTransferable")) {
    if (content.includes("transfer") || content.includes("burn")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("non_transferable")) + 1;
      findings.push(createFinding7(
        "SOL3389",
        "Non-Transferable Token With Transfer Logic",
        "medium",
        "Non-transferable tokens should not have transfer functions",
        path,
        lineNum,
        "Remove transfer functionality from non-transferable tokens"
      ));
    }
  }
  if (content.includes("interest_bearing") || content.includes("InterestBearing")) {
    if (!content.includes("rate_authority") && !content.includes("validate")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("interest")) + 1;
      findings.push(createFinding7(
        "SOL3390",
        "Interest Bearing Rate Without Authority Check",
        "high",
        "Interest rate changes must be authorized",
        path,
        lineNum,
        "Verify rate_authority before interest rate updates"
      ));
    }
  }
  if (content.includes("memo_required") || content.includes("MemoRequired")) {
    if (content.includes("skip") || content.includes("bypass")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("memo")) + 1;
      findings.push(createFinding7(
        "SOL3391",
        "Memo Required Extension Bypass",
        "medium",
        "MemoRequired extension can be bypassed if not properly enforced",
        path,
        lineNum,
        "Ensure memo is always required when extension is set"
      ));
    }
  }
  if (content.includes("cpi_guard") || content.includes("CpiGuard")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("cpi")) + 1;
    findings.push(createFinding7(
      "SOL3392",
      "CPI Guard Status Change Risk",
      "medium",
      "CPI Guard state changes should be carefully controlled",
      path,
      lineNum,
      "Verify authority before CPI Guard enable/disable"
    ));
  }
  if (content.includes("default_account_state") || content.includes("DefaultAccountState")) {
    if (content.includes("frozen")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("default")) + 1;
      findings.push(createFinding7(
        "SOL3393",
        "Default Account State Set to Frozen",
        "medium",
        "Tokens with default frozen state require manual unfreezing",
        path,
        lineNum,
        "Document frozen default state clearly to users"
      ));
    }
  }
  if (content.includes("transfer_fee") || content.includes("TransferFee")) {
    if (!content.includes("max_fee") && !content.includes("ceiling")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("fee")) + 1;
      findings.push(createFinding7(
        "SOL3394",
        "Transfer Fee Without Maximum Cap",
        "medium",
        "Transfer fees should have a maximum to prevent excessive charges",
        path,
        lineNum,
        "Set maximum_fee to cap transfer fees"
      ));
    }
  }
  if (content.includes("metadata_pointer") || content.includes("MetadataPointer")) {
    if (!content.includes("authority") && !content.includes("validate")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("metadata")) + 1;
      findings.push(createFinding7(
        "SOL3395",
        "Metadata Pointer Change Without Authority",
        "medium",
        "Metadata pointer changes could redirect to malicious metadata",
        path,
        lineNum,
        "Verify metadata_pointer_authority before changes"
      ));
    }
  }
  if (content.includes("random") || content.includes("Random")) {
    if (content.includes("slot") || content.includes("blockhash")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("random")) + 1;
      findings.push(createFinding7(
        "SOL3396",
        "Randomness From Predictable Source",
        "critical",
        "Using slot/blockhash for randomness is predictable by validators",
        path,
        lineNum,
        "Use Switchboard VRF or similar for secure randomness"
      ));
    }
  }
  if (content.includes("royalt") || content.includes("creator_fee")) {
    if (!content.includes("enforce") && !content.includes("require")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("royalt")) + 1;
      findings.push(createFinding7(
        "SOL3397",
        "NFT Royalty Not Enforced",
        "medium",
        "Royalties should be enforced at the program level",
        path,
        lineNum,
        "Use Token-2022 royalty enforcement or program-level checks"
      ));
    }
  }
  if (content.includes("item") && (content.includes("transfer") || content.includes("mint"))) {
    if (!content.includes("unique") && !content.includes("exists")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("item")) + 1;
      findings.push(createFinding7(
        "SOL3398",
        "Game Item Duplication Risk",
        "high",
        "Game items may be duplicated if uniqueness is not enforced",
        path,
        lineNum,
        "Verify item uniqueness before minting/transfers"
      ));
    }
  }
  if (content.includes("reward") && content.includes("game")) {
    if (!content.includes("cap") && !content.includes("limit") && !content.includes("max")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("reward")) + 1;
      findings.push(createFinding7(
        "SOL3399",
        "P2E Reward Without Cap",
        "high",
        "Uncapped rewards can lead to token inflation",
        path,
        lineNum,
        "Implement daily/weekly reward caps"
      ));
    }
  }
  if (content.includes("loot") || content.includes("gacha") || content.includes("chest")) {
    if (!content.includes("vrf") && !content.includes("VRF")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("loot") || l.includes("gacha") || l.includes("chest")
      ) + 1;
      findings.push(createFinding7(
        "SOL3400",
        "Loot Box Without VRF Randomness",
        "critical",
        "Loot box outcomes must use verifiable random function",
        path,
        lineNum,
        "Implement VRF for loot box/gacha mechanics"
      ));
    }
  }
  if (content.includes("collection") && content.includes("nft")) {
    if (!content.includes("verified") && !content.includes("authority")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("collection")) + 1;
      findings.push(createFinding7(
        "SOL3401",
        "NFT Collection Not Verified",
        "high",
        "NFT collection membership should be verified",
        path,
        lineNum,
        "Check collection.verified is true"
      ));
    }
  }
  if (content.includes("metadata") && (content.includes("uri") || content.includes("name"))) {
    if (!content.includes("sanitize") && !content.includes("validate")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("metadata")) + 1;
      findings.push(createFinding7(
        "SOL3402",
        "NFT Metadata Without Sanitization",
        "medium",
        "Metadata fields should be sanitized to prevent injection",
        path,
        lineNum,
        "Sanitize and validate all metadata inputs"
      ));
    }
  }
  if (content.includes("compressed") || content.includes("cnft") || content.includes("merkle")) {
    if (!content.includes("verify_leaf") && !content.includes("proof")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("compressed") || l.includes("cnft")
      ) + 1;
      findings.push(createFinding7(
        "SOL3403",
        "Compressed NFT Without Proof Verification",
        "critical",
        "cNFT operations must verify Merkle proof",
        path,
        lineNum,
        "Use verify_leaf with proper proof path"
      ));
    }
  }
  if (content.includes("burn") && content.includes("nft")) {
    if (!content.includes("owner") && !content.includes("authority")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("burn")) + 1;
      findings.push(createFinding7(
        "SOL3404",
        "NFT Burn Without Ownership Verification",
        "critical",
        "Only NFT owner should be able to burn",
        path,
        lineNum,
        "Verify caller is NFT owner before burning"
      ));
    }
  }
  if (content.includes("game") && content.includes("state")) {
    if (!content.includes("checkpoint") && !content.includes("save")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("game")) + 1;
      findings.push(createFinding7(
        "SOL3405",
        "Game State Without Checkpoint System",
        "medium",
        "Game states should have checkpoints to prevent manipulation",
        path,
        lineNum,
        "Implement periodic state checkpoints"
      ));
    }
  }
  if (content.includes("swap") || content.includes("exchange")) {
    if (!content.includes("deadline") && !content.includes("min_amount_out")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("swap")) + 1;
      findings.push(createFinding7(
        "SOL3406",
        "Swap Vulnerable to Sandwich Attack",
        "critical",
        "Swaps without slippage protection can be sandwiched",
        path,
        lineNum,
        "Add min_amount_out and deadline parameters"
      ));
    }
  }
  if (content.includes("swap") || content.includes("trade")) {
    if (!content.includes("deadline") && !content.includes("expire") && !content.includes("valid_until")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("swap") || l.includes("trade")
      ) + 1;
      findings.push(createFinding7(
        "SOL3407",
        "Trade Without Expiry Deadline",
        "high",
        "Trades without deadline can be held and executed at unfavorable prices",
        path,
        lineNum,
        "Add transaction deadline parameter"
      ));
    }
  }
  if (content.includes("bundle") || content.includes("Bundle")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("bundle")) + 1;
    findings.push(createFinding7(
      "SOL3408",
      "Jito Bundle Interaction Risk",
      "medium",
      "Transactions may be bundled with malicious ones via Jito",
      path,
      lineNum,
      "Consider MEV protection via Jito block builders or private RPCs"
    ));
  }
  if (content.includes("priority_fee") || content.includes("compute_budget")) {
    if (!content.includes("limit") && !content.includes("max")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("priority")) + 1;
      findings.push(createFinding7(
        "SOL3409",
        "Priority Fee Without Limit",
        "low",
        "Priority fees should be bounded to prevent overpayment",
        path,
        lineNum,
        "Set maximum priority fee limit"
      ));
    }
  }
  if (content.includes("order") && content.includes("pending")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("order")) + 1;
    findings.push(createFinding7(
      "SOL3410",
      "Pending Order Visible On-Chain",
      "medium",
      "Pending orders visible on-chain can be front-run",
      path,
      lineNum,
      "Consider commit-reveal or encrypted orders"
    ));
  }
  if (content.includes("liquidat") || content.includes("arbitrage")) {
    const lineNum = content.split("\n").findIndex(
      (l) => l.includes("liquidat") || l.includes("arbitrage")
    ) + 1;
    findings.push(createFinding7(
      "SOL3411",
      "Backrunning Opportunity Present",
      "medium",
      "Liquidations and arbitrage are prime backrunning targets",
      path,
      lineNum,
      "Consider permissioned liquidators or batch auctions"
    ));
  }
  if (content.includes("liquidity") && content.includes("add")) {
    if (!content.includes("commit") && !content.includes("lock")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("liquidity")) + 1;
      findings.push(createFinding7(
        "SOL3412",
        "JIT Liquidity Attack Vector",
        "medium",
        "Just-in-time liquidity can sandwich trades",
        path,
        lineNum,
        "Consider minimum liquidity lock period"
      ));
    }
  }
  if (content.includes("oracle") && content.includes("update")) {
    if (!content.includes("delay") && !content.includes("twap")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("oracle")) + 1;
      findings.push(createFinding7(
        "SOL3413",
        "Oracle Update Frontrunnable",
        "high",
        "Oracle updates can be front-run if visible before execution",
        path,
        lineNum,
        "Use TWAP or delayed oracle updates"
      ));
    }
  }
  if (content.includes("vault") && content.includes("deposit")) {
    if (!content.includes("minimum") && !content.includes("dead_shares")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("deposit")) + 1;
      findings.push(createFinding7(
        "SOL3414",
        "First Depositor Attack Possible",
        "critical",
        "First depositor can inflate share price to steal subsequent deposits",
        path,
        lineNum,
        "Initialize vault with dead shares or minimum deposit"
      ));
    }
  }
  if (content.includes("bad_debt") || content.includes("underwater")) {
    if (!content.includes("insurance") && !content.includes("reserve")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("bad_debt") || l.includes("underwater")
      ) + 1;
      findings.push(createFinding7(
        "SOL3415",
        "Bad Debt Without Insurance Fund",
        "high",
        "Bad debt should be covered by insurance fund",
        path,
        lineNum,
        "Implement insurance reserve for bad debt"
      ));
    }
  }
  if (content.includes("liquidation") && content.includes("bonus")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("liquidation")) + 1;
    findings.push(createFinding7(
      "SOL3416",
      "Verify Liquidation Bonus Is Reasonable",
      "medium",
      "High liquidation bonuses can lead to cascading liquidations",
      path,
      lineNum,
      "Keep liquidation bonus reasonable (e.g., 5-15%)"
    ));
  }
  if (content.includes("health_factor") || content.includes("health")) {
    if (!content.includes("collateral") || !content.includes("debt")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("health")) + 1;
      findings.push(createFinding7(
        "SOL3417",
        "Health Factor Missing Components",
        "high",
        "Health factor must consider all collateral and debt",
        path,
        lineNum,
        "Include all positions in health factor calculation"
      ));
    }
  }
  if (content.includes("interest_rate") && content.includes("utilization")) {
    if (!content.includes("kink") && !content.includes("optimal")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("interest")) + 1;
      findings.push(createFinding7(
        "SOL3418",
        "Interest Rate Model Without Kink",
        "medium",
        "Interest rate models should have kink at optimal utilization",
        path,
        lineNum,
        "Implement kinked interest rate curve"
      ));
    }
  }
  if (content.includes("borrow") && !content.includes("borrow_cap") && !content.includes("max_borrow")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("borrow")) + 1;
    findings.push(createFinding7(
      "SOL3419",
      "Missing Borrow Cap",
      "high",
      "Borrowing without cap can drain liquidity",
      path,
      lineNum,
      "Implement per-asset borrow caps"
    ));
  }
  if (content.includes("deposit") && content.includes("lending")) {
    if (!content.includes("supply_cap") && !content.includes("max_deposit")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("deposit")) + 1;
      findings.push(createFinding7(
        "SOL3420",
        "Missing Supply Cap",
        "medium",
        "Unlimited supply can lead to oracle manipulation",
        path,
        lineNum,
        "Implement per-asset supply caps"
      ));
    }
  }
  if (content.includes("close") && content.includes("account")) {
    if (!content.includes("realloc") && !content.includes("zero")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("close")) + 1;
      findings.push(createFinding7(
        "SOL3421",
        "Account Close Without Zeroing",
        "high",
        "Closed accounts should be zeroed to prevent revival attacks",
        path,
        lineNum,
        "Zero account data before closing"
      ));
    }
  }
  if (content.includes("find_program_address")) {
    if (!content.includes("bump") || content.includes("create_program_address")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("find_program_address")) + 1;
      findings.push(createFinding7(
        "SOL3422",
        "PDA Without Canonical Bump",
        "high",
        "Use canonical bump seed from find_program_address",
        path,
        lineNum,
        "Store and validate canonical bump seed"
      ));
    }
  }
  if (content.includes("sol_memcpy") || content.includes("sol_memmove")) {
    const lineNum = content.split("\n").findIndex(
      (l) => l.includes("sol_memcpy") || l.includes("sol_memmove")
    ) + 1;
    findings.push(createFinding7(
      "SOL3423",
      "Low-Level Memory Operation",
      "medium",
      "Low-level syscalls require careful bounds checking",
      path,
      lineNum,
      "Verify source/destination sizes before memory operations"
    ));
  }
  if (content.includes("msg!") || content.includes("log")) {
    if (content.includes("user") || content.includes("input")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("msg!")) + 1;
      findings.push(createFinding7(
        "SOL3424",
        "Log Injection Risk",
        "low",
        "User input in logs can confuse monitoring systems",
        path,
        lineNum,
        "Sanitize user input before logging"
      ));
    }
  }
  if (content.includes("for") && content.includes("iter")) {
    if (!content.includes("take") && !content.includes("limit")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("for")) + 1;
      findings.push(createFinding7(
        "SOL3425",
        "Unbounded Iteration May Exhaust CU",
        "high",
        "Unbounded iteration can consume all compute units",
        path,
        lineNum,
        "Limit iterations with .take() or explicit bounds"
      ));
    }
  }
  if (content.includes("invoke") && content.includes("invoke")) {
    const invokeCount = (content.match(/invoke/g) || []).length;
    if (invokeCount > 3) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("invoke")) + 1;
      findings.push(createFinding7(
        "SOL3426",
        "Multiple CPI Calls May Exceed Depth Limit",
        "medium",
        `${invokeCount} invoke calls detected. Solana has max CPI depth of 4.`,
        path,
        lineNum,
        "Reduce CPI depth or batch operations"
      ));
    }
  }
  if (content.includes("#[program]") && !content.includes('#[cfg(not(feature = "no-idl"))]')) {
    findings.push(createFinding7(
      "SOL3427",
      "Anchor IDL Always Exposed",
      "info",
      "Consider optional IDL generation for production",
      path,
      1,
      "Add no-idl feature flag for production builds"
    ));
  }
  if (content.includes("Error") && !content.includes("#[error_code]")) {
    if (!content.includes("ProgramError")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("Error")) + 1;
      findings.push(createFinding7(
        "SOL3428",
        "Custom Errors Without Error Code",
        "low",
        "Custom errors should use #[error_code] for better debugging",
        path,
        lineNum,
        "Use Anchor #[error_code] for custom errors"
      ));
    }
  }
  if (content.includes("set_authority") || content.includes("SetAuthority")) {
    if (!content.includes("None") && !content.includes("revoke")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("authority")) + 1;
      findings.push(createFinding7(
        "SOL3429",
        "Authority Can Be Changed",
        "medium",
        "Verify authority changes are intentional and authorized",
        path,
        lineNum,
        "Consider if authority should be immutable or require multi-sig"
      ));
    }
  }
  if (content.includes("version") && content.includes("transaction")) {
    if (!content.includes("v0") && !content.includes("legacy")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("version")) + 1;
      findings.push(createFinding7(
        "SOL3430",
        "Transaction Version Not Specified",
        "low",
        "Explicitly handle both legacy and v0 transactions",
        path,
        lineNum,
        "Add version-specific handling for transactions"
      ));
    }
  }
  if (content.includes("lookup") || content.includes("address_lookup")) {
    if (!content.includes("validate") && !content.includes("verify")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("lookup")) + 1;
      findings.push(createFinding7(
        "SOL3431",
        "Address Lookup Table Without Validation",
        "high",
        "Lookup tables should be validated before use",
        path,
        lineNum,
        "Verify lookup table is owned by expected program"
      ));
    }
  }
  if (content.includes("durable_nonce") || content.includes("DurableNonce")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("nonce")) + 1;
    findings.push(createFinding7(
      "SOL3432",
      "Durable Nonce Expiration Risk",
      "medium",
      "Durable nonces can expire, leaving transactions stranded",
      path,
      lineNum,
      "Handle nonce expiration gracefully"
    ));
  }
  if (content.includes("stake") && content.includes("delegate")) {
    if (!content.includes("lockup") && !content.includes("warmup")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("stake")) + 1;
      findings.push(createFinding7(
        "SOL3433",
        "Stake Delegation Without Lockup",
        "medium",
        "Consider stake warmup and cooldown periods",
        path,
        lineNum,
        "Respect stake warmup/cooldown for proper delegation"
      ));
    }
  }
  if (content.includes("vote") && content.includes("account")) {
    if (!content.includes("authorized") && !content.includes("authority")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("vote")) + 1;
      findings.push(createFinding7(
        "SOL3434",
        "Vote Account Without Authority Check",
        "high",
        "Vote account operations require proper authorization",
        path,
        lineNum,
        "Verify vote account authority"
      ));
    }
  }
  if (content.includes("commission") && content.includes("validator")) {
    if (!content.includes("max") && !content.includes("limit")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("commission")) + 1;
      findings.push(createFinding7(
        "SOL3435",
        "Validator Commission Without Cap",
        "medium",
        "Validator commissions should have reasonable caps",
        path,
        lineNum,
        "Limit commission to reasonable percentage"
      ));
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-74.ts
function createFinding8(id, title, severity, description, path, line, recommendation) {
  return {
    id,
    title,
    severity,
    description,
    location: { file: path, line },
    recommendation
  };
}
function checkBatch74Patterns(input) {
  const findings = [];
  const { rust, path } = input;
  if (!rust?.content) return findings;
  const content = rust.content;
  const lines = content.split("\n");
  if (content.includes("state") && content.includes("update")) {
    if (!content.includes("invariant") && !content.includes("assert")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("update")) + 1;
      findings.push(createFinding8(
        "SOL3476",
        "State Update Without Invariant Check",
        "high",
        "State updates should verify invariants are preserved",
        path,
        lineNum,
        "Add invariant assertions after state updates"
      ));
    }
  }
  if (content.includes("total_supply") || content.includes("totalSupply")) {
    if (content.includes("mint") || content.includes("burn")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("total_supply")) + 1;
      findings.push(createFinding8(
        "SOL3477",
        "Total Supply Must Track Mint/Burn",
        "high",
        "Total supply should equal sum of all balances",
        path,
        lineNum,
        "Update total_supply atomically with mint/burn"
      ));
    }
  }
  if (content.includes("balance") && (content.includes("transfer") || content.includes("move"))) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("balance")) + 1;
    findings.push(createFinding8(
      "SOL3478",
      "Balance Transfer Invariant",
      "medium",
      "Sum of balances should remain constant in transfers",
      path,
      lineNum,
      "Verify from_balance + to_balance unchanged"
    ));
  }
  if (content.includes("nonce") || content.includes("counter") || content.includes("sequence")) {
    if (!content.includes("checked_add") && !content.includes("saturating")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("nonce") || l.includes("counter") || l.includes("sequence")
      ) + 1;
      findings.push(createFinding8(
        "SOL3479",
        "Counter May Overflow",
        "high",
        "Monotonic counters should use checked arithmetic",
        path,
        lineNum,
        "Use checked_add and verify no overflow"
      ));
    }
  }
  if (content.includes("collateral") && content.includes("debt")) {
    if (!content.includes("ratio") && !content.includes("factor")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("collateral")) + 1;
      findings.push(createFinding8(
        "SOL3480",
        "Collateralization Ratio Not Maintained",
        "critical",
        "Operations should maintain minimum collateral ratio",
        path,
        lineNum,
        "Check collateral_ratio >= MIN_RATIO after operations"
      ));
    }
  }
  if (content.includes("pool") && (content.includes("reserve") || content.includes("liquidity"))) {
    if (!content.includes("k") && !content.includes("product")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("pool")) + 1;
      findings.push(createFinding8(
        "SOL3481",
        "AMM Constant Product Not Verified",
        "critical",
        "AMM operations should preserve x*y=k invariant",
        path,
        lineNum,
        "Verify new_x * new_y >= k after swaps"
      ));
    }
  }
  if (content.includes("interest") && content.includes("accrued")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("interest")) + 1;
    findings.push(createFinding8(
      "SOL3482",
      "Interest Accrual Must Be Consistent",
      "medium",
      "Accrued interest should match time elapsed and rate",
      path,
      lineNum,
      "Verify: accrued = principal * rate * time / YEAR_SECONDS"
    ));
  }
  if (content.includes("withdraw") || content.includes("redeem")) {
    if (!content.includes("available") && !content.includes("liquidity")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("withdraw") || l.includes("redeem")
      ) + 1;
      findings.push(createFinding8(
        "SOL3483",
        "Withdrawal May Exceed Available",
        "high",
        "Withdrawals must not exceed available liquidity",
        path,
        lineNum,
        "Check withdraw_amount <= available_liquidity"
      ));
    }
  }
  const criticalFunctions = ["upgrade", "pause", "withdraw", "mint", "burn", "set_config"];
  for (const fn of criticalFunctions) {
    if (content.includes(fn)) {
      if (!content.includes("authority") && !content.includes("admin") && !content.includes("owner")) {
        const lineNum = content.split("\n").findIndex((l) => l.includes(fn)) + 1;
        findings.push(createFinding8(
          "SOL3484",
          `Critical Function '${fn}' Missing Access Control`,
          "critical",
          "Critical functions must verify caller authorization",
          path,
          lineNum,
          "Add authority/admin check before execution"
        ));
        break;
      }
    }
  }
  if ((content.includes("transfer") || content.includes("invoke")) && content.includes("balance")) {
    if (!content.includes("lock") && !content.includes("nonReentrant")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("transfer")) + 1;
      findings.push(createFinding8(
        "SOL3485",
        "Token Operation May Be Reentrant",
        "critical",
        "Token operations with external calls may be vulnerable to reentrancy",
        path,
        lineNum,
        "Use checks-effects-interactions pattern or reentrancy guard"
      ));
    }
  }
  if (content.includes("flash") && content.includes("loan")) {
    if (!content.includes("repay") && !content.includes("callback")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("flash")) + 1;
      findings.push(createFinding8(
        "SOL3486",
        "Flash Loan Repayment Not Enforced",
        "critical",
        "Flash loans must verify full repayment with fee",
        path,
        lineNum,
        "Verify repaid_amount >= borrowed_amount + fee"
      ));
    }
  }
  if (content.includes("admin") || content.includes("owner")) {
    if (!content.includes("multisig") && !content.includes("timelock") && !content.includes("dao")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("admin") || l.includes("owner")
      ) + 1;
      findings.push(createFinding8(
        "SOL3487",
        "Single Point of Admin Control",
        "high",
        "Admin functions should use multisig or timelock",
        path,
        lineNum,
        "Implement multisig or timelock for admin functions"
      ));
    }
  }
  if (content.includes("initialize") || content.includes("init")) {
    if (!content.includes("initialized") && !content.includes("already")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("initialize") || l.includes("init")
      ) + 1;
      findings.push(createFinding8(
        "SOL3488",
        "Initialization Can Be Called Multiple Times",
        "critical",
        "Initialize function must be callable only once",
        path,
        lineNum,
        "Add initialized flag and check it"
      ));
    }
  }
  if (content.includes("mint") && !content.includes("max_supply") && !content.includes("cap")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("mint")) + 1;
    findings.push(createFinding8(
      "SOL3489",
      "Token Minting Without Supply Cap",
      "high",
      "Unlimited minting can lead to inflation",
      path,
      lineNum,
      "Add max_supply check before minting"
    ));
  }
  if (content.includes("price") && content.includes("feed")) {
    if (!content.includes("stale") && !content.includes("valid") && !content.includes("confidence")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("price")) + 1;
      findings.push(createFinding8(
        "SOL3490",
        "Price Feed Used Without Validation",
        "critical",
        "Price feeds must be validated for staleness and confidence",
        path,
        lineNum,
        "Check price.timestamp, confidence_interval, and status"
      ));
    }
  }
  if (content.includes("AccountInfo") && !content.includes("Account<")) {
    if (!content.includes("discriminator") && !content.includes("try_from")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("AccountInfo")) + 1;
      findings.push(createFinding8(
        "SOL3491",
        "Raw AccountInfo Without Type Verification",
        "critical",
        "AccountInfo must verify account type via discriminator",
        path,
        lineNum,
        "Use Anchor Account<> type or manually check discriminator"
      ));
    }
  }
  if (content.includes("seeds") && content.includes("bump")) {
    if (!content.includes("find_program_address")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("seeds")) + 1;
      findings.push(createFinding8(
        "SOL3492",
        "PDA Created Without find_program_address",
        "high",
        "PDA should be derived using find_program_address for canonical bump",
        path,
        lineNum,
        "Use Pubkey::find_program_address() to get canonical bump"
      ));
    }
  }
  if (content.includes("pub fn") && !content.includes("Signer") && !content.includes("is_signer")) {
    if (content.includes("transfer") || content.includes("withdraw") || content.includes("update")) {
      findings.push(createFinding8(
        "SOL3493",
        "Sensitive Function May Lack Signer Check",
        "high",
        "Functions modifying state should verify signer authorization",
        path,
        1,
        "Add Signer constraint or manual is_signer check"
      ));
    }
  }
  if (content.includes("token_account") || content.includes("TokenAccount")) {
    if (!content.includes(".owner") || !content.includes("==")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("token_account")) + 1;
      findings.push(createFinding8(
        "SOL3494",
        "Token Account Owner Not Verified",
        "critical",
        "Token account owner must match expected owner",
        path,
        lineNum,
        "Verify token_account.owner == expected_owner"
      ));
    }
  }
  if (content.includes("create_account") && !content.includes("rent")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("create_account")) + 1;
    findings.push(createFinding8(
      "SOL3495",
      "New Account May Not Be Rent Exempt",
      "medium",
      "New accounts should be funded for rent exemption",
      path,
      lineNum,
      "Fund with Rent::get()?.minimum_balance(space)"
    ));
  }
  if (content.includes("invoke") || content.includes("CPI")) {
    if (!content.includes("program_id") || !content.includes("key")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("invoke")) + 1;
      findings.push(createFinding8(
        "SOL3496",
        "CPI Target Program Not Validated",
        "critical",
        "CPI must verify target program ID",
        path,
        lineNum,
        "Verify program_id matches expected program"
      ));
    }
  }
  if (content.includes("try_from") || content.includes("deserialize")) {
    if (!content.includes("data.len()") && !content.includes("data_len")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("try_from") || l.includes("deserialize")
      ) + 1;
      findings.push(createFinding8(
        "SOL3497",
        "Deserialization Without Length Check",
        "high",
        "Data length should be verified before deserialization",
        path,
        lineNum,
        "Check data.len() >= EXPECTED_SIZE before parsing"
      ));
    }
  }
  if (content.includes("close") || content.includes("Close")) {
    if (!content.includes("sol_destination") && !content.includes("recipient")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("close")) + 1;
      findings.push(createFinding8(
        "SOL3498",
        "Close Account Destination Not Specified",
        "high",
        "Closed account lamports must go to specified destination",
        path,
        lineNum,
        "Specify close destination: #[account(close = destination)]"
      ));
    }
  }
  if (content.includes("system_program") || content.includes("SystemProgram")) {
    if (!content.includes("system_program::ID") && !content.includes("key() ==")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("system")) + 1;
      findings.push(createFinding8(
        "SOL3499",
        "System Program ID Not Verified",
        "high",
        "System program account should verify ID",
        path,
        lineNum,
        "Use #[account(address = system_program::ID)]"
      ));
    }
  }
  if (content.includes("token_program") || content.includes("TokenProgram")) {
    if (!content.includes("token::ID") && !content.includes("TOKEN_PROGRAM_ID")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("token")) + 1;
      findings.push(createFinding8(
        "SOL3500",
        "Token Program ID Not Verified",
        "high",
        "Token program account should verify ID",
        path,
        lineNum,
        "Use #[account(address = token::ID)]"
      ));
    }
  }
  if (content.includes("set_authority") || content.includes("authority =")) {
    if (!content.includes("pending") && !content.includes("accept")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("authority")) + 1;
      findings.push(createFinding8(
        "SOL3501",
        "Authority Transfer Without Two-Step Process",
        "high",
        "Authority transfers should use two-step process to prevent accidents",
        path,
        lineNum,
        "Implement propose_authority() then accept_authority()"
      ));
    }
  }
  if (content.includes("#[program]") || content.includes("declare_id!")) {
    if (!content.includes("paused") && !content.includes("pause")) {
      findings.push(createFinding8(
        "SOL3502",
        "Protocol Missing Emergency Pause",
        "medium",
        "Protocols should have emergency pause functionality",
        path,
        1,
        "Implement pause mechanism for emergency response"
      ));
    }
  }
  if (content.includes("transfer") || content.includes("mint") || content.includes("burn")) {
    if (!content.includes("emit!") && !content.includes("log") && !content.includes("msg!")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("transfer") || l.includes("mint") || l.includes("burn")
      ) + 1;
      findings.push(createFinding8(
        "SOL3503",
        "State Change Without Event Emission",
        "low",
        "Important state changes should emit events for tracking",
        path,
        lineNum,
        "Add emit!() or msg!() for state changes"
      ));
    }
  }
  if (content.includes("/") && content.includes("u64")) {
    if (!content.includes("checked_div") && !content.includes("floor") && !content.includes("ceil")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("/")) + 1;
      findings.push(createFinding8(
        "SOL3504",
        "Division May Lose Precision",
        "high",
        "Integer division truncates - use checked_div and specify rounding",
        path,
        lineNum,
        "Use checked_div and handle remainder appropriately"
      ));
    }
  }
  if (content.includes("clock") && content.includes("unix_timestamp")) {
    if (content.includes("<") || content.includes(">")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("timestamp")) + 1;
      findings.push(createFinding8(
        "SOL3505",
        "Timestamp Comparison May Be Gamed",
        "medium",
        "Validators have limited ability to manipulate timestamps",
        path,
        lineNum,
        "Use reasonable tolerance for timestamp comparisons"
      ));
    }
  }
  if (content.includes("price") && content.includes("oracle")) {
    if (content.includes("settle") || content.includes("execute")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("settle") || l.includes("execute")) + 1;
      findings.push(createFinding8(
        "SOL3506",
        "Oracle Price Settlement Front-Runnable",
        "high",
        "Settlement using oracle prices can be front-run",
        path,
        lineNum,
        "Use commit-reveal or batch auctions for settlements"
      ));
    }
  }
  if (content.includes("fee") && (content.includes("%") || content.includes("bps"))) {
    if (!content.includes("max_fee") && !content.includes("MAX") && !content.includes("<=")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("fee")) + 1;
      findings.push(createFinding8(
        "SOL3507",
        "Fee Percentage Without Maximum",
        "medium",
        "Fees should have reasonable maximum cap",
        path,
        lineNum,
        "Add MAX_FEE constant and enforce it"
      ));
    }
  }
  if (content.includes("reward") && content.includes("rate")) {
    if (!content.includes("min") && !content.includes("max")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("reward")) + 1;
      findings.push(createFinding8(
        "SOL3508",
        "Reward Rate Without Bounds",
        "medium",
        "Reward rates should have minimum and maximum bounds",
        path,
        lineNum,
        "Enforce MIN_RATE <= rate <= MAX_RATE"
      ));
    }
  }
  if (content.includes("balance") && content.includes("transfer")) {
    if (!content.includes("minimum") && !content.includes("MIN")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("transfer")) + 1;
      findings.push(createFinding8(
        "SOL3509",
        "Transfer May Allow Dust Amounts",
        "low",
        "Small transfers can be used for spam attacks",
        path,
        lineNum,
        "Enforce minimum transfer amount"
      ));
    }
  }
  if (content.includes("slash") || content.includes("penalty")) {
    if (!content.includes("dispute") && !content.includes("appeal")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("slash") || l.includes("penalty")
      ) + 1;
      findings.push(createFinding8(
        "SOL3510",
        "Slashing Without Dispute Mechanism",
        "medium",
        "Slashing should have dispute/appeal process",
        path,
        lineNum,
        "Implement dispute period before finalizing slashes"
      ));
    }
  }
  if (content.includes("try_borrow_mut") && content.includes("RefCell")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("try_borrow_mut")) + 1;
    findings.push(createFinding8(
      "SOL3511",
      "Potential Race Condition in State Access",
      "high",
      "Concurrent state mutations may race",
      path,
      lineNum,
      "Ensure single writer pattern or use atomic operations"
    ));
  }
  if (content.includes("commit") && content.includes("reveal")) {
    if (!content.includes("block") && !content.includes("slot")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("reveal")) + 1;
      findings.push(createFinding8(
        "SOL3512",
        "Commit-Reveal Without Block Delay",
        "high",
        "Reveal should be delayed by minimum number of blocks",
        path,
        lineNum,
        "Require minimum block delay between commit and reveal"
      ));
    }
  }
  if (content.includes("iter") && content.includes("for")) {
    if (!content.includes("limit") && !content.includes("max_iter")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("iter")) + 1;
      findings.push(createFinding8(
        "SOL3513",
        "Unbounded Iteration May Cause DoS",
        "high",
        "Unbounded loops can exhaust compute budget",
        path,
        lineNum,
        "Add iteration limit or pagination"
      ));
    }
  }
  if (content.includes("error!") || content.includes("Error {")) {
    if (content.includes("internal") || content.includes("secret") || content.includes("key")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("error")) + 1;
      findings.push(createFinding8(
        "SOL3514",
        "Error Message May Leak Sensitive Info",
        "low",
        "Error messages should not reveal internal details",
        path,
        lineNum,
        "Use generic error messages for security-sensitive failures"
      ));
    }
  }
  if (content.includes("hash") && (content.includes("md5") || content.includes("sha1"))) {
    const lineNum = content.split("\n").findIndex(
      (l) => l.includes("md5") || l.includes("sha1")
    ) + 1;
    findings.push(createFinding8(
      "SOL3515",
      "Weak Hash Function Used",
      "high",
      "MD5 and SHA1 are cryptographically weak",
      path,
      lineNum,
      "Use SHA256 or better for cryptographic hashing"
    ));
  }
  if (content.includes("stake") && content.includes("reward")) {
    if (!content.includes("pro_rata") && !content.includes("share")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("reward")) + 1;
      findings.push(createFinding8(
        "SOL3516",
        "Staking Rewards May Not Be Fair",
        "medium",
        "Rewards should be distributed proportionally to stake",
        path,
        lineNum,
        "Calculate rewards = stake_amount * total_rewards / total_staked"
      ));
    }
  }
  if (content.includes("delegate") && content.includes("delegate")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("delegate")) + 1;
    findings.push(createFinding8(
      "SOL3517",
      "Delegation Chain May Be Unbounded",
      "medium",
      "Delegation chains should have maximum depth",
      path,
      lineNum,
      "Limit delegation depth to prevent gas bombs"
    ));
  }
  if (content.includes("batch") || content.includes("multi")) {
    if (!content.includes("max_count") && !content.includes("MAX")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("batch") || l.includes("multi")
      ) + 1;
      findings.push(createFinding8(
        "SOL3518",
        "Batch Operation Without Limit",
        "high",
        "Batch operations should have maximum count",
        path,
        lineNum,
        "Limit batch size to fit in compute budget"
      ));
    }
  }
  if (content.includes("invoke") || content.includes("call")) {
    const invokeCount = (content.match(/invoke/g) || []).length;
    if (invokeCount > 2) {
      findings.push(createFinding8(
        "SOL3519",
        "Deep Call Stack May Fail",
        "medium",
        `${invokeCount} invokes detected - may exceed CPI depth limit of 4`,
        path,
        1,
        "Reduce call depth or restructure logic"
      ));
    }
  }
  if (content.includes("liquidat")) {
    if (!content.includes("circuit_breaker") && !content.includes("pause")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("liquidat")) + 1;
      findings.push(createFinding8(
        "SOL3520",
        "Mass Liquidation Without Circuit Breaker",
        "high",
        "Liquidation cascades should trigger circuit breakers",
        path,
        lineNum,
        "Implement circuit breaker for mass liquidation events"
      ));
    }
  }
  if (content.includes("oracle") || content.includes("price_feed")) {
    if (!content.includes("timestamp") && !content.includes("updated")) {
      const lineNum = content.split("\n").findIndex(
        (l) => l.includes("oracle") || l.includes("price_feed")
      ) + 1;
      findings.push(createFinding8(
        "SOL3521",
        "Oracle Without Freshness Check",
        "critical",
        "Oracle prices must be checked for staleness",
        path,
        lineNum,
        "Verify: current_time - oracle.last_updated < MAX_STALENESS"
      ));
    }
  }
  if (content.includes("vote") && content.includes("lock")) {
    if (!content.includes("duration") && !content.includes("unlock_time")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("lock")) + 1;
      findings.push(createFinding8(
        "SOL3522",
        "Vote Lock Without Duration",
        "medium",
        "Vote locks should have specified duration",
        path,
        lineNum,
        "Set and enforce lock duration"
      ));
    }
  }
  if (content.includes("merkle") && content.includes("proof")) {
    if (!content.includes("max_depth") && !content.includes("HEIGHT")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("merkle")) + 1;
      findings.push(createFinding8(
        "SOL3523",
        "Merkle Proof Without Depth Limit",
        "medium",
        "Merkle proofs should have maximum depth",
        path,
        lineNum,
        "Limit proof depth to reasonable maximum"
      ));
    }
  }
  if (content.includes("decimals") && content.includes("mint")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("decimals")) + 1;
    findings.push(createFinding8(
      "SOL3524",
      "Verify Token Decimal Consistency",
      "medium",
      "Token operations should handle varying decimals correctly",
      path,
      lineNum,
      "Normalize amounts based on token decimals"
    ));
  }
  if (content.includes("associated_token") || content.includes("ATA")) {
    if (!content.includes("get_or_create") && !content.includes("init_if_needed")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("associated")) + 1;
      findings.push(createFinding8(
        "SOL3525",
        "ATA May Not Exist",
        "medium",
        "Associated token account should be created if missing",
        path,
        lineNum,
        "Use init_if_needed or get_associated_token_address_and_bump_seed"
      ));
    }
  }
  if (content.includes("upgrade") && content.includes("program")) {
    if (!content.includes("buffer") && !content.includes("deploy")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("upgrade")) + 1;
      findings.push(createFinding8(
        "SOL3526",
        "Program Upgrade Process Unclear",
        "medium",
        "Program upgrades should follow safe deployment process",
        path,
        lineNum,
        "Use proper upgrade buffer and deployment process"
      ));
    }
  }
  if (content.includes("config") && content.includes("load")) {
    if (!content.includes("validate") && !content.includes("check")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("config")) + 1;
      findings.push(createFinding8(
        "SOL3527",
        "Config Loaded Without Validation",
        "medium",
        "Config values should be validated after loading",
        path,
        lineNum,
        "Validate config values are within expected ranges"
      ));
    }
  }
  if (content.includes("epoch")) {
    if (!content.includes("boundary") && !content.includes("transition")) {
      const lineNum = content.split("\n").findIndex((l) => l.includes("epoch")) + 1;
      findings.push(createFinding8(
        "SOL3528",
        "Epoch Boundary Not Handled",
        "low",
        "Consider edge cases at epoch boundaries",
        path,
        lineNum,
        "Handle epoch transition cases explicitly"
      ));
    }
  }
  if (content.includes("#[derive(Accounts)]") || content.includes("AccountMeta")) {
    findings.push(createFinding8(
      "SOL3529",
      "Verify Instruction Account Order",
      "info",
      "Account order in instruction must match expected order",
      path,
      1,
      "Document and verify account order in instructions"
    ));
  }
  if (content.includes("set_return_data") || content.includes("return_data")) {
    const lineNum = content.split("\n").findIndex((l) => l.includes("return_data")) + 1;
    findings.push(createFinding8(
      "SOL3530",
      "Return Data Size Should Be Limited",
      "low",
      "Return data has maximum size limit",
      path,
      lineNum,
      "Ensure return data fits in 1024 bytes"
    ));
  }
  return findings;
}

// src/patterns/solana-batched-patterns-75.ts
var SEC3_BUSINESS_LOGIC_FINAL = [
  {
    id: "SOL3576",
    name: "State Machine Violation - Missing Transition Guard",
    severity: "critical",
    pattern: /enum\s+\w+State[\s\S]{0,300}(?!transition_guard|valid_transition|can_transition)/,
    description: "State machine lacks transition guards, allowing invalid state changes.",
    recommendation: "Implement explicit transition guards with allowed_transitions mapping."
  },
  {
    id: "SOL3577",
    name: "Invariant Violation - Balance Sum Drift",
    severity: "critical",
    pattern: /(?:deposit|withdraw|transfer)[\s\S]{0,200}(?!assert_total_balance|verify_invariant|sum_check)/,
    description: "Balance-modifying operation without invariant verification.",
    recommendation: "Add post-operation invariant check: assert!(sum(balances) == expected_total)."
  },
  {
    id: "SOL3578",
    name: "Protocol Fee Bypass - Missing Fee Enforcement",
    severity: "high",
    pattern: /(?:swap|trade|exchange)[\s\S]{0,300}(?!fee_amount|protocol_fee|take_fee)/,
    description: "Trading operation without fee enforcement allows fee bypass.",
    recommendation: "Enforce fee collection before completing transaction."
  },
  {
    id: "SOL3579",
    name: "Reward Distribution - Proportional Calculation Error",
    severity: "high",
    pattern: /reward[\s\S]{0,100}(?:\/|div)[\s\S]{0,50}(?!checked_div|safe_div|precision)/,
    description: "Reward calculation may lose precision or be manipulated.",
    recommendation: "Use high-precision math (128-bit) and verify proportional distribution."
  },
  {
    id: "SOL3580",
    name: "Epoch Boundary - Stale Data After Transition",
    severity: "medium",
    pattern: /epoch[\s\S]{0,100}(?!refresh_epoch|current_epoch|epoch_check)/,
    description: "Epoch-dependent operation without freshness check.",
    recommendation: "Verify epoch is current before using epoch-dependent data."
  },
  {
    id: "SOL3581",
    name: "Position Accounting - Share vs Amount Mismatch",
    severity: "critical",
    pattern: /(?:shares|amount)[\s\S]{0,100}(?:convert|calculate)[\s\S]{0,100}(?!rate_check|exchange_rate)/,
    description: "Share-to-amount conversion without rate verification.",
    recommendation: "Use locked exchange rate and verify before/after conversion."
  },
  {
    id: "SOL3582",
    name: "Withdrawal Queue - Priority Manipulation",
    severity: "high",
    pattern: /queue[\s\S]{0,100}(?:push|insert|add)[\s\S]{0,100}(?!timestamp|priority_lock)/,
    description: "Queue insertion without proper ordering can be manipulated.",
    recommendation: "Use timestamp-based priority with manipulation resistance."
  },
  {
    id: "SOL3583",
    name: "Atomic Operation - Partial Execution",
    severity: "critical",
    pattern: /(?:multi_transfer|batch)[\s\S]{0,200}(?!atomic|all_or_nothing|revert_on_fail)/,
    description: "Multi-step operation can fail partially, leaving inconsistent state.",
    recommendation: "Implement atomic execution with full rollback on any failure."
  },
  {
    id: "SOL3584",
    name: "Vesting Schedule - Cliff Bypass",
    severity: "high",
    pattern: /vest(?:ing)?[\s\S]{0,150}(?!cliff_check|cliff_passed|unlock_time)/,
    description: "Vesting logic may allow early withdrawal before cliff.",
    recommendation: "Enforce cliff period check before any token release."
  },
  {
    id: "SOL3585",
    name: "Auction Mechanism - Bid Manipulation",
    severity: "high",
    pattern: /(?:auction|bid)[\s\S]{0,200}(?!minimum_increment|anti_snipe|time_extension)/,
    description: "Auction lacks anti-manipulation mechanisms.",
    recommendation: "Add minimum bid increment and anti-sniping time extensions."
  }
];
var SEC3_INPUT_VALIDATION_FINAL = [
  {
    id: "SOL3586",
    name: "Seed Collision - Predictable PDA Generation",
    severity: "critical",
    pattern: /find_program_address[\s\S]{0,100}(?:user_input|external_data)[\s\S]{0,50}(?!hash|sanitize)/,
    description: "PDA seeds from user input can cause collisions.",
    recommendation: "Hash user input before using as PDA seed."
  },
  {
    id: "SOL3587",
    name: "String Length - Unbounded Input",
    severity: "medium",
    pattern: /String[\s\S]{0,50}(?!max_len|bounded|truncate|limit)/,
    description: "Unbounded string input can exhaust compute or storage.",
    recommendation: "Enforce maximum string length at input validation."
  },
  {
    id: "SOL3588",
    name: "Array Index - Unchecked Access",
    severity: "high",
    pattern: /\[[\s\S]{0,20}as\s+usize[\s\S]{0,10}\](?!.*get\(|.*get_mut\()/,
    description: "Direct array access without bounds checking.",
    recommendation: "Use .get() or .get_mut() for safe array access."
  },
  {
    id: "SOL3589",
    name: "Timestamp Future - Excessive Future Date",
    severity: "medium",
    pattern: /timestamp[\s\S]{0,100}(?:\+|add)[\s\S]{0,50}(?!max_future|reasonable_limit)/,
    description: "Timestamp can be set far into future, locking funds.",
    recommendation: "Limit maximum future timestamp to reasonable bounds."
  },
  {
    id: "SOL3590",
    name: "Percentage Overflow - Greater Than 100%",
    severity: "high",
    pattern: /(?:percent|bps|basis_points)[\s\S]{0,50}(?!<=\s*10000|<=\s*100|max_percent)/,
    description: "Percentage/BPS input can exceed 100%, causing overflow.",
    recommendation: "Validate percentage <= 10000 BPS (100%)."
  },
  {
    id: "SOL3591",
    name: "Merkle Proof - Invalid Proof Length",
    severity: "high",
    pattern: /merkle[\s\S]{0,100}proof[\s\S]{0,100}(?!len\s*==|proof_size|max_depth)/,
    description: "Merkle proof without length validation can cause DoS.",
    recommendation: "Validate proof length matches expected tree depth."
  },
  {
    id: "SOL3592",
    name: "Decimal Precision - Inconsistent Decimals",
    severity: "high",
    pattern: /decimals[\s\S]{0,100}(?!normalize|scale|convert_decimals)/,
    description: "Token decimal handling without normalization.",
    recommendation: "Normalize all token amounts to consistent decimal places."
  },
  {
    id: "SOL3593",
    name: "Vector Capacity - Unbounded Growth",
    severity: "medium",
    pattern: /Vec::(?:new|with_capacity)[\s\S]{0,100}(?:push|extend)[\s\S]{0,100}(?!max_len|capacity_check)/,
    description: "Vector can grow unbounded, exhausting compute.",
    recommendation: "Enforce maximum vector capacity limits."
  },
  {
    id: "SOL3594",
    name: "Negative Amount - Unsigned Underflow",
    severity: "critical",
    pattern: /amount[\s\S]{0,50}(?:checked_sub|saturating_sub)[\s\S]{0,30}(?!>=|zero_check)/,
    description: "Subtraction may underflow even with checked math if not validated.",
    recommendation: "Validate amount >= subtrahend before subtraction."
  },
  {
    id: "SOL3595",
    name: "Slot Number - Past Slot Manipulation",
    severity: "medium",
    pattern: /slot[\s\S]{0,50}(?!>=\s*current|future_slot|slot_check)/,
    description: "Slot number validation allows past slots.",
    recommendation: "Require slot >= current_slot for future-dated operations."
  }
];
var SEC3_ACCESS_CONTROL_FINAL = [
  {
    id: "SOL3596",
    name: "Role Hierarchy - Missing Inheritance Check",
    severity: "high",
    pattern: /role[\s\S]{0,100}(?:admin|operator|manager)[\s\S]{0,100}(?!inherits|hierarchy|parent_role)/,
    description: "Role-based access without hierarchy verification.",
    recommendation: "Implement role hierarchy with proper inheritance checks."
  },
  {
    id: "SOL3597",
    name: "Capability Escalation - Self-Promotion",
    severity: "critical",
    pattern: /set_role|grant_permission[\s\S]{0,100}(?!admin_only|require_admin|authorized_grantor)/,
    description: "Role granting without proper authorization allows self-promotion.",
    recommendation: "Only authorized administrators can grant elevated roles."
  },
  {
    id: "SOL3598",
    name: "Emergency Mode - Insufficient Protection",
    severity: "critical",
    pattern: /emergency[\s\S]{0,100}(?:pause|freeze|shutdown)[\s\S]{0,100}(?!multisig|timelock|guardian)/,
    description: "Emergency controls without adequate protection.",
    recommendation: "Use multisig or guardian council for emergency actions."
  },
  {
    id: "SOL3599",
    name: "Delegate Authority - Revocation Missing",
    severity: "high",
    pattern: /delegate[\s\S]{0,100}(?:authority|permission)[\s\S]{0,100}(?!revoke|expiration|time_limit)/,
    description: "Delegated authority without revocation mechanism.",
    recommendation: "Implement expiration or explicit revocation for delegations."
  },
  {
    id: "SOL3600",
    name: "Ownership Transfer - Two-Step Missing",
    severity: "high",
    pattern: /transfer_ownership|set_owner[\s\S]{0,150}(?!pending_owner|accept_ownership|two_step)/,
    description: "Single-step ownership transfer risks permanent loss.",
    recommendation: "Use two-step ownership transfer with acceptance."
  },
  {
    id: "SOL3601",
    name: "Whitelist Bypass - Empty Check",
    severity: "high",
    pattern: /whitelist[\s\S]{0,100}(?:contains|check)[\s\S]{0,100}(?!is_empty|len\s*>|non_empty)/,
    description: "Empty whitelist may allow all or deny all unexpectedly.",
    recommendation: "Handle empty whitelist case explicitly."
  },
  {
    id: "SOL3602",
    name: "Time-Based Access - Clock Manipulation",
    severity: "medium",
    pattern: /Clock::get[\s\S]{0,100}(?:start_time|end_time)[\s\S]{0,100}(?!slot_based|block_height)/,
    description: "Time-based access using only clock can be manipulated.",
    recommendation: "Use slot-based timing for manipulation resistance."
  },
  {
    id: "SOL3603",
    name: "Cross-Program Authority - CPI Privilege",
    severity: "critical",
    pattern: /invoke_signed[\s\S]{0,150}(?!caller_check|program_origin|authorized_caller)/,
    description: "CPI with PDA signing without caller verification.",
    recommendation: "Verify calling program is authorized before CPI signing."
  },
  {
    id: "SOL3604",
    name: "Nonce Authority - Unauthorized Usage",
    severity: "high",
    pattern: /nonce[\s\S]{0,100}(?:advance|authorize)[\s\S]{0,100}(?!authority_check|signer_check)/,
    description: "Nonce account operations without authority verification.",
    recommendation: "Verify nonce authority before operations."
  },
  {
    id: "SOL3605",
    name: "Program Authority - Upgrade Without Timelock",
    severity: "high",
    pattern: /upgrade_authority|SetAuthority[\s\S]{0,100}(?!timelock|delay|governance)/,
    description: "Program upgrade authority without delay mechanism.",
    recommendation: "Implement timelock for program upgrades."
  }
];
var HELIUS_COMPLETE_HISTORY = [
  {
    id: "SOL3606",
    name: "Cypher Protocol ($1M) - Unsafe Deserialization",
    severity: "critical",
    pattern: /try_from_slice|deserialize[\s\S]{0,100}(?!verify_discriminator|type_check|version_check)/,
    description: "Account deserialization without type verification (Cypher exploit).",
    recommendation: "Verify account discriminator and version before deserializing."
  },
  {
    id: "SOL3607",
    name: "Marinade Finance ($0) - Stake Account Validation",
    severity: "high",
    pattern: /stake_account|StakeState[\s\S]{0,100}(?!verify_delegation|validator_check)/,
    description: "Stake account operations without proper validation.",
    recommendation: "Verify stake account delegation and validator identity."
  },
  {
    id: "SOL3608",
    name: "Tulip Protocol ($0) - Strategy Vault Confusion",
    severity: "high",
    pattern: /strategy|vault[\s\S]{0,100}(?!strategy_check|vault_type|authorized_strategy)/,
    description: "Vault strategy operations without type verification.",
    recommendation: "Verify strategy type matches expected vault strategy."
  },
  {
    id: "SOL3609",
    name: "Synthetify ($0) - Synthetic Asset Minting",
    severity: "critical",
    pattern: /synthetic|mint_synthetic[\s\S]{0,100}(?!collateral_ratio|backing_check)/,
    description: "Synthetic asset minting without collateral verification.",
    recommendation: "Verify collateral ratio meets minimum requirements."
  },
  {
    id: "SOL3610",
    name: "Jet Protocol ($0) - Interest Rate Model",
    severity: "high",
    pattern: /interest_rate|utilization[\s\S]{0,100}(?!rate_bounds|max_rate|curve_check)/,
    description: "Interest rate calculation without bounds checking.",
    recommendation: "Enforce rate bounds and validate utilization curve."
  },
  {
    id: "SOL3611",
    name: "Saber Protocol - LP Token Accounting",
    severity: "high",
    pattern: /lp_token|pool_token[\s\S]{0,100}(?!supply_check|mint_verify)/,
    description: "LP token operations without supply verification.",
    recommendation: "Verify LP token supply matches pool reserves."
  },
  {
    id: "SOL3612",
    name: "Mercurial Finance - Stable Swap Imbalance",
    severity: "high",
    pattern: /stable_swap|curve[\s\S]{0,100}(?!imbalance_check|a_factor|amplification)/,
    description: "Stable swap without imbalance protection.",
    recommendation: "Check pool imbalance and amplification factor bounds."
  },
  {
    id: "SOL3613",
    name: "Orca Whirlpool - Position Range Validation",
    severity: "high",
    pattern: /tick_lower|tick_upper[\s\S]{0,100}(?!range_check|tick_spacing|valid_range)/,
    description: "Concentrated liquidity position without range validation.",
    recommendation: "Validate tick range adheres to pool tick spacing."
  },
  {
    id: "SOL3614",
    name: "Lifinity - Proactive Market Making",
    severity: "medium",
    pattern: /oracle[\s\S]{0,100}rebalance[\s\S]{0,100}(?!frequency_limit|cooldown)/,
    description: "Oracle-based rebalancing without frequency limits.",
    recommendation: "Limit rebalancing frequency to prevent manipulation."
  },
  {
    id: "SOL3615",
    name: "Phoenix DEX - Order Matching Priority",
    severity: "medium",
    pattern: /order[\s\S]{0,100}match[\s\S]{0,100}(?!price_time_priority|fifo)/,
    description: "Order matching without proper priority enforcement.",
    recommendation: "Enforce price-time priority for fair order matching."
  }
];
var ARXIV_RESEARCH_PATTERNS = [
  {
    id: "SOL3616",
    name: "BPF Verifier Bypass - Unchecked Division",
    severity: "critical",
    pattern: /\/[\s\S]{0,30}(?!checked_div|safe_div|zero_check)/,
    description: "Division without zero check may bypass BPF verifier.",
    recommendation: "Use checked_div or verify divisor != 0."
  },
  {
    id: "SOL3617",
    name: "Stack Overflow - Deep Recursion",
    severity: "high",
    pattern: /fn\s+\w+[\s\S]{0,100}self\.\w+\(|recursive/,
    description: "Recursive function may cause stack overflow.",
    recommendation: "Convert recursion to iteration or limit depth."
  },
  {
    id: "SOL3618",
    name: "Compute Budget - Unbounded Loop",
    severity: "high",
    pattern: /for[\s\S]{0,30}\.iter\(\)[\s\S]{0,50}(?!take\(|limit|max_iterations)/,
    description: "Unbounded iteration may exceed compute budget.",
    recommendation: "Limit iteration count or use pagination."
  },
  {
    id: "SOL3619",
    name: "Account Reallocation - Data Loss",
    severity: "high",
    pattern: /realloc[\s\S]{0,100}(?!copy|preserve|migrate)/,
    description: "Account reallocation may lose existing data.",
    recommendation: "Preserve existing data when reallocating accounts."
  },
  {
    id: "SOL3620",
    name: "Sysvar Spoofing - Invalid Sysvar",
    severity: "critical",
    pattern: /sysvar[\s\S]{0,50}(?!from_account_info|check_id|verify_sysvar)/,
    description: "Sysvar account without proper validation can be spoofed.",
    recommendation: "Use from_account_info to validate sysvar accounts."
  },
  {
    id: "SOL3621",
    name: "Program Data - Version Mismatch",
    severity: "medium",
    pattern: /program_data|ProgramData[\s\S]{0,100}(?!version_check|upgrade_authority)/,
    description: "Program data access without version verification.",
    recommendation: "Verify program data version and upgrade authority."
  },
  {
    id: "SOL3622",
    name: "Loader Confusion - Wrong Loader",
    severity: "high",
    pattern: /bpf_loader|loader[\s\S]{0,100}(?!loader_check|correct_loader)/,
    description: "Program loader not verified may allow exploitation.",
    recommendation: "Verify program uses expected loader (BPF Loader 2)."
  },
  {
    id: "SOL3623",
    name: "Account Rent - Exempt Status Change",
    severity: "medium",
    pattern: /lamports[\s\S]{0,100}(?:sub|transfer)[\s\S]{0,100}(?!rent_exempt|minimum_balance)/,
    description: "Lamport withdrawal may break rent-exempt status.",
    recommendation: "Verify account remains rent-exempt after withdrawal."
  },
  {
    id: "SOL3624",
    name: "Clock Sysvar - Slot Drift",
    severity: "low",
    pattern: /Clock::get[\s\S]{0,50}unix_timestamp[\s\S]{0,50}(?!slot_for_time|drift_check)/,
    description: "Clock sysvar timestamp may drift from actual time.",
    recommendation: "Use slot-based timing for precision-critical operations."
  },
  {
    id: "SOL3625",
    name: "Epoch Info - Stale Epoch Data",
    severity: "low",
    pattern: /EpochInfo[\s\S]{0,100}(?!current_epoch|epoch_refresh)/,
    description: "Epoch info may be stale across epoch boundaries.",
    recommendation: "Refresh epoch info for epoch-sensitive operations."
  }
];
var EMERGING_2026_PATTERNS = [
  {
    id: "SOL3626",
    name: "Token-2022 Transfer Hook - Reentrancy via Hook",
    severity: "critical",
    pattern: /transfer_hook|TransferHook[\s\S]{0,100}(?!reenter_guard|hook_lock)/,
    description: "Token-2022 transfer hooks enable reentrancy attacks.",
    recommendation: "Implement reentrancy guard in transfer hook handlers."
  },
  {
    id: "SOL3627",
    name: "Confidential Transfers - Amount Verification",
    severity: "high",
    pattern: /confidential[\s\S]{0,100}transfer[\s\S]{0,100}(?!range_proof|verify_amount)/,
    description: "Confidential transfer without amount range proof.",
    recommendation: "Verify range proofs for confidential transfer amounts."
  },
  {
    id: "SOL3628",
    name: "Lookup Tables - Stale Entry Reference",
    severity: "medium",
    pattern: /AddressLookupTable[\s\S]{0,100}(?!deactivation_slot|is_active)/,
    description: "Lookup table reference without freshness check.",
    recommendation: "Verify lookup table is active and not deactivating."
  },
  {
    id: "SOL3629",
    name: "Blink Actions - URL Parameter Injection",
    severity: "high",
    pattern: /actions\.json|blink[\s\S]{0,100}(?!sanitize|validate_url|escape)/,
    description: "Blink action URLs without sanitization.",
    recommendation: "Sanitize and validate all Blink action parameters."
  },
  {
    id: "SOL3630",
    name: "Compressed NFT - Invalid Leaf Update",
    severity: "high",
    pattern: /cnft|compressed[\s\S]{0,100}update[\s\S]{0,100}(?!merkle_verify|proof_check)/,
    description: "cNFT leaf update without proof verification.",
    recommendation: "Verify merkle proof before updating compressed NFT."
  },
  {
    id: "SOL3631",
    name: "Jito Bundle - MEV Sandwich Protection",
    severity: "high",
    pattern: /swap|trade[\s\S]{0,200}(?!bundle|jito|private|mev_protect)/i,
    description: "Trade without MEV protection is vulnerable to sandwich.",
    recommendation: "Use Jito bundles or private transactions for trades."
  },
  {
    id: "SOL3632",
    name: "Priority Fee - Griefing Attack",
    severity: "medium",
    pattern: /compute_budget|priority_fee[\s\S]{0,100}(?!max_fee|fee_limit)/,
    description: "Unbounded priority fees enable griefing attacks.",
    recommendation: "Implement maximum priority fee limits."
  },
  {
    id: "SOL3633",
    name: "Versioned Transactions - Legacy Fallback",
    severity: "low",
    pattern: /Transaction[\s\S]{0,50}(?!versioned|message_version|v0)/,
    description: "Legacy transaction format limits functionality.",
    recommendation: "Use versioned transactions (v0) for new features."
  },
  {
    id: "SOL3634",
    name: "Durable Nonce - Expiration Handling",
    severity: "medium",
    pattern: /durable_nonce|nonce_account[\s\S]{0,100}(?!expiration|advance_nonce)/,
    description: "Durable nonce without expiration handling.",
    recommendation: "Handle nonce expiration and advancement properly."
  },
  {
    id: "SOL3635",
    name: "Stake Pool - Validator Selection Manipulation",
    severity: "high",
    pattern: /stake_pool[\s\S]{0,100}validator[\s\S]{0,100}(?!commission_check|performance)/,
    description: "Stake pool validator selection without performance check.",
    recommendation: "Verify validator commission and historical performance."
  }
];
var ADDITIONAL_DEEP_PATTERNS = [
  // Protocol-Specific Deep Patterns
  {
    id: "SOL3636",
    name: "Perpetuals - Funding Rate Manipulation",
    severity: "critical",
    pattern: /funding_rate|mark_price[\s\S]{0,100}(?!twap|time_window|rate_cap)/,
    description: "Perpetual funding rate without manipulation protection.",
    recommendation: "Use TWAP for mark price and cap funding rate changes."
  },
  {
    id: "SOL3637",
    name: "Options - Greeks Calculation",
    severity: "high",
    pattern: /delta|gamma|theta[\s\S]{0,100}(?!iv_check|time_decay|precision)/,
    description: "Options Greeks calculation without precision handling.",
    recommendation: "Use high-precision math for Greeks calculations."
  },
  {
    id: "SOL3638",
    name: "Lending - Utilization Spike",
    severity: "high",
    pattern: /utilization[\s\S]{0,100}(?!rate_smoothing|gradual_change)/,
    description: "Interest rate spikes on utilization changes.",
    recommendation: "Implement rate smoothing to prevent sudden spikes."
  },
  {
    id: "SOL3639",
    name: "AMM - Virtual Reserves Manipulation",
    severity: "critical",
    pattern: /virtual_reserve|virtual_balance[\s\S]{0,100}(?!real_balance_check|bounds)/,
    description: "Virtual reserves without real balance verification.",
    recommendation: "Verify virtual reserves match real token balances."
  },
  {
    id: "SOL3640",
    name: "Yield Aggregator - Strategy Exit Delay",
    severity: "medium",
    pattern: /withdraw[\s\S]{0,100}strategy[\s\S]{0,100}(?!delay|timelock|queue)/,
    description: "Strategy withdrawal without delay allows front-running.",
    recommendation: "Implement withdrawal delay or queuing mechanism."
  },
  {
    id: "SOL3641",
    name: "Governance - Flash Loan Voting",
    severity: "critical",
    pattern: /vote|proposal[\s\S]{0,100}(?!snapshot|voting_escrow|time_lock)/,
    description: "Governance voting vulnerable to flash loan attacks.",
    recommendation: "Use voting escrow or snapshot-based voting power."
  },
  {
    id: "SOL3642",
    name: "Insurance Fund - Underfunding",
    severity: "high",
    pattern: /insurance[\s\S]{0,100}fund[\s\S]{0,100}(?!minimum_balance|coverage_ratio)/,
    description: "Insurance fund without minimum coverage requirements.",
    recommendation: "Maintain minimum insurance fund coverage ratio."
  },
  {
    id: "SOL3643",
    name: "Liquidation - Cascade Prevention",
    severity: "critical",
    pattern: /liquidat[\s\S]{0,100}(?!batch_limit|cascade_check|max_liquidation)/,
    description: "Liquidation without cascade prevention.",
    recommendation: "Limit liquidation batch size to prevent cascades."
  },
  {
    id: "SOL3644",
    name: "Cross-Margin - Position Isolation",
    severity: "high",
    pattern: /cross_margin|portfolio[\s\S]{0,100}(?!isolation|max_exposure)/,
    description: "Cross-margin without position isolation limits.",
    recommendation: "Implement per-asset exposure limits in cross-margin."
  },
  {
    id: "SOL3645",
    name: "Fee Tier - Inconsistent Application",
    severity: "medium",
    pattern: /fee_tier|fee_rate[\s\S]{0,100}(?!consistent|standardized)/,
    description: "Fee tier application inconsistent across operations.",
    recommendation: "Standardize fee tier calculation and application."
  },
  // Wallet & Infrastructure Patterns
  {
    id: "SOL3646",
    name: "Wallet Adapter - Unsafe Connection",
    severity: "high",
    pattern: /wallet[\s\S]{0,50}connect[\s\S]{0,100}(?!verify|standard_wallet)/i,
    description: "Wallet connection without adapter verification.",
    recommendation: "Use standard wallet adapter with verification."
  },
  {
    id: "SOL3647",
    name: "RPC Endpoint - Untrusted Source",
    severity: "medium",
    pattern: /rpc[\s\S]{0,50}(?:url|endpoint)[\s\S]{0,50}(?!trusted|allowlist)/i,
    description: "RPC endpoint from untrusted source.",
    recommendation: "Use trusted RPC endpoints from allowlist."
  },
  {
    id: "SOL3648",
    name: "Transaction Simulation - Skip Preflight",
    severity: "medium",
    pattern: /skip[_-]?preflight|preflightCommitment[\s\S]{0,30}null/i,
    description: "Skipping preflight simulation hides errors.",
    recommendation: "Always run preflight simulation for error detection."
  },
  {
    id: "SOL3649",
    name: "Blockhash Caching - Stale Hash",
    severity: "medium",
    pattern: /blockhash[\s\S]{0,100}cache[\s\S]{0,100}(?!refresh|ttl|expire)/,
    description: "Cached blockhash may become stale.",
    recommendation: "Implement blockhash caching with short TTL."
  },
  {
    id: "SOL3650",
    name: "Commitment Level - Inconsistent",
    severity: "low",
    pattern: /commitment[\s\S]{0,30}(?:processed|confirmed|finalized)[\s\S]{0,100}(?!consistent)/,
    description: "Inconsistent commitment levels across operations.",
    recommendation: "Use consistent commitment level (finalized for critical ops)."
  },
  // Additional Security Patterns
  {
    id: "SOL3651",
    name: "Seed Phrase - Exposure Risk",
    severity: "critical",
    pattern: /mnemonic|seed_phrase|recovery[\s\S]{0,50}(?!encrypt|secure_store)/i,
    description: "Seed phrase handling without encryption.",
    recommendation: "Never store or transmit seed phrases unencrypted."
  },
  {
    id: "SOL3652",
    name: "Private Key - Memory Exposure",
    severity: "critical",
    pattern: /private_key|secret_key[\s\S]{0,100}(?!zeroize|secure_memory)/,
    description: "Private key in memory without secure handling.",
    recommendation: "Use zeroize and secure memory for private keys."
  },
  {
    id: "SOL3653",
    name: "Transaction Logging - Sensitive Data",
    severity: "high",
    pattern: /log|print|debug[\s\S]{0,50}(?:key|secret|private|password)/i,
    description: "Logging may expose sensitive data.",
    recommendation: "Never log sensitive data like keys or secrets."
  },
  {
    id: "SOL3654",
    name: "Error Message - Information Leak",
    severity: "low",
    pattern: /Error[\s\S]{0,100}(?:address|amount|balance|internal)/,
    description: "Error messages may leak sensitive information.",
    recommendation: "Use generic error messages for security-sensitive failures."
  },
  {
    id: "SOL3655",
    name: "Randomness Source - Predictable",
    severity: "critical",
    pattern: /random|rand[\s\S]{0,100}(?!vrf|chainlink|switchboard)/i,
    description: "On-chain randomness is predictable.",
    recommendation: "Use VRF (Switchboard, Chainlink) for secure randomness."
  },
  // Final Protocol Patterns
  {
    id: "SOL3656",
    name: "Token Freeze - Authority Check",
    severity: "high",
    pattern: /freeze[\s\S]{0,100}(?!authority_check|freeze_authority)/,
    description: "Freeze operations without authority verification.",
    recommendation: "Verify freeze authority before freeze operations."
  },
  {
    id: "SOL3657",
    name: "Mint Authority - Centralization",
    severity: "medium",
    pattern: /mint_authority[\s\S]{0,100}(?!multisig|dao|decentralized)/,
    description: "Centralized mint authority is a security risk.",
    recommendation: "Use multisig or DAO for mint authority."
  },
  {
    id: "SOL3658",
    name: "Close Authority - Denial of Service",
    severity: "high",
    pattern: /close_authority[\s\S]{0,100}(?!user_check|owner_only)/,
    description: "Close authority may enable account DoS.",
    recommendation: "Restrict close authority to account owner."
  },
  {
    id: "SOL3659",
    name: "Permanent Delegate - Token Theft",
    severity: "critical",
    pattern: /permanent_delegate|PermanentDelegate[\s\S]{0,100}(?!warn|user_consent)/,
    description: "Permanent delegate enables token theft.",
    recommendation: "Warn users about permanent delegate implications."
  },
  {
    id: "SOL3660",
    name: "Non-Transferable - Bypass",
    severity: "high",
    pattern: /non_transferable|NonTransferable[\s\S]{0,100}(?!burn_check|wrap_prevent)/,
    description: "Non-transferable token may be bypassed via wrap.",
    recommendation: "Prevent wrapping of non-transferable tokens."
  },
  // Final Security Patterns
  {
    id: "SOL3661",
    name: "Account Data Injection - Untrusted Parsing",
    severity: "critical",
    pattern: /try_from_slice[\s\S]{0,50}account\.data[\s\S]{0,50}(?!sanitize|validate)/,
    description: "Account data parsed without sanitization.",
    recommendation: "Validate and sanitize all account data before parsing."
  },
  {
    id: "SOL3662",
    name: "Program Invocation - Unbounded Depth",
    severity: "high",
    pattern: /invoke[\s\S]{0,100}invoke[\s\S]{0,100}(?!depth_check|max_depth)/,
    description: "Nested CPI without depth limit.",
    recommendation: "Track and limit CPI depth to prevent DoS."
  },
  {
    id: "SOL3663",
    name: "Account Seed - Collision Attack",
    severity: "high",
    pattern: /seeds[\s\S]{0,50}(?:&\[|vec!)[\s\S]{0,100}(?!unique|hash|nonce)/,
    description: "PDA seeds may collide without unique component.",
    recommendation: "Include unique identifier in PDA seeds."
  },
  {
    id: "SOL3664",
    name: "Instruction Data - Size Limit",
    severity: "medium",
    pattern: /instruction[\s\S]{0,50}data[\s\S]{0,100}(?!max_size|len_check)/,
    description: "Instruction data without size validation.",
    recommendation: "Validate instruction data size before processing."
  },
  {
    id: "SOL3665",
    name: "Account List - Duplicate Entry",
    severity: "high",
    pattern: /accounts[\s\S]{0,100}iter[\s\S]{0,100}(?!unique|dedup|no_duplicate)/,
    description: "Account list may contain duplicates.",
    recommendation: "Validate accounts list has no duplicates."
  },
  // Final Patterns
  {
    id: "SOL3666",
    name: "Token Account - ATA Mismatch",
    severity: "high",
    pattern: /get_associated_token_address[\s\S]{0,100}(?!verify|check_ata)/,
    description: "ATA address not verified against expected.",
    recommendation: "Verify ATA matches expected derivation."
  },
  {
    id: "SOL3667",
    name: "Metadata Account - Tampering",
    severity: "medium",
    pattern: /metadata[\s\S]{0,100}(?!verify_creator|verify_collection)/,
    description: "NFT metadata without creator/collection verification.",
    recommendation: "Verify metadata creator and collection."
  },
  {
    id: "SOL3668",
    name: "Edition Account - Supply Overflow",
    severity: "high",
    pattern: /edition[\s\S]{0,100}supply[\s\S]{0,100}(?!max_supply|supply_check)/,
    description: "Edition supply modification without limit check.",
    recommendation: "Enforce maximum supply for editions."
  },
  {
    id: "SOL3669",
    name: "Master Edition - Unauthorized Print",
    severity: "critical",
    pattern: /master_edition[\s\S]{0,100}print[\s\S]{0,100}(?!authority_check)/,
    description: "Edition printing without authority verification.",
    recommendation: "Verify print authority before creating editions."
  },
  {
    id: "SOL3670",
    name: "Collection Verification - Bypass",
    severity: "high",
    pattern: /collection[\s\S]{0,100}verified[\s\S]{0,100}(?!authority_check)/,
    description: "Collection verification without authority check.",
    recommendation: "Only collection authority can verify NFTs."
  },
  {
    id: "SOL3671",
    name: "Creator Royalties - Enforcement",
    severity: "medium",
    pattern: /creator[\s\S]{0,100}royalt[\s\S]{0,100}(?!pnft|enforce|programmable)/,
    description: "Royalties not enforced (non-programmable NFT).",
    recommendation: "Use programmable NFTs for enforced royalties."
  },
  {
    id: "SOL3672",
    name: "Token Record - State Mismatch",
    severity: "high",
    pattern: /TokenRecord[\s\S]{0,100}(?!state_check|valid_state)/,
    description: "Token record state not validated.",
    recommendation: "Verify token record state matches expected."
  },
  {
    id: "SOL3673",
    name: "Rule Set - Authorization",
    severity: "high",
    pattern: /rule_set|RuleSet[\s\S]{0,100}(?!authority|authorized_update)/,
    description: "Rule set modification without authorization.",
    recommendation: "Verify rule set authority before updates."
  },
  {
    id: "SOL3674",
    name: "Delegate Role - Scope Creep",
    severity: "medium",
    pattern: /delegate[\s\S]{0,100}role[\s\S]{0,100}(?!scope|limited|specific)/,
    description: "Delegate role without scope limitation.",
    recommendation: "Limit delegate role to specific operations."
  },
  {
    id: "SOL3675",
    name: "Authorization Record - Expiration",
    severity: "medium",
    pattern: /authorization[\s\S]{0,100}(?!expiration|time_limit|revoke)/,
    description: "Authorization without expiration.",
    recommendation: "Set expiration for all authorizations."
  }
];
var ALL_BATCH_75_PATTERNS = [
  ...SEC3_BUSINESS_LOGIC_FINAL,
  ...SEC3_INPUT_VALIDATION_FINAL,
  ...SEC3_ACCESS_CONTROL_FINAL,
  ...HELIUS_COMPLETE_HISTORY,
  ...ARXIV_RESEARCH_PATTERNS,
  ...EMERGING_2026_PATTERNS,
  ...ADDITIONAL_DEEP_PATTERNS
];
function checkBatch75Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of ALL_BATCH_75_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}
var BATCH_75_PATTERN_COUNT = ALL_BATCH_75_PATTERNS.length;

// src/patterns/solana-batched-patterns-76.ts
function findLineNumber2(content, charIndex) {
  const lines = content.substring(0, charIndex).split("\n");
  return lines.length;
}
function getCodeSnippet(content, lineNum, context = 2) {
  const lines = content.split("\n");
  const start = Math.max(0, lineNum - context - 1);
  const end = Math.min(lines.length, lineNum + context);
  return lines.slice(start, end).join("\n").substring(0, 200);
}
function checkBatch76Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || "unknown";
  if (!content) return findings;
  const reinitPatterns = [
    /init\s*(?!.*constraint.*is_initialized)/gi,
    /initialize.*pub\s+fn.*(?!.*require.*!.*initialized)/gis
  ];
  reinitPatterns.forEach((pattern) => {
    const matches = content.matchAll(pattern);
    for (const match of matches) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3676",
        title: "Account Reinitialization Vulnerability",
        severity: "critical",
        description: "Account can be reinitialized, allowing attacker to reset state and potentially steal funds. The Solend 2021 attack exploited similar missing init checks.",
        location: { file: fileName, line: lineNum },
        recommendation: "Add is_initialized check: require!(!account.is_initialized, ErrorCode::AlreadyInitialized)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  });
  const arbitraryCpiPattern = /invoke(?:_signed)?\s*\(\s*&\s*\w+\s*,/gi;
  const matches3677 = content.matchAll(arbitraryCpiPattern);
  for (const match of matches3677) {
    const context = content.substring(Math.max(0, (match.index || 0) - 100), (match.index || 0) + 200);
    if (!context.includes("program_id ==") && !context.includes("require!") && !context.includes("TOKEN_PROGRAM_ID")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3677",
        title: "Arbitrary CPI Target Vulnerability",
        severity: "critical",
        description: "CPI call without validating target program. Attacker could redirect call to malicious program.",
        location: { file: fileName, line: lineNum },
        recommendation: "Hardcode expected program IDs or validate against allowlist before CPI",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const sysvarPattern = /sysvar::instructions|Instructions::load/gi;
  const matches3678 = content.matchAll(sysvarPattern);
  for (const match of matches3678) {
    const context = content.substring(match.index || 0, (match.index || 0) + 300);
    if (!context.includes("verify") && !context.includes("check") && !context.includes("validate")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3678",
        title: "Unvalidated Instruction Sysvar Access",
        severity: "high",
        description: "Instructions sysvar accessed without validation. Step Finance $40M hack exploited instruction introspection.",
        location: { file: fileName, line: lineNum },
        recommendation: "Validate instruction sysvar data and verify expected instruction sequence",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const accountsPattern = /#\[derive\(Accounts\)\][\s\S]*?pub\s+struct\s+\w+[\s\S]*?\{[\s\S]*?\}/g;
  const matches3679 = content.matchAll(accountsPattern);
  for (const match of matches3679) {
    const accountsContent = match[0];
    const accountNames = accountsContent.match(/pub\s+(\w+)\s*:/g) || [];
    if (accountNames.length > 2 && !accountsContent.includes("constraint") && !accountsContent.includes("key()")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3679",
        title: "Potential Duplicate Account Vulnerability",
        severity: "medium",
        description: "Multiple accounts without uniqueness constraints. Attacker could pass same account twice.",
        location: { file: fileName, line: lineNum },
        recommendation: "Add constraints: constraint = account1.key() != account2.key()",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const pdaInitPattern = /seeds\s*=\s*\[[\s\S]*?\]\s*,\s*bump(?!\s*=)/gi;
  const matches3680 = content.matchAll(pdaInitPattern);
  for (const match of matches3680) {
    const lineNum = findLineNumber2(content, match.index || 0);
    findings.push({
      id: "SOL3680",
      title: "PDA Bump Seed Not Stored",
      severity: "high",
      description: "PDA created without storing bump seed. Non-canonical bumps could create shadow PDAs.",
      location: { file: fileName, line: lineNum },
      recommendation: "Store bump in account: bump = vault.bump, and verify on subsequent access",
      code: getCodeSnippet(content, lineNum)
    });
  }
  const setAuthPattern = /set_authority|SetAuthority|transfer_authority/gi;
  const matches3681 = content.matchAll(setAuthPattern);
  for (const match of matches3681) {
    const context = content.substring(Math.max(0, (match.index || 0) - 100), (match.index || 0) + 200);
    if (!context.includes("timelock") && !context.includes("delay") && !context.includes("multisig")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3681",
        title: "Authority Transfer Without Timelock",
        severity: "critical",
        description: "Authority transfer without timelock. Owner phishing attacks in Dec 2025-Feb 2026 exploited instant authority transfers.",
        location: { file: fileName, line: lineNum },
        recommendation: "Add timelock: require!(current_time > pending_authority_time + TIMELOCK_PERIOD)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const approvePattern = /approve|Approve|delegate/gi;
  const matches3682 = content.matchAll(approvePattern);
  for (const match of matches3682) {
    const context = content.substring(match.index || 0, (match.index || 0) + 200);
    if (!context.includes("amount") || context.includes("u64::MAX") || context.includes("unlimited")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3682",
        title: "Unlimited Token Approval",
        severity: "high",
        description: "Token approval without amount limits. Phishing attacks trick users into unlimited approvals.",
        location: { file: fileName, line: lineNum },
        recommendation: "Always specify exact approval amounts, never use unlimited approvals",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const ownerChangePattern = /owner\s*=|set_owner|change_owner|new_owner/gi;
  const matches3683 = content.matchAll(ownerChangePattern);
  for (const match of matches3683) {
    const context = content.substring(Math.max(0, (match.index || 0) - 150), (match.index || 0) + 150);
    if (!context.includes("pending") && !context.includes("accept") && !context.includes("confirm")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3683",
        title: "Single-Step Owner Change",
        severity: "high",
        description: "Ownership transfer in single transaction. Should require two-step (propose + accept) pattern.",
        location: { file: fileName, line: lineNum },
        recommendation: "Implement two-step ownership: set_pending_owner() then accept_ownership()",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const adminKeyPattern = /admin_key|executive|master_key|root_authority/gi;
  const matches3684 = content.matchAll(adminKeyPattern);
  for (const match of matches3684) {
    const context = content.substring(Math.max(0, (match.index || 0) - 100), (match.index || 0) + 200);
    if (!context.includes("multisig") && !context.includes("threshold") && !context.includes("timelock")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3684",
        title: "Single Admin Key Without Multisig",
        severity: "critical",
        description: "Executive/admin key without multisig protection. Step Finance $40M hack targeted executive vulnerability.",
        location: { file: fileName, line: lineNum },
        recommendation: "Use multisig (e.g., Squads) for all admin operations",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const emergencyPattern = /emergency|rescue|recover|admin_withdraw/gi;
  const matches3685 = content.matchAll(emergencyPattern);
  for (const match of matches3685) {
    const context = content.substring(match.index || 0, (match.index || 0) + 300);
    if (!context.includes("limit") && !context.includes("cap") && !context.includes("timelock")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3685",
        title: "Unlimited Emergency Withdrawal",
        severity: "critical",
        description: "Emergency withdrawal without limits. Compromised admin can drain entire protocol.",
        location: { file: fileName, line: lineNum },
        recommendation: "Add withdrawal limits and timelock: require!(amount <= EMERGENCY_LIMIT)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const largeTransferPattern = /transfer|withdraw|drain/gi;
  const matches3686 = content.matchAll(largeTransferPattern);
  for (const match of matches3686) {
    const context = content.substring(Math.max(0, (match.index || 0) - 200), (match.index || 0) + 200);
    if (!context.includes("circuit") && !context.includes("pause") && !context.includes("halt") && !context.includes("limit")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      if (context.includes("vault") || context.includes("pool") || context.includes("treasury")) {
        findings.push({
          id: "SOL3686",
          title: "Missing Circuit Breaker",
          severity: "high",
          description: "Large fund movements without circuit breaker. Step Finance needed manual intervention.",
          location: { file: fileName, line: lineNum },
          recommendation: "Implement circuit breaker: auto-pause when withdrawal > X% of TVL in Y time",
          code: getCodeSnippet(content, lineNum)
        });
      }
    }
  }
  const keyStoragePattern = /private_key|secret_key|keypair|seed_phrase|mnemonic/gi;
  const matches3687 = content.matchAll(keyStoragePattern);
  for (const match of matches3687) {
    const lineNum = findLineNumber2(content, match.index || 0);
    findings.push({
      id: "SOL3687",
      title: "Private Key in Code",
      severity: "critical",
      description: "Private key reference detected. DEXX $30M hack was caused by centralized key management.",
      location: { file: fileName, line: lineNum },
      recommendation: "Never store private keys in code. Use HSM, MPC, or hardware wallets.",
      code: getCodeSnippet(content, lineNum)
    });
  }
  const custodyPattern = /user_keypair|custod|hold_key|store_key/gi;
  const matches3688 = content.matchAll(custodyPattern);
  for (const match of matches3688) {
    const lineNum = findLineNumber2(content, match.index || 0);
    findings.push({
      id: "SOL3688",
      title: "User Key Custody Risk",
      severity: "critical",
      description: "Pattern suggests custodial key storage. DEXX attack compromised 9,000+ wallets.",
      location: { file: fileName, line: lineNum },
      recommendation: "Never hold user private keys. Use non-custodial design with user-controlled wallets.",
      code: getCodeSnippet(content, lineNum)
    });
  }
  const importPattern = /use\s+solana_|extern\s+crate\s+solana/gi;
  const matches3689 = content.matchAll(importPattern);
  for (const match of matches3689) {
    const lineNum = findLineNumber2(content, match.index || 0);
    findings.push({
      id: "SOL3689",
      title: "Solana Dependency Without Version Pin",
      severity: "medium",
      description: "Solana crate import detected. Web3.js supply chain attack (Dec 2024) shows risk of unpinned deps.",
      location: { file: fileName, line: lineNum },
      recommendation: 'Pin exact versions in Cargo.toml: solana-program = "=1.18.0"',
      code: getCodeSnippet(content, lineNum)
    });
  }
  const bridgePattern = /bridge|cross_chain|wormhole|layerzero/gi;
  const matches3690 = content.matchAll(bridgePattern);
  for (const match of matches3690) {
    const context = content.substring(match.index || 0, (match.index || 0) + 300);
    if (!context.includes("finality") && !context.includes("confirmation") && !context.includes("slot_confirmed")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3690",
        title: "Bridge Without Finality Check",
        severity: "critical",
        description: "Cross-chain bridge without finality verification. NoOnes $8M exploit across multiple chains.",
        location: { file: fileName, line: lineNum },
        recommendation: "Wait for sufficient confirmations: require!(slot_confirmed >= 32)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const ratePattern = /exchange_rate|rate_x|conversion_rate|price_ratio/gi;
  const matches3691 = content.matchAll(ratePattern);
  for (const match of matches3691) {
    const context = content.substring(Math.max(0, (match.index || 0) - 100), (match.index || 0) + 200);
    if (!context.includes("twap") && !context.includes("oracle") && !context.includes("time_weighted")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3691",
        title: "Exchange Rate Without TWAP",
        severity: "critical",
        description: "Exchange rate without time-weighted average. Loopscale $5.8M RateX exploit.",
        location: { file: fileName, line: lineNum },
        recommendation: "Use TWAP oracle: require!(rate_age < MAX_STALENESS && use_twap())",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const sharePattern = /share_price|shares_per|price_per_share|vault_share/gi;
  const matches3692 = content.matchAll(sharePattern);
  for (const match of matches3692) {
    const context = content.substring(match.index || 0, (match.index || 0) + 200);
    if (!context.includes("virtual") && !context.includes("dead_shares") && !context.includes("minimum")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3692",
        title: "Share Price Inflation Risk",
        severity: "high",
        description: "Share calculation without inflation protection. First depositor attack vector.",
        location: { file: fileName, line: lineNum },
        recommendation: "Add virtual shares: total_shares = actual_shares + VIRTUAL_SHARES",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const oraclePattern = /oracle|price_feed|pyth|switchboard/gi;
  const matches3693 = content.matchAll(oraclePattern);
  for (const match of matches3693) {
    const context = content.substring(Math.max(0, (match.index || 0) - 150), (match.index || 0) + 250);
    if (context.split(/oracle|price/gi).length <= 2 && !context.includes("aggregate") && !context.includes("multiple")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3693",
        title: "Single Oracle Dependency",
        severity: "high",
        description: "Single oracle source detected. Mango Markets $116M used single-source price manipulation.",
        location: { file: fileName, line: lineNum },
        recommendation: "Aggregate multiple oracles: price = median(pyth, switchboard, chainlink)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const pricePattern = /\.price|get_price|fetch_price|price_data/gi;
  const matches3694 = content.matchAll(pricePattern);
  for (const match of matches3694) {
    const context = content.substring(match.index || 0, (match.index || 0) + 200);
    if (!context.includes("confidence") && !context.includes("conf") && !context.includes("deviation")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3694",
        title: "Oracle Without Confidence Check",
        severity: "high",
        description: "Price fetched without confidence interval validation.",
        location: { file: fileName, line: lineNum },
        recommendation: "Check confidence: require!(price.conf < price.price * MAX_CONF_PCT)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const tickPattern = /tick|position.*liquidity|concentrated/gi;
  const matches3695 = content.matchAll(tickPattern);
  for (const match of matches3695) {
    const context = content.substring(Math.max(0, (match.index || 0) - 100), (match.index || 0) + 200);
    if (!context.includes("owner") && !context.includes("verify") && !context.includes("program_id")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3695",
        title: "CLMM Tick Without Owner Verification",
        severity: "critical",
        description: "Tick account without ownership check. Crema Finance $8.8M used fake tick accounts.",
        location: { file: fileName, line: lineNum },
        recommendation: "Verify tick ownership: require!(tick_account.owner == &PROGRAM_ID)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const collateralPattern = /collateral|backing|reserve.*mint/gi;
  const matches3696 = content.matchAll(collateralPattern);
  for (const match of matches3696) {
    const context = content.substring(match.index || 0, (match.index || 0) + 250);
    if (!context.includes("whitelist") && !context.includes("allowed_mint") && !context.includes("verify_mint")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3696",
        title: "Collateral Without Mint Whitelist",
        severity: "critical",
        description: "Collateral accepted without mint validation. Cashio $52M used fake collateral.",
        location: { file: fileName, line: lineNum },
        recommendation: "Whitelist collateral mints: require!(ALLOWED_MINTS.contains(&mint.key()))",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const trustPattern = /root.*trust|trust.*root|anchor.*mint/gi;
  const matches3697 = content.matchAll(trustPattern);
  for (const match of matches3697) {
    const lineNum = findLineNumber2(content, match.index || 0);
    findings.push({
      id: "SOL3697",
      title: "Missing Root of Trust Chain",
      severity: "critical",
      description: "Root of trust pattern detected but may be incomplete. Cashio missing validation chain.",
      location: { file: fileName, line: lineNum },
      recommendation: "Validate complete chain: collateral -> pool -> bank -> root",
      code: getCodeSnippet(content, lineNum)
    });
  }
  const guardianPattern = /guardian|verify_signature|signature.*check/gi;
  const matches3698 = content.matchAll(guardianPattern);
  for (const match of matches3698) {
    const context = content.substring(match.index || 0, (match.index || 0) + 200);
    if (!context.includes("quorum") && !context.includes("threshold") && !context.includes("count")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3698",
        title: "Guardian Without Quorum Check",
        severity: "critical",
        description: "Guardian/signature verification without quorum. Wormhole $326M bypass.",
        location: { file: fileName, line: lineNum },
        recommendation: "Require quorum: require!(valid_sigs >= (guardians * 2 / 3) + 1)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const secpPattern = /secp256k1|ed25519.*verify|verify.*signature/gi;
  const matches3699 = content.matchAll(secpPattern);
  for (const match of matches3699) {
    const context = content.substring(match.index || 0, (match.index || 0) + 200);
    if (!context.includes("instruction_sysvar") && !context.includes("check_ed25519")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3699",
        title: "Signature Verify Without Instruction Check",
        severity: "critical",
        description: "Signature verification without validating instruction sysvar.",
        location: { file: fileName, line: lineNum },
        recommendation: "Validate via instruction sysvar, not just return value",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const flashLoanPattern = /flash.*loan|instant.*borrow|same.*transaction.*repay/gi;
  const matches3700 = content.matchAll(flashLoanPattern);
  for (const match of matches3700) {
    const context = content.substring(match.index || 0, (match.index || 0) + 300);
    if (!context.includes("reentrant") && !context.includes("lock") && !context.includes("guard")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3700",
        title: "Flash Loan Without Reentrancy Guard",
        severity: "critical",
        description: "Flash loan implementation without reentrancy protection.",
        location: { file: fileName, line: lineNum },
        recommendation: "Add reentrancy guard: set_locked(true) before callback",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const liquidationPattern = /liquidation|health.*factor|collateral.*ratio/gi;
  const matches3701 = content.matchAll(liquidationPattern);
  for (const match of matches3701) {
    const context = content.substring(Math.max(0, (match.index || 0) - 100), (match.index || 0) + 200);
    if (!context.includes("minimum") && !context.includes("floor") && !context.includes("bound")) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: "SOL3701",
        title: "Liquidation Without Minimum Bounds",
        severity: "high",
        description: "Liquidation parameters without minimum bounds. Solend attack set threshold to 1%.",
        location: { file: fileName, line: lineNum },
        recommendation: "Set bounds: require!(liquidation_threshold >= MIN_THRESHOLD)",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const token2022Patterns = [
    { id: "SOL3702", pattern: /transfer.*hook|TransferHook/gi, name: "Transfer Hook Validation", desc: "Transfer hook without validation" },
    { id: "SOL3703", pattern: /confidential.*transfer|ConfidentialTransfer/gi, name: "Confidential Transfer Security", desc: "Confidential transfer without proper encryption handling" },
    { id: "SOL3704", pattern: /permanent.*delegate|PermanentDelegate/gi, name: "Permanent Delegate Risk", desc: "Permanent delegate can drain tokens anytime" },
    { id: "SOL3705", pattern: /non.*transferable|NonTransferable/gi, name: "Non-Transferable Token Bypass", desc: "Non-transferable token could be bypassed via wrapping" },
    { id: "SOL3706", pattern: /interest.*bearing|InterestBearing/gi, name: "Interest Rate Manipulation", desc: "Interest-bearing token rate manipulation" },
    { id: "SOL3707", pattern: /default.*account.*state/gi, name: "Default Account State Risk", desc: "Default frozen state could lock user funds" },
    { id: "SOL3708", pattern: /memo.*required|MemoTransfer/gi, name: "Memo Requirement Bypass", desc: "Memo requirement without enforcement" },
    { id: "SOL3709", pattern: /cpi.*guard|CpiGuard/gi, name: "CPI Guard Misconfiguration", desc: "CPI guard not properly configured" },
    { id: "SOL3710", pattern: /transfer.*fee.*config|TransferFeeConfig/gi, name: "Transfer Fee Exploitation", desc: "Transfer fee config without max bounds" }
  ];
  for (const p of token2022Patterns) {
    const matches = content.matchAll(p.pattern);
    for (const match of matches) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: p.id,
        title: p.name,
        severity: "high",
        description: p.desc + ". Token-2022 extensions require careful validation.",
        location: { file: fileName, line: lineNum },
        recommendation: "Review Token-2022 extension security implications",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const cnftPatterns = [
    { id: "SOL3711", pattern: /merkle.*proof|verify.*proof/gi, name: "cNFT Proof Validation", desc: "Merkle proof without proper verification" },
    { id: "SOL3712", pattern: /concurrent.*merkle|ConcurrentMerkle/gi, name: "Concurrent Merkle Race", desc: "Race condition in concurrent merkle updates" },
    { id: "SOL3713", pattern: /canopy.*depth|tree.*depth/gi, name: "Tree Depth Mismatch", desc: "Tree depth/canopy mismatch could cause failures" },
    { id: "SOL3714", pattern: /leaf.*schema|LeafSchema/gi, name: "Leaf Schema Validation", desc: "Leaf schema version not validated" },
    { id: "SOL3715", pattern: /creator.*verification|verify.*creator/gi, name: "Creator Verification Skip", desc: "Creator verification can be bypassed" },
    { id: "SOL3716", pattern: /collection.*verification/gi, name: "Collection Verification", desc: "Collection verification without authority check" },
    { id: "SOL3717", pattern: /delegate.*burn|burn.*delegate/gi, name: "Delegate Burn Authority", desc: "Delegate with burn authority risk" },
    { id: "SOL3718", pattern: /tree.*authority|authority.*tree/gi, name: "Tree Authority Validation", desc: "Tree authority not validated" },
    { id: "SOL3719", pattern: /update.*metadata.*tree/gi, name: "Metadata Update Security", desc: "Metadata update without authorization" },
    { id: "SOL3720", pattern: /decompress|decompression/gi, name: "Decompression Validation", desc: "Decompression without proper asset verification" }
  ];
  for (const p of cnftPatterns) {
    const matches = content.matchAll(p.pattern);
    for (const match of matches) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: p.id,
        title: p.name,
        severity: "high",
        description: p.desc + ". Bubblegum/cNFT security pattern.",
        location: { file: fileName, line: lineNum },
        recommendation: "Follow Metaplex cNFT security best practices",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const mevPatterns = [
    { id: "SOL3721", pattern: /bundle|jito.*tip|tip.*account/gi, name: "Bundle Tip Validation", desc: "Jito bundle tip without validation" },
    { id: "SOL3722", pattern: /priority.*fee|compute.*price/gi, name: "Priority Fee Griefing", desc: "Priority fee allows economic griefing" },
    { id: "SOL3723", pattern: /backrun|frontrun|sandwich/gi, name: "MEV Exposure", desc: "Transaction vulnerable to MEV extraction" },
    { id: "SOL3724", pattern: /slot.*leader|leader.*schedule/gi, name: "Leader Schedule Exploitation", desc: "Leader schedule exposure for MEV" },
    { id: "SOL3725", pattern: /transaction.*ordering/gi, name: "Ordering Dependency", desc: "Transaction ordering creates MEV opportunity" },
    { id: "SOL3726", pattern: /slippage.*tolerance/gi, name: "Slippage Tolerance", desc: "Wide slippage allows sandwich attacks" },
    { id: "SOL3727", pattern: /batch.*auction|sealed.*bid/gi, name: "Batch Auction Security", desc: "Batch auction front-running prevention" },
    { id: "SOL3728", pattern: /commit.*reveal/gi, name: "Commit-Reveal Timing", desc: "Commit-reveal scheme timing vulnerability" },
    { id: "SOL3729", pattern: /fair.*ordering|time.*priority/gi, name: "Fair Ordering", desc: "Fair ordering not enforced" },
    { id: "SOL3730", pattern: /atomic.*arb|arbitrage/gi, name: "Atomic Arbitrage", desc: "Atomic arbitrage extraction vector" }
  ];
  for (const p of mevPatterns) {
    const matches = content.matchAll(p.pattern);
    for (const match of matches) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: p.id,
        title: p.name,
        severity: "medium",
        description: p.desc + ". MEV protection pattern.",
        location: { file: fileName, line: lineNum },
        recommendation: "Implement MEV-resistant design patterns",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const govPatterns = [
    { id: "SOL3731", pattern: /governance.*token|voting.*power/gi, name: "Governance Token Snapshot", desc: "Voting power without snapshot mechanism" },
    { id: "SOL3732", pattern: /proposal.*threshold/gi, name: "Proposal Threshold", desc: "Low proposal threshold allows spam" },
    { id: "SOL3733", pattern: /quorum.*requirement/gi, name: "Quorum Manipulation", desc: "Quorum can be manipulated with flash loans" },
    { id: "SOL3734", pattern: /execution.*delay|timelock.*delay/gi, name: "Execution Delay Bypass", desc: "Execution delay could be bypassed" },
    { id: "SOL3735", pattern: /veto.*power|guardian.*veto/gi, name: "Veto Power Centralization", desc: "Centralized veto creates single point of failure" },
    { id: "SOL3736", pattern: /delegate.*vote|voting.*delegate/gi, name: "Vote Delegation Security", desc: "Vote delegation without proper controls" },
    { id: "SOL3737", pattern: /vote.*weight.*calculation/gi, name: "Vote Weight Calculation", desc: "Vote weight calculation manipulation" },
    { id: "SOL3738", pattern: /proposal.*cancel|cancel.*proposal/gi, name: "Proposal Cancellation", desc: "Proposal cancellation authority abuse" },
    { id: "SOL3739", pattern: /treasury.*execution/gi, name: "Treasury Execution Risk", desc: "Treasury can execute arbitrary transactions" },
    { id: "SOL3740", pattern: /realm|spl.*governance/gi, name: "SPL Governance Config", desc: "SPL Governance misconfiguration" }
  ];
  for (const p of govPatterns) {
    const matches = content.matchAll(p.pattern);
    for (const match of matches) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: p.id,
        title: p.name,
        severity: "high",
        description: p.desc + ". DAO governance security pattern.",
        location: { file: fileName, line: lineNum },
        recommendation: "Review governance security best practices",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  const infraPatterns = [
    { id: "SOL3741", pattern: /rpc.*endpoint|cluster.*url/gi, name: "RPC Endpoint Exposure", desc: "RPC endpoint hardcoded or exposed" },
    { id: "SOL3742", pattern: /rate.*limit|request.*throttle/gi, name: "Rate Limiting", desc: "Missing rate limiting for expensive operations" },
    { id: "SOL3743", pattern: /transaction.*simulation|simulate/gi, name: "Simulation Bypass", desc: "Simulation can be bypassed for actual execution" },
    { id: "SOL3744", pattern: /recent.*blockhash|blockhash.*cache/gi, name: "Blockhash Management", desc: "Blockhash management vulnerability" },
    { id: "SOL3745", pattern: /durable.*nonce/gi, name: "Durable Nonce Security", desc: "Durable nonce account security" },
    { id: "SOL3746", pattern: /lookup.*table|address.*lookup/gi, name: "Lookup Table Poisoning", desc: "Address lookup table could be poisoned" },
    { id: "SOL3747", pattern: /versioned.*transaction|v0.*transaction/gi, name: "Versioned Transaction", desc: "Versioned transaction handling" },
    { id: "SOL3748", pattern: /compute.*budget|request.*units/gi, name: "Compute Budget Attack", desc: "Compute budget can be exhausted by attacker" },
    { id: "SOL3749", pattern: /program.*upgrade|bpf.*upgrade/gi, name: "Program Upgrade Authority", desc: "Program upgrade authority centralization" },
    { id: "SOL3750", pattern: /idl.*publish|anchor.*idl/gi, name: "IDL Exposure", desc: "IDL publication exposes program interface" }
  ];
  for (const p of infraPatterns) {
    const matches = content.matchAll(p.pattern);
    for (const match of matches) {
      const lineNum = findLineNumber2(content, match.index || 0);
      findings.push({
        id: p.id,
        title: p.name,
        severity: "medium",
        description: p.desc + ". Infrastructure security pattern.",
        location: { file: fileName, line: lineNum },
        recommendation: "Follow Solana operational security guidelines",
        code: getCodeSnippet(content, lineNum)
      });
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-77.ts
var ARXIV_ACADEMIC_PATTERNS = [
  // 3.1.1 Missing Signer Check (arXiv)
  {
    id: "SOL3776",
    name: "arXiv 3.1.1 - Missing Signer Verification (Solend Pattern)",
    severity: "critical",
    pattern: /(?:authority|admin|owner)[\s\S]{0,50}AccountInfo[\s\S]{0,100}(?!\.is_signer)/,
    description: "Authority account without signer verification. Solend $2M pattern documented in arXiv.",
    recommendation: "Always verify authority.is_signer() before privileged operations."
  },
  {
    id: "SOL3777",
    name: "arXiv 3.1.1 - Key Match Without Signature",
    severity: "critical",
    pattern: /\.key\s*==[\s\S]{0,30}\.key[\s\S]{0,100}(?!is_signer)/,
    description: "Key comparison without signer check allows spoofing.",
    recommendation: "Combine key comparison with is_signer verification."
  },
  // 3.1.2 Missing Ownership Check (arXiv)
  {
    id: "SOL3778",
    name: "arXiv 3.1.2 - Missing Account Ownership Verification",
    severity: "critical",
    pattern: /AccountInfo[\s\S]{0,100}\.data[\s\S]{0,100}(?!owner\s*==|owner\(\))/,
    description: "Account data access without ownership check. arXiv documented vulnerability.",
    recommendation: "Verify account.owner() == expected_program_id before data access."
  },
  {
    id: "SOL3779",
    name: "arXiv 3.1.2 - Forged Account Injection",
    severity: "critical",
    pattern: /try_borrow_data[\s\S]{0,100}(?!owner_check|verify_owner)/,
    description: "Borrowing account data without ownership verification allows forged accounts.",
    recommendation: "Check account ownership before borrowing data."
  },
  // 3.1.3 Missing Rent Exemption Check
  {
    id: "SOL3780",
    name: "arXiv 3.1.3 - Missing Rent Exemption Check",
    severity: "medium",
    pattern: /(?:create|init)[\s\S]{0,100}(?:account|pda)[\s\S]{0,100}(?!rent_exempt|minimum_balance)/,
    description: "Account creation without rent exemption verification.",
    recommendation: "Verify account has rent-exempt minimum balance."
  },
  // Account Type Confusion (arXiv)
  {
    id: "SOL3781",
    name: "arXiv - Account Type Confusion Attack",
    severity: "critical",
    pattern: /try_from_slice[\s\S]{0,100}(?!discriminator|type_check)/,
    description: "Deserialization without type verification enables confusion attacks.",
    recommendation: "Verify 8-byte discriminator before deserialization."
  },
  // Cross-Instance Reinitialization (arXiv)
  {
    id: "SOL3782",
    name: "arXiv - Cross-Instance Reinitialization Attack",
    severity: "high",
    pattern: /initialize[\s\S]{0,100}(?:program_id|cross_program)[\s\S]{0,100}(?!instance_check)/,
    description: "Initialization vulnerable to cross-program instance attacks.",
    recommendation: "Verify program instance matches expected deployment."
  },
  // Oracle Manipulation (Solend $1.26M - arXiv Table 1)
  {
    id: "SOL3783",
    name: "arXiv Table 1 - Oracle Attack Pattern (Solend)",
    severity: "critical",
    pattern: /oracle[\s\S]{0,100}(?:price|feed)[\s\S]{0,100}(?!aggregate|multi_source)/,
    description: "Single oracle source vulnerable to manipulation. Solend $1.26M (arXiv Table 1).",
    recommendation: "Use multiple oracle sources with aggregation."
  },
  // Flash Loan Attack (Mango $100M, Nirvana $3.5M - arXiv Table 1)
  {
    id: "SOL3784",
    name: "arXiv Table 1 - Flash Loan Attack (Mango/Nirvana)",
    severity: "critical",
    pattern: /(?:flash_loan|borrow)[\s\S]{0,100}(?!same_block|atomic_check)/,
    description: "Flash loan without same-block detection. Mango $100M, Nirvana $3.5M (arXiv).",
    recommendation: "Add same-block/same-slot detection for flash loan protection."
  },
  // Cascade Attack (Tulip/UXD via Mango - arXiv Table 1)
  {
    id: "SOL3785",
    name: "arXiv Table 1 - Cascade Attack (Tulip/UXD)",
    severity: "high",
    pattern: /(?:integrated|connected)[\s\S]{0,100}(?:protocol|pool)[\s\S]{0,100}(?!isolation|circuit_breaker)/,
    description: "Cross-protocol integration without isolation. Tulip $2.5M, UXD $20M via Mango.",
    recommendation: "Implement circuit breakers and protocol isolation."
  },
  // Operational Error (OptiFi $661K - arXiv Table 1)
  {
    id: "SOL3786",
    name: "arXiv Table 1 - Operational Error (OptiFi)",
    severity: "high",
    pattern: /(?:close|shutdown)[\s\S]{0,100}program[\s\S]{0,100}(?!funds_check|balance_check)/,
    description: "Program close without checking locked funds. OptiFi $661K (arXiv).",
    recommendation: "Verify no funds locked before program closure."
  },
  // Unverified Accounts (Cashio $52M - arXiv Table 1)
  {
    id: "SOL3787",
    name: "arXiv Table 1 - Unverified Account Bypass (Cashio)",
    severity: "critical",
    pattern: /(?:collateral|mint)[\s\S]{0,100}(?:verify|validate)[\s\S]{0,100}(?!chain_of_trust)/,
    description: "Collateral verification without chain of trust. Cashio $52M (arXiv).",
    recommendation: "Establish and verify complete chain of trust for accounts."
  },
  // Deprecated Function (Wormhole 120K ETH - arXiv Table 1)
  {
    id: "SOL3788",
    name: "arXiv Table 1 - Deprecated Function Exploit (Wormhole)",
    severity: "critical",
    pattern: /verify_signatures_address|deprecated|unsafe_function/,
    description: "Use of deprecated security function. Wormhole 120K ETH (arXiv).",
    recommendation: "Audit for deprecated functions, use current security APIs."
  },
  // eBPF/SBF Specific Issues (arXiv)
  {
    id: "SOL3789",
    name: "arXiv - eBPF Syscall Abuse",
    severity: "high",
    pattern: /syscall[\s\S]{0,50}(?:invoke|sol_)[\s\S]{0,100}(?!validate_input)/,
    description: "Direct syscall usage without input validation.",
    recommendation: "Validate all inputs before syscall invocation."
  },
  {
    id: "SOL3790",
    name: "arXiv - LLVM Compilation Vulnerability",
    severity: "medium",
    pattern: /(?:#\[repr|#\[inline)[\s\S]{0,50}(?:never|always)/,
    description: "Compiler directives may affect security properties.",
    recommendation: "Audit compiler directives for security implications."
  }
];
var SEALEVEL_ATTACKS = [
  {
    id: "SOL3791",
    name: "Sealevel - Duplicate Mutable Accounts",
    severity: "high",
    pattern: /(?:account_a|source)[\s\S]{0,30}mut[\s\S]{0,30}(?:account_b|dest)[\s\S]{0,30}mut[\s\S]{0,100}(?!key.*!=)/,
    description: "Same account passed as multiple mutable arguments.",
    recommendation: "Verify all mutable accounts are distinct: a.key() != b.key()."
  },
  {
    id: "SOL3792",
    name: "Sealevel - Account Type Confusion",
    severity: "critical",
    pattern: /(?:cast|transmute)[\s\S]{0,50}(?:AccountInfo|&\[u8\])[\s\S]{0,100}(?!discriminator)/,
    description: "Unsafe account type casting without discriminator check.",
    recommendation: "Always verify discriminator before type casting."
  },
  {
    id: "SOL3793",
    name: "Sealevel - Sysvar Address Spoofing",
    severity: "high",
    pattern: /sysvar[\s\S]{0,100}(?:clock|rent|slot)[\s\S]{0,100}(?!check_id|is_sysvar)/,
    description: "Sysvar account without address verification.",
    recommendation: "Verify sysvar addresses match expected IDs."
  },
  {
    id: "SOL3794",
    name: "Sealevel - Arbitrary Program CPI",
    severity: "critical",
    pattern: /invoke(?:_signed)?[\s\S]{0,100}(?:program|cpi_program)[\s\S]{0,100}(?!==\s*(?:TOKEN|SYSTEM|ASSOCIATED))/,
    description: "CPI to arbitrary program without ID verification.",
    recommendation: "Hardcode or verify program IDs for all CPI calls."
  },
  {
    id: "SOL3795",
    name: "Sealevel - PDA Not Verified",
    severity: "high",
    pattern: /create_program_address[\s\S]{0,100}(?!==|verify|check)/,
    description: "PDA address created but not verified.",
    recommendation: "Verify PDA address matches expected derivation."
  },
  {
    id: "SOL3796",
    name: "Sealevel - Bump Seed Canonicalization",
    severity: "high",
    pattern: /bump[\s\S]{0,50}(?:u8|param)[\s\S]{0,100}(?!canonical|find_program)/,
    description: "User-provided bump seed allows shadow PDAs.",
    recommendation: "Use find_program_address for canonical bump."
  },
  {
    id: "SOL3797",
    name: "Sealevel - Closing Account Without Zeroing",
    severity: "high",
    pattern: /close[\s\S]{0,100}lamports[\s\S]{0,100}(?!\.fill\(0\)|zero|clear)/,
    description: "Account closure without data zeroing enables resurrection.",
    recommendation: "Zero all data before transferring lamports."
  },
  {
    id: "SOL3798",
    name: "Sealevel - Missing Owner Check on Read",
    severity: "critical",
    pattern: /\.try_borrow_data\(\)[\s\S]{0,50}(?!owner|program_id)/,
    description: "Reading account data without verifying owner.",
    recommendation: "Check account.owner == program_id before reading."
  },
  {
    id: "SOL3799",
    name: "Sealevel - init_if_needed Race",
    severity: "high",
    pattern: /init_if_needed/,
    description: "init_if_needed creates race condition vulnerability.",
    recommendation: "Use explicit initialization with existence check."
  },
  {
    id: "SOL3800",
    name: "Sealevel - Reallocation Vulnerability",
    severity: "medium",
    pattern: /realloc[\s\S]{0,100}(?!bounds_check|max_size)/,
    description: "Account reallocation without size bounds.",
    recommendation: "Validate reallocation size against maximum."
  }
];
var NEODYME_PATTERNS = [
  {
    id: "SOL3801",
    name: "Neodyme - Rounding Error ($2.6B Risk)",
    severity: "critical",
    pattern: /(?:round|as\s+u64)[\s\S]{0,50}(?:amount|value)[\s\S]{0,100}(?!floor_for_deposit|ceil_for_withdraw)/,
    description: "Rounding error in financial calculation. $2.6B at risk pattern.",
    recommendation: "Use floor for deposits (favor protocol), ceil for withdrawals (favor protocol)."
  },
  {
    id: "SOL3802",
    name: "Neodyme - Integer Overflow in Checked Mode",
    severity: "high",
    pattern: /\+|\-|\*|\/[\s\S]{0,30}(?:amount|balance|fee)[\s\S]{0,50}(?!checked_|saturating_)/,
    description: "Arithmetic operation without overflow protection.",
    recommendation: "Use checked_add/sub/mul/div for all arithmetic."
  },
  {
    id: "SOL3803",
    name: "Neodyme - Verify invoke_signed Properly",
    severity: "critical",
    pattern: /invoke_signed[\s\S]{0,100}(?!seeds_check|signer_seeds)/,
    description: "invoke_signed without proper seeds verification.",
    recommendation: "Verify signer seeds match expected PDA derivation."
  },
  {
    id: "SOL3804",
    name: "Neodyme - Account Confusions Without Anchor",
    severity: "high",
    pattern: /pub\s+struct[\s\S]{0,100}AccountInfo[\s\S]{0,100}(?!#\[account\])/,
    description: "Manual account handling without Anchor type safety.",
    recommendation: "Use Anchor #[account] for type-safe account handling."
  },
  {
    id: "SOL3805",
    name: "Neodyme - Unvalidated Reference Account",
    severity: "high",
    pattern: /(?:reference|ref)[\s\S]{0,50}(?:account|info)[\s\S]{0,100}(?!verify|validate|check)/,
    description: "Reference account passed without validation.",
    recommendation: "Validate all reference accounts, even read-only ones."
  }
];
var OTTERSEC_PATTERNS = [
  {
    id: "SOL3806",
    name: "OtterSec - LP Token Oracle Manipulation ($200M)",
    severity: "critical",
    pattern: /lp[\s\S]{0,50}(?:price|value)[\s\S]{0,100}(?:reserve|balance)[\s\S]{0,100}(?!fair_price|virtual)/,
    description: "LP token pricing using spot reserves. $200M at risk pattern.",
    recommendation: "Use fair/virtual pricing for LP tokens."
  },
  {
    id: "SOL3807",
    name: "OtterSec - AMM Price Manipulation for Oracle",
    severity: "critical",
    pattern: /(?:amm|dex)[\s\S]{0,100}(?:price|quote)[\s\S]{0,100}(?:oracle|feed)/,
    description: "Using AMM spot price as oracle enables manipulation.",
    recommendation: "Use TWAP or external oracles, not AMM spot prices."
  },
  {
    id: "SOL3808",
    name: "OtterSec - Lending Protocol via LP Attack",
    severity: "critical",
    pattern: /(?:lending|borrow)[\s\S]{0,100}lp[\s\S]{0,100}(?:collateral|deposit)/,
    description: "LP tokens as lending collateral without manipulation protection.",
    recommendation: "Use manipulation-resistant LP valuation for collateral."
  },
  {
    id: "SOL3809",
    name: "OtterSec - Drift Oracle Guardrails Pattern",
    severity: "medium",
    pattern: /oracle[\s\S]{0,100}(?!guardrail|bound|limit|max_deviation)/,
    description: "Oracle without guardrails allows extreme price movements.",
    recommendation: "Implement oracle guardrails (max deviation, staleness, confidence)."
  }
];
var KUDELSKI_PATTERNS = [
  {
    id: "SOL3810",
    name: "Kudelski - Ownership Validation Missing",
    severity: "critical",
    pattern: /(?:program|account)[\s\S]{0,50}(?:data|info)[\s\S]{0,100}(?!owner\s*==|verify_owner)/,
    description: "Account ownership not validated (Kudelski).",
    recommendation: "Verify account ownership before trusting data."
  },
  {
    id: "SOL3811",
    name: "Kudelski - Data Validation Missing",
    severity: "high",
    pattern: /try_borrow_data[\s\S]{0,100}(?!validate|check|verify)/,
    description: "Account data read without validation (Kudelski).",
    recommendation: "Validate account data format and constraints."
  },
  {
    id: "SOL3812",
    name: "Kudelski - Unmodified Reference Accounts",
    severity: "medium",
    pattern: /(?:reference|readonly)[\s\S]{0,50}account[\s\S]{0,100}(?!verify_validity)/,
    description: "Reference-only accounts not validated (Kudelski).",
    recommendation: "Verify validity of unmodified reference accounts."
  },
  {
    id: "SOL3813",
    name: "Kudelski - Wormhole Signature Delegation Chain",
    severity: "critical",
    pattern: /(?:signature|verify)[\s\S]{0,100}(?:delegate|chain)[\s\S]{0,100}(?!complete_verification)/,
    description: "Signature verification delegation without complete chain.",
    recommendation: "Ensure complete verification chain for delegated signatures."
  }
];
var ZELLIC_ANCHOR_PATTERNS = [
  {
    id: "SOL3814",
    name: "Zellic - Anchor Seeds Constraint Mismatch",
    severity: "high",
    pattern: /seeds\s*=\s*\[[\s\S]{0,100}\][\s\S]{0,50}(?!bump)/,
    description: "PDA seeds defined without bump constraint.",
    recommendation: "Always include bump constraint with seeds."
  },
  {
    id: "SOL3815",
    name: "Zellic - Anchor has_one Without Constraint",
    severity: "medium",
    pattern: /has_one[\s\S]{0,50}(?!constraint|@)/,
    description: "has_one attribute without additional constraint.",
    recommendation: "Combine has_one with constraint for full validation."
  },
  {
    id: "SOL3816",
    name: "Zellic - Anchor close Without Balance Check",
    severity: "high",
    pattern: /#\[account\([\s\S]{0,100}close[\s\S]{0,100}\)][\s\S]{0,200}(?!balance_check)/,
    description: "Anchor close attribute without verifying zero balance.",
    recommendation: "Verify account has expected balance before closing."
  },
  {
    id: "SOL3817",
    name: "Zellic - Anchor Realloc Without Zero Init",
    severity: "medium",
    pattern: /realloc[\s\S]{0,50}(?!zero\s*=\s*true)/,
    description: "Anchor realloc without zero initialization.",
    recommendation: "Use realloc::zero = true to zero new bytes."
  },
  {
    id: "SOL3818",
    name: "Zellic - UncheckedAccount Without CHECK",
    severity: "high",
    pattern: /UncheckedAccount[\s\S]{0,100}(?!\/\/\/\s*CHECK)/,
    description: "UncheckedAccount without /// CHECK documentation.",
    recommendation: "Document security justification with /// CHECK comment."
  },
  {
    id: "SOL3819",
    name: "Zellic - AccountInfo in Anchor (Should Use Typed)",
    severity: "medium",
    pattern: /(?:pub\s+)?(?:\w+):\s*AccountInfo[\s\S]{0,50}(?!\/\/\/\s*CHECK)/,
    description: "Raw AccountInfo usage in Anchor instead of typed account.",
    recommendation: "Use Account<'info, T>, Signer, or Program types."
  }
];
var SEC3_AUDIT_PATTERNS = [
  {
    id: "SOL3820",
    name: "Sec3 Part 1 - Common Attack Surface: Entry Point",
    severity: "high",
    pattern: /(?:process|handle)_instruction[\s\S]{0,100}(?!validate_accounts|check_program_id)/,
    description: "Instruction entry point without account validation.",
    recommendation: "Validate all accounts at instruction entry."
  },
  {
    id: "SOL3821",
    name: "Sec3 Part 1 - State Transition Analysis",
    severity: "high",
    pattern: /state[\s\S]{0,50}(?:=|:=)[\s\S]{0,100}(?!match|enum|verify_transition)/,
    description: "State modification without transition verification.",
    recommendation: "Define and verify valid state transitions."
  },
  {
    id: "SOL3822",
    name: "Sec3 Part 2 - Automated Scanning Gap",
    severity: "medium",
    pattern: /unsafe[\s\S]{0,30}(?:code|fn|impl)/,
    description: "Unsafe Rust code requires manual security review.",
    recommendation: "Minimize unsafe code, audit thoroughly when required."
  },
  {
    id: "SOL3823",
    name: "Sec3 Part 3 - PoC Framework Integration",
    severity: "info",
    pattern: /(?:test|spec)[\s\S]{0,100}(?!exploit|attack|malicious)/,
    description: "Tests may not include adversarial scenarios.",
    recommendation: "Include exploit PoC tests using Neodyme framework."
  },
  {
    id: "SOL3824",
    name: "Sec3 Part 4 - Anchor #[program] Handler",
    severity: "medium",
    pattern: /#\[program\][\s\S]{0,200}pub\s+fn[\s\S]{0,100}(?!ctx\.accounts)/,
    description: "Anchor handler not using ctx.accounts pattern.",
    recommendation: "Use ctx.accounts for validated account access."
  },
  {
    id: "SOL3825",
    name: "Sec3 - Unsafe Library Reference",
    severity: "medium",
    pattern: /use\s+(?:unsafe_|deprecated_)/,
    description: "Importing unsafe or deprecated library.",
    recommendation: "Audit dependencies with cargo audit, update unsafe refs."
  }
];
var TRAIL_OF_BITS_PATTERNS = [
  {
    id: "SOL3826",
    name: "ToB - DeFi Composability Risk",
    severity: "high",
    pattern: /(?:composed|integrated)[\s\S]{0,100}(?:protocol|defi)[\s\S]{0,100}(?!risk_assessment)/,
    description: "DeFi protocol composition without risk assessment.",
    recommendation: "Assess risks of composed protocol interactions."
  },
  {
    id: "SOL3827",
    name: "ToB - Price Oracle Dependency",
    severity: "high",
    pattern: /(?:price|oracle)[\s\S]{0,100}(?:single|one)[\s\S]{0,100}(?!fallback|backup)/,
    description: "Single price oracle dependency creates failure point.",
    recommendation: "Implement oracle fallback mechanisms."
  },
  {
    id: "SOL3828",
    name: "ToB - Liquidation Path Analysis",
    severity: "high",
    pattern: /liquidat(?:e|ion)[\s\S]{0,100}(?!path_analysis|cascade_check)/,
    description: "Liquidation without cascade analysis.",
    recommendation: "Analyze liquidation paths for cascade risks."
  },
  {
    id: "SOL3829",
    name: "ToB - Emergency Mechanism",
    severity: "medium",
    pattern: /(?:pause|emergency|shutdown)[\s\S]{0,100}(?!admin_only|multisig)/,
    description: "Emergency mechanism without proper access control.",
    recommendation: "Require multisig for emergency operations."
  },
  {
    id: "SOL3830",
    name: "ToB - Upgrade Path Security",
    severity: "high",
    pattern: /upgrade[\s\S]{0,100}(?:authority|admin)[\s\S]{0,100}(?!timelock|governance)/,
    description: "Program upgrade without timelock or governance.",
    recommendation: "Add timelock or governance for upgrades."
  }
];
var EXPLOIT_DEEP_PATTERNS = [
  // Wormhole Deep Dive
  {
    id: "SOL3831",
    name: "Wormhole - SignatureSet Account Spoofing",
    severity: "critical",
    pattern: /(?:signature|guardian)[\s\S]{0,100}(?:set|verify)[\s\S]{0,100}(?!account_owner_check)/,
    description: "Signature verification accepting fake SignatureSet. Wormhole $326M.",
    recommendation: "Verify SignatureSet account owned by expected program."
  },
  {
    id: "SOL3832",
    name: "Wormhole - VAA Verification Bypass",
    severity: "critical",
    pattern: /vaa[\s\S]{0,100}(?:verify|validate)[\s\S]{0,100}(?!guardian_set|quorum)/,
    description: "VAA verification without guardian set validation.",
    recommendation: "Verify VAA against current guardian set with quorum."
  },
  // Mango Markets Deep Dive
  {
    id: "SOL3833",
    name: "Mango - Self-Trading Oracle Manipulation",
    severity: "critical",
    pattern: /(?:perp|trade)[\s\S]{0,100}(?:oracle|mark_price)[\s\S]{0,100}(?!self_trade_check)/,
    description: "Perp trading allows self-trades affecting oracle. Mango $116M.",
    recommendation: "Detect and prevent self-trades affecting price."
  },
  {
    id: "SOL3834",
    name: "Mango - Unrealized PnL as Collateral",
    severity: "critical",
    pattern: /(?:pnl|profit)[\s\S]{0,100}(?:unrealized|open)[\s\S]{0,100}(?:collateral|margin)/,
    description: "Unrealized PnL counted as collateral before settlement.",
    recommendation: "Only count settled PnL as collateral."
  },
  {
    id: "SOL3835",
    name: "Mango - Position Concentration Missing",
    severity: "high",
    pattern: /position[\s\S]{0,100}(?:size|value)[\s\S]{0,100}(?!concentration_limit|max_position)/,
    description: "No position concentration limits.",
    recommendation: "Implement position size limits relative to market."
  },
  // Cashio Deep Dive
  {
    id: "SOL3836",
    name: "Cashio - Root of Trust Chain Bypass",
    severity: "critical",
    pattern: /collateral[\s\S]{0,100}(?:chain|nested)[\s\S]{0,100}(?!root_of_trust)/,
    description: "Collateral chain without root of trust. Cashio $52M.",
    recommendation: "Verify complete chain to trusted root account."
  },
  {
    id: "SOL3837",
    name: "Cashio - Saber LP Token Authenticity",
    severity: "critical",
    pattern: /lp[\s\S]{0,50}token[\s\S]{0,100}(?:mint|verify)[\s\S]{0,100}(?!pool_owner_check)/,
    description: "LP token accepted without pool ownership verification.",
    recommendation: "Verify LP token mint owned by expected pool program."
  },
  // Crema CLMM Deep Dive
  {
    id: "SOL3838",
    name: "Crema - Fake Tick Account Creation",
    severity: "critical",
    pattern: /tick[\s\S]{0,100}(?:account|create)[\s\S]{0,100}(?!program_owner)/,
    description: "Tick account created without program ownership. Crema $8.8M.",
    recommendation: "Verify tick accounts owned by CLMM program."
  },
  {
    id: "SOL3839",
    name: "Crema - Fee Accumulator Manipulation",
    severity: "critical",
    pattern: /fee[\s\S]{0,100}(?:accumulator|collected)[\s\S]{0,100}(?!authentic_source)/,
    description: "Fee data from unverified source.",
    recommendation: "Verify fee accumulator from authenticated source."
  },
  {
    id: "SOL3840",
    name: "Crema - Flash Loan Fee Claim Amplification",
    severity: "critical",
    pattern: /(?:flash_loan|claim)[\s\S]{0,100}fee[\s\S]{0,100}(?!position_check)/,
    description: "Fee claim without position verification.",
    recommendation: "Verify position ownership and duration before fee claim."
  },
  // Slope Wallet Deep Dive
  {
    id: "SOL3841",
    name: "Slope - Seed Phrase Logging to Telemetry",
    severity: "critical",
    pattern: /(?:seed|mnemonic|phrase)[\s\S]{0,100}(?:log|send|transmit)/,
    description: "Seed phrase sent to telemetry. Slope $8M.",
    recommendation: "Never log or transmit seed phrases."
  },
  {
    id: "SOL3842",
    name: "Slope - Unencrypted Key Storage",
    severity: "critical",
    pattern: /(?:key|secret)[\s\S]{0,100}(?:store|save)[\s\S]{0,100}(?!encrypt|secure)/,
    description: "Private keys stored without encryption.",
    recommendation: "Always encrypt private keys at rest."
  },
  {
    id: "SOL3843",
    name: "Slope - Sensitive Data in Telemetry",
    severity: "critical",
    pattern: /telemetry[\s\S]{0,100}(?:send|track)[\s\S]{0,100}(?!sanitize|filter_sensitive)/,
    description: "Telemetry may include sensitive data.",
    recommendation: "Sanitize all telemetry to remove sensitive data."
  },
  // Audius Governance Deep Dive
  {
    id: "SOL3844",
    name: "Audius - Malicious Proposal Acceptance",
    severity: "critical",
    pattern: /proposal[\s\S]{0,100}(?:submit|create)[\s\S]{0,100}(?!validation|review)/,
    description: "Governance proposal accepted without validation. Audius $6.1M.",
    recommendation: "Validate proposal content and submitter permissions."
  },
  {
    id: "SOL3845",
    name: "Audius - Treasury Permission Reconfiguration",
    severity: "critical",
    pattern: /treasury[\s\S]{0,100}(?:permission|authority)[\s\S]{0,100}(?!timelock|delay)/,
    description: "Treasury permissions changeable without delay.",
    recommendation: "Add timelock for treasury permission changes."
  },
  // Nirvana Finance Deep Dive
  {
    id: "SOL3846",
    name: "Nirvana - Bonding Curve Flash Loan",
    severity: "critical",
    pattern: /bonding[\s\S]{0,100}(?:curve|price)[\s\S]{0,100}(?!flash_guard|atomic)/,
    description: "Bonding curve exploitable via flash loan. Nirvana $3.5M.",
    recommendation: "Add flash loan protection to bonding curves."
  },
  {
    id: "SOL3847",
    name: "Nirvana - Instant Price Impact",
    severity: "high",
    pattern: /(?:buy|sell)[\s\S]{0,100}(?:price|impact)[\s\S]{0,100}(?!slippage_limit)/,
    description: "Trade without slippage limit allows manipulation.",
    recommendation: "Enforce slippage limits on all trades."
  }
];
var PROTOCOL_SPECIFIC = [
  // Pyth Oracle
  {
    id: "SOL3848",
    name: "Pyth - Confidence Interval Not Checked",
    severity: "high",
    pattern: /pyth[\s\S]{0,100}(?:price|get)[\s\S]{0,100}(?!conf|confidence)/,
    description: "Pyth price used without confidence interval check.",
    recommendation: "Verify Pyth confidence interval is acceptable."
  },
  {
    id: "SOL3849",
    name: "Pyth - Expo Scaling Error",
    severity: "high",
    pattern: /pyth[\s\S]{0,100}(?:price|expo)[\s\S]{0,100}(?!scale|adjust_expo)/,
    description: "Pyth price not scaled by expo.",
    recommendation: "Always scale Pyth price by 10^expo."
  },
  // Switchboard Oracle
  {
    id: "SOL3850",
    name: "Switchboard - Aggregator Staleness",
    severity: "high",
    pattern: /switchboard[\s\S]{0,100}(?:result|value)[\s\S]{0,100}(?!staleness|timestamp)/,
    description: "Switchboard result used without staleness check.",
    recommendation: "Check aggregator timestamp freshness."
  },
  // Marinade Finance
  {
    id: "SOL3851",
    name: "Marinade - mSOL Pricing Attack",
    severity: "high",
    pattern: /msol[\s\S]{0,100}(?:price|rate)[\s\S]{0,100}(?!verify_rate)/,
    description: "mSOL exchange rate not verified.",
    recommendation: "Verify mSOL rate from Marinade program."
  },
  {
    id: "SOL3852",
    name: "Marinade - Delayed Unstake Ticket",
    severity: "medium",
    pattern: /marinade[\s\S]{0,100}(?:unstake|ticket)[\s\S]{0,100}(?!epoch_check)/,
    description: "Marinade unstake ticket epoch not verified.",
    recommendation: "Verify ticket epoch matches current epoch."
  },
  // Jupiter Aggregator
  {
    id: "SOL3853",
    name: "Jupiter - Route Manipulation",
    severity: "high",
    pattern: /jupiter[\s\S]{0,100}(?:route|swap)[\s\S]{0,100}(?!min_out|slippage)/,
    description: "Jupiter route without slippage protection.",
    recommendation: "Always set min_out for Jupiter swaps."
  },
  // Drift Protocol
  {
    id: "SOL3854",
    name: "Drift - Oracle Guard Rails",
    severity: "high",
    pattern: /drift[\s\S]{0,100}(?:oracle|price)[\s\S]{0,100}(?!guard|limit)/,
    description: "Drift oracle without guard rails.",
    recommendation: "Use Drift oracle guard rails for price bounds."
  },
  // Solend Protocol
  {
    id: "SOL3855",
    name: "Solend - Reserve Refresh Required",
    severity: "high",
    pattern: /solend[\s\S]{0,100}(?:reserve|rate)[\s\S]{0,100}(?!refresh)/,
    description: "Solend reserve not refreshed before use.",
    recommendation: "Refresh reserve before reading rates."
  },
  // Orca Whirlpool
  {
    id: "SOL3856",
    name: "Orca - Tick Array Bounds",
    severity: "high",
    pattern: /whirlpool[\s\S]{0,100}(?:tick|array)[\s\S]{0,100}(?!bounds_check)/,
    description: "Orca tick array access without bounds check.",
    recommendation: "Verify tick index within array bounds."
  },
  // Raydium
  {
    id: "SOL3857",
    name: "Raydium - Pool Authority Leak",
    severity: "critical",
    pattern: /raydium[\s\S]{0,100}(?:pool|authority)[\s\S]{0,100}(?!admin_only)/,
    description: "Raydium pool authority access pattern.",
    recommendation: "Verify admin permissions for pool operations."
  },
  // Metaplex
  {
    id: "SOL3858",
    name: "Metaplex - Collection Authority",
    severity: "high",
    pattern: /metaplex[\s\S]{0,100}(?:collection|authority)[\s\S]{0,100}(?!verify)/,
    description: "Collection authority not verified.",
    recommendation: "Verify collection authority for NFT operations."
  },
  // Phoenix
  {
    id: "SOL3859",
    name: "Phoenix - Order Book Crossing",
    severity: "high",
    pattern: /phoenix[\s\S]{0,100}(?:order|book)[\s\S]{0,100}(?!cross_check)/,
    description: "Phoenix order without crossing check.",
    recommendation: "Handle order book crossing conditions."
  }
];
var MEV_INFRASTRUCTURE_PATTERNS = [
  {
    id: "SOL3860",
    name: "MEV - JIT Liquidity Attack",
    severity: "high",
    pattern: /(?:liquidity|provision)[\s\S]{0,100}(?:add|remove)[\s\S]{0,100}(?!sandwich_protection)/,
    description: "Liquidity operation vulnerable to JIT sandwich.",
    recommendation: "Use private transactions or MEV protection."
  },
  {
    id: "SOL3861",
    name: "MEV - Order Flow Extraction",
    severity: "medium",
    pattern: /(?:order|trade)[\s\S]{0,100}(?:submit|send)[\s\S]{0,100}(?!private|protected)/,
    description: "Trade order visible in mempool for front-running.",
    recommendation: "Use Jito bundles or private transaction submission."
  },
  {
    id: "SOL3862",
    name: "MEV - Time-Bandit Reorganization",
    severity: "high",
    pattern: /(?:finality|confirm)[\s\S]{0,100}(?!sufficient_slots)/,
    description: "Insufficient confirmation slots for finality.",
    recommendation: "Wait for sufficient slot confirmations."
  },
  {
    id: "SOL3863",
    name: "Infra - Validator Stake Concentration",
    severity: "medium",
    pattern: /validator[\s\S]{0,100}(?:stake|delegation)[\s\S]{0,100}(?!diversity)/,
    description: "Stake concentration risk in validator selection.",
    recommendation: "Diversify stake across multiple validators."
  },
  {
    id: "SOL3864",
    name: "Infra - Hosting Provider Concentration",
    severity: "medium",
    pattern: /(?:deploy|host)[\s\S]{0,100}(?:aws|gcp|azure)[\s\S]{0,100}(?!multi_provider)/,
    description: "Single cloud provider concentration risk.",
    recommendation: "Distribute infrastructure across providers."
  },
  {
    id: "SOL3865",
    name: "Infra - RPC Provider Manipulation",
    severity: "high",
    pattern: /rpc[\s\S]{0,100}(?:endpoint|url)[\s\S]{0,100}(?!fallback|multi)/,
    description: "Single RPC provider enables manipulation.",
    recommendation: "Use multiple RPC providers with fallback."
  }
];
var TESTING_DEPLOYMENT_PATTERNS = [
  {
    id: "SOL3866",
    name: "Testing - Devnet Address in Mainnet",
    severity: "critical",
    pattern: /(?:devnet|testnet)[\s\S]{0,50}(?:address|pubkey|endpoint)/,
    description: "Devnet/testnet reference in mainnet code.",
    recommendation: "Remove all devnet/testnet references before mainnet."
  },
  {
    id: "SOL3867",
    name: "Testing - Debug Code in Production",
    severity: "high",
    pattern: /(?:debug|console\.log|println!)[\s\S]{0,50}(?!#\[cfg\(test\)\])/,
    description: "Debug code in production build.",
    recommendation: "Remove debug code or gate with cfg(test)."
  },
  {
    id: "SOL3868",
    name: "Testing - Missing Fuzzing",
    severity: "medium",
    pattern: /(?:test|spec)[\s\S]{0,100}(?!fuzz|arbitrary|quickcheck)/,
    description: "Test suite without fuzzing.",
    recommendation: "Add fuzz testing for input validation."
  },
  {
    id: "SOL3869",
    name: "Deployment - Upgrade Authority Active",
    severity: "medium",
    pattern: /upgrade[\s\S]{0,50}authority[\s\S]{0,100}(?!revoked|none)/,
    description: "Upgrade authority still active.",
    recommendation: "Consider revoking upgrade authority after deployment."
  },
  {
    id: "SOL3870",
    name: "Deployment - Mainnet Without Audit",
    severity: "high",
    pattern: /mainnet[\s\S]{0,100}(?:deploy|launch)[\s\S]{0,100}(?!audit|reviewed)/,
    description: "Mainnet deployment without audit reference.",
    recommendation: "Complete security audit before mainnet launch."
  }
];
var MISC_ADVANCED_PATTERNS = [
  {
    id: "SOL3871",
    name: "Misc - Timestamp Manipulation",
    severity: "medium",
    pattern: /(?:clock|unix_timestamp)[\s\S]{0,100}(?!slot_based|tolerance)/,
    description: "Timestamp used without manipulation protection.",
    recommendation: "Use slot-based timing or add timestamp tolerance."
  },
  {
    id: "SOL3872",
    name: "Misc - Slot-Based Randomness (Predictable)",
    severity: "high",
    pattern: /(?:random|seed)[\s\S]{0,50}(?:slot|hash)[\s\S]{0,100}(?!vrf|commit_reveal)/,
    description: "Slot-based randomness is predictable.",
    recommendation: "Use VRF or commit-reveal for randomness."
  },
  {
    id: "SOL3873",
    name: "Misc - CPI Return Data Spoofing",
    severity: "high",
    pattern: /(?:cpi|invoke)[\s\S]{0,100}(?:return|result)[\s\S]{0,100}(?!verify_program)/,
    description: "CPI return data accepted without program verification.",
    recommendation: "Verify program ID before trusting return data."
  },
  {
    id: "SOL3874",
    name: "Misc - Close Account Balance Drain",
    severity: "high",
    pattern: /close[\s\S]{0,100}(?:account|pda)[\s\S]{0,100}(?!destination_check)/,
    description: "Account close without destination verification.",
    recommendation: "Verify close destination is expected recipient."
  },
  {
    id: "SOL3875",
    name: "Misc - Rent Exemption Threshold",
    severity: "medium",
    pattern: /(?:lamports|balance)[\s\S]{0,100}(?!>=.*rent_exempt|minimum_balance)/,
    description: "Balance check without rent exemption consideration.",
    recommendation: "Account for rent-exempt minimum in balance checks."
  }
];
var BATCH_77_PATTERNS = [
  ...ARXIV_ACADEMIC_PATTERNS,
  ...SEALEVEL_ATTACKS,
  ...NEODYME_PATTERNS,
  ...OTTERSEC_PATTERNS,
  ...KUDELSKI_PATTERNS,
  ...ZELLIC_ANCHOR_PATTERNS,
  ...SEC3_AUDIT_PATTERNS,
  ...TRAIL_OF_BITS_PATTERNS,
  ...EXPLOIT_DEEP_PATTERNS,
  ...PROTOCOL_SPECIFIC,
  ...MEV_INFRASTRUCTURE_PATTERNS,
  ...TESTING_DEPLOYMENT_PATTERNS,
  ...MISC_ADVANCED_PATTERNS
];
function scanBatch77(input) {
  const findings = [];
  const content = input.content;
  const filePath = input.filePath || "unknown";
  for (const pattern of BATCH_77_PATTERNS) {
    const match = pattern.pattern.exec(content);
    if (match) {
      const lines = content.substring(0, match.index).split("\n");
      const line = lines.length;
      findings.push({
        id: pattern.id,
        name: pattern.name,
        severity: pattern.severity,
        description: pattern.description,
        recommendation: pattern.recommendation,
        file: filePath,
        line,
        snippet: match[0].substring(0, 200)
      });
    }
  }
  return findings;
}
var BATCH_77_COUNT = BATCH_77_PATTERNS.length;

// src/patterns/solana-batched-patterns-78.ts
var STEP_FINANCE_PATTERNS = [
  {
    id: "SOL3876",
    name: "Step Finance - Treasury Wallet Without Multisig",
    severity: "critical",
    pattern: /(?:treasury|protocol_wallet|reserve)[\s\S]{0,100}(?:Signer|authority)[\s\S]{0,50}(?!multisig|threshold|quorum)/i,
    description: "Treasury wallet controlled by single signer. Step Finance lost $30M+ when treasury keys were compromised.",
    recommendation: "Implement multisig (2-of-3 or higher) for all treasury operations. Use Squads or similar."
  },
  {
    id: "SOL3877",
    name: "Step Finance - Executive Key Exposure",
    severity: "critical",
    pattern: /(?:admin|owner|authority)[\s\S]{0,80}(?:single|solo|direct)[\s\S]{0,50}(?:transfer|withdraw|drain)/i,
    description: "Single executive key controls critical operations. Step Finance breach involved executive wallet compromise.",
    recommendation: "Distribute authority across multiple keys with threshold requirements."
  },
  {
    id: "SOL3878",
    name: "Step Finance - Commission Fund Drain Risk",
    severity: "high",
    pattern: /(?:commission|fee|revenue)[\s\S]{0,80}(?:withdraw|transfer|claim)[\s\S]{0,50}(?!timelock|delay|multisig)/i,
    description: "Commission funds withdrawable without delay. Step Finance treasury included accumulated fees.",
    recommendation: "Implement withdrawal delays and multisig for protocol fees."
  },
  {
    id: "SOL3879",
    name: "Step Finance - Monero Conversion Risk",
    severity: "high",
    pattern: /(?:bridge|swap|convert)[\s\S]{0,100}(?:cross.?chain|external|off.?chain)/i,
    description: "Stolen funds were rapidly converted to Monero for obfuscation. Consider tracking mechanisms.",
    recommendation: "Implement large transfer delays and circuit breakers for suspicious conversion patterns."
  },
  {
    id: "SOL3880",
    name: "Step Finance - STEP Token Price Impact",
    severity: "medium",
    pattern: /(?:token|native)[\s\S]{0,80}(?:price|value)[\s\S]{0,50}(?:treasury|protocol)/i,
    description: "Treasury breach caused STEP token to crater. Protocol token should have protective mechanisms.",
    recommendation: "Implement buyback mechanisms and treasury diversification."
  },
  {
    id: "SOL3881",
    name: "Step Finance - Hot Wallet Authority Pattern",
    severity: "critical",
    pattern: /(?:hot.?wallet|operational|active)[\s\S]{0,80}(?:authority|admin|owner)[\s\S]{0,50}(?:treasury|reserve)/i,
    description: "Hot wallet has authority over treasury funds. Step Finance pattern of executive key compromise.",
    recommendation: "Cold storage for treasury with hardware wallet multisig."
  },
  {
    id: "SOL3882",
    name: "Step Finance - Missing Withdrawal Limits",
    severity: "high",
    pattern: /(?:withdraw|transfer|drain)[\s\S]{0,100}amount[\s\S]{0,50}(?!max|limit|cap|threshold)/i,
    description: "Unlimited withdrawal amounts possible. Attackers drained 261,854 SOL (~$30M) in single operation.",
    recommendation: "Implement daily/weekly withdrawal limits with escalating approval requirements."
  },
  {
    id: "SOL3883",
    name: "Step Finance - No Emergency Pause",
    severity: "high",
    pattern: /(?:treasury|withdraw|transfer)[\s\S]{0,200}(?!pause|freeze|halt|emergency)/i,
    description: "No emergency pause mechanism for treasury operations.",
    recommendation: "Implement emergency pause controlled by security council."
  },
  {
    id: "SOL3884",
    name: "Step Finance - Missing Anomaly Detection",
    severity: "medium",
    pattern: /(?:treasury|protocol|reserve)[\s\S]{0,150}(?!monitor|alert|detect|anomaly)/i,
    description: "No on-chain anomaly detection for treasury operations.",
    recommendation: "Implement transaction monitoring and automated alerts for unusual patterns."
  },
  {
    id: "SOL3885",
    name: "Step Finance - Destination Validation Missing",
    severity: "high",
    pattern: /(?:withdraw|transfer)[\s\S]{0,100}(?:destination|recipient|to)[\s\S]{0,50}(?!whitelist|allowlist|validate)/i,
    description: "No destination validation for large transfers. Funds went to attacker-controlled addresses.",
    recommendation: "Implement address whitelisting for treasury withdrawals."
  },
  // ============================================================================
  // DEV.TO DEEP DIVE - INTEGER OVERFLOW/UNDERFLOW (Feb 2026)
  // ============================================================================
  {
    id: "SOL3886",
    name: "DEV.to #8 - Fee Calculation Overflow",
    severity: "critical",
    pattern: /(?:fee|commission|tax)[\s\S]{0,30}\*[\s\S]{0,20}(?:amount|balance|value)/i,
    description: "Fee multiplication without overflow protection. Integer overflow can zero out fees.",
    recommendation: "Use checked_mul or saturating_mul for all fee calculations."
  },
  {
    id: "SOL3887",
    name: "DEV.to #8 - Balance Subtraction Underflow",
    severity: "critical",
    pattern: /balance[\s\S]{0,20}-[\s\S]{0,20}(?:amount|withdrawal|transfer)[\s\S]{0,30}(?!checked|saturating)/i,
    description: "Balance subtraction without underflow check can wrap to max u64.",
    recommendation: "Use checked_sub for all balance decrements."
  },
  {
    id: "SOL3888",
    name: "DEV.to #8 - Token Supply Overflow",
    severity: "critical",
    pattern: /(?:supply|total_minted)[\s\S]{0,20}\+[\s\S]{0,20}(?:mint_amount|new_tokens)[\s\S]{0,30}(?!checked|saturating)/i,
    description: "Token supply addition without overflow check.",
    recommendation: "Use checked_add for supply changes with MAX_SUPPLY validation."
  },
  {
    id: "SOL3889",
    name: "DEV.to #8 - i32 Timestamp Year 2038",
    severity: "medium",
    pattern: /(?:timestamp|time|date)[\s\S]{0,30}i32/i,
    description: "Using i32 for timestamps will overflow on January 19, 2038.",
    recommendation: "Use i64 or u64 for all timestamp values."
  },
  {
    id: "SOL3890",
    name: "DEV.to #8 - Price Calculation Overflow",
    severity: "critical",
    pattern: /(?:price|rate|exchange)[\s\S]{0,30}\*[\s\S]{0,20}(?:amount|quantity)[\s\S]{0,30}(?!u128|checked|saturating)/i,
    description: "Price * amount can easily overflow u64. Use u128 for intermediate calculations.",
    recommendation: "Cast to u128 for multiplication, then validate result fits in u64."
  },
  // ============================================================================
  // DEV.TO DEEP DIVE - DUPLICATE MUTABLE ACCOUNTS (#10)
  // ============================================================================
  {
    id: "SOL3891",
    name: "DEV.to #10 - Duplicate Mutable Account Risk",
    severity: "critical",
    pattern: /(?:transfer|move)[\s\S]{0,100}(?:from|source)[\s\S]{0,50}(?:to|destination)[\s\S]{0,30}(?!key.*!=|!=.*key)/i,
    description: "Transfer without checking source != destination. Can double balance via self-transfer.",
    recommendation: "Always validate from_account.key() != to_account.key()."
  },
  {
    id: "SOL3892",
    name: "DEV.to #10 - Self-Reference Account Attack",
    severity: "critical",
    pattern: /(?:debit|subtract)[\s\S]{0,50}(?:credit|add)[\s\S]{0,100}(?!same|duplicate|!=)/i,
    description: "Debit and credit operations can be applied to same account, creating money.",
    recommendation: "Check all account pairs for uniqueness before operations."
  },
  {
    id: "SOL3893",
    name: "DEV.to #10 - Anchor Duplicate Account Check Missing",
    severity: "high",
    pattern: /#\[account\([\s\S]{0,100}mut[\s\S]{0,100}(?!constraint.*!=)/i,
    description: "Mutable accounts without constraint checking uniqueness.",
    recommendation: "Add constraint = from.key() != to.key() for account pairs."
  },
  // ============================================================================
  // DEV.TO DEEP DIVE - CLOSE ACCOUNT WITHOUT ZEROING (#9)
  // ============================================================================
  {
    id: "SOL3894",
    name: "DEV.to #9 - Close Account Data Not Zeroed",
    severity: "critical",
    pattern: /(?:close|lamports.*=.*0)[\s\S]{0,100}(?!data.*=.*0|zero|clear|memset)/i,
    description: "Closing account without zeroing data allows resurrection with stale data.",
    recommendation: "Zero all account data bytes before close. Use Anchor close constraint."
  },
  {
    id: "SOL3895",
    name: "DEV.to #9 - Close Without Discriminator Clear",
    severity: "critical",
    pattern: /(?:close|destroy)[\s\S]{0,80}(?!discriminator.*0|disc.*clear)/i,
    description: "Discriminator not cleared on close. Account can be reopened with same type.",
    recommendation: "Set discriminator to zero or CLOSED marker on close."
  },
  {
    id: "SOL3896",
    name: "DEV.to #9 - Rent Siphoning Attack",
    severity: "high",
    pattern: /close[\s\S]{0,80}(?:lamports|rent)[\s\S]{0,50}(?!minimum|exempt|check)/i,
    description: "Rent can be drained from account before close by making it non-exempt.",
    recommendation: "Verify rent exemption before closing to recover full lamports."
  },
  {
    id: "SOL3897",
    name: "DEV.to #9 - Close Account Resurrection",
    severity: "critical",
    pattern: /(?:close|destroy)[\s\S]{0,100}(?:same.*slot|block|transaction)/i,
    description: "Closed account can be resurrected within same transaction block.",
    recommendation: "Implement close account cooldown or permanent closure markers."
  },
  // ============================================================================
  // NOONES P2P BRIDGE EXPLOIT ($8M, Jan 2025)
  // ============================================================================
  {
    id: "SOL3898",
    name: "NoOnes - P2P Bridge Authentication Bypass",
    severity: "critical",
    pattern: /(?:bridge|cross.?chain|p2p)[\s\S]{0,100}(?:transfer|withdraw)[\s\S]{0,50}(?!verify|auth|sig)/i,
    description: "P2P bridge without proper authentication. NoOnes lost $8M across multiple chains.",
    recommendation: "Implement multi-party verification for all bridge operations."
  },
  {
    id: "SOL3899",
    name: "NoOnes - Cross-Chain Message Replay",
    severity: "critical",
    pattern: /(?:message|payload)[\s\S]{0,80}(?:bridge|relay)[\s\S]{0,50}(?!nonce|sequence|unique)/i,
    description: "Cross-chain messages can be replayed. NoOnes exploit involved replay attacks.",
    recommendation: "Include unique nonce or sequence number in all bridge messages."
  },
  {
    id: "SOL3900",
    name: "NoOnes - Multi-Chain Coordination Failure",
    severity: "high",
    pattern: /(?:multi.?chain|cross.?chain)[\s\S]{0,100}(?:transfer|bridge)[\s\S]{0,50}(?!finality|confirm)/i,
    description: "Multi-chain operations without proper finality checks.",
    recommendation: "Wait for source chain finality before executing destination chain operations."
  },
  // ============================================================================
  // UPBIT HOT WALLET PATTERN ($36M, Nov 2025)
  // ============================================================================
  {
    id: "SOL3901",
    name: "Upbit - Exchange Hot Wallet Isolation Failure",
    severity: "critical",
    pattern: /(?:hot.?wallet|exchange)[\s\S]{0,100}(?:deposit|withdraw)[\s\S]{0,50}(?!hsm|isolated|air.?gap)/i,
    description: "Exchange hot wallet without HSM isolation. Upbit lost $36M from hot wallet breach.",
    recommendation: "Use HSM for hot wallet keys with strict access controls."
  },
  {
    id: "SOL3902",
    name: "Upbit - Deposit Address Validation Missing",
    severity: "high",
    pattern: /(?:deposit|receive)[\s\S]{0,80}(?:address|account)[\s\S]{0,50}(?!validate|verify|whitelist)/i,
    description: "Deposit addresses not properly validated. Can accept attacker-controlled addresses.",
    recommendation: "Validate all deposit addresses against known user accounts."
  },
  {
    id: "SOL3903",
    name: "Upbit - Withdrawal API Abuse",
    severity: "critical",
    pattern: /(?:withdraw|api)[\s\S]{0,100}(?!rate.?limit|throttle|cooldown)/i,
    description: "Withdrawal API without rate limiting. Enables rapid fund extraction.",
    recommendation: "Implement rate limits, velocity checks, and cooling periods for withdrawals."
  },
  // ============================================================================
  // DECEMBER 2025 SOLANA CONSENSUS VULNERABILITIES
  // ============================================================================
  {
    id: "SOL3904",
    name: "Consensus Vuln - Network Stalling Attack Vector",
    severity: "critical",
    pattern: /(?:consensus|validator|vote)[\s\S]{0,100}(?:block|slot)[\s\S]{0,50}(?:stall|halt|freeze)/i,
    description: "December 2025 disclosed consensus vulnerabilities could stall network.",
    recommendation: "Update to patched Solana client versions (Anza/Firedancer/Jito coordinated fix)."
  },
  {
    id: "SOL3905",
    name: "Consensus Vuln - Validator Concentration Risk",
    severity: "high",
    pattern: /(?:validator|stake)[\s\S]{0,100}(?:concentration|centralize|single)/i,
    description: "High validator concentration (Jito 88%) amplifies consensus vulnerabilities.",
    recommendation: "Monitor validator client diversity and stake distribution."
  },
  // ============================================================================
  // TRUST WALLET CHROME EXTENSION BREACH ($7M)
  // ============================================================================
  {
    id: "SOL3906",
    name: "Trust Wallet - Analytics Library Key Harvesting",
    severity: "critical",
    pattern: /(?:analytics|posthog|telemetry)[\s\S]{0,100}(?:key|private|seed|secret)/i,
    description: "Analytics libraries can harvest keys. Trust Wallet lost $7M via posthog-js vulnerability.",
    recommendation: "Never pass sensitive data to analytics. Audit all third-party dependencies."
  },
  {
    id: "SOL3907",
    name: "Trust Wallet - Third-Party Library Exposure",
    severity: "high",
    pattern: /(?:import|require|from)[\s\S]{0,50}(?:analytics|tracking|telemetry)/i,
    description: "Third-party analytics libraries are a supply chain attack vector.",
    recommendation: "Minimize third-party dependencies. Use CSP to restrict data exfiltration."
  },
  {
    id: "SOL3908",
    name: "Trust Wallet - Browser Extension Security",
    severity: "high",
    pattern: /(?:extension|browser|chrome)[\s\S]{0,100}(?:storage|key|private)/i,
    description: "Browser extension key storage vulnerable to malicious extensions or XSS.",
    recommendation: "Use encrypted storage with user-derived keys. Never store raw secrets."
  },
  // ============================================================================
  // CERTIK JANUARY 2026 - $400M+ LOSSES
  // ============================================================================
  {
    id: "SOL3909",
    name: "CertiK 2026 - Private Key Logging",
    severity: "critical",
    pattern: /(?:log|print|debug|console)[\s\S]{0,50}(?:key|secret|private|seed)/i,
    description: "Private keys logged to output. CertiK reports key exposure as top vulnerability.",
    recommendation: "Never log sensitive data. Use dedicated secrets management."
  },
  {
    id: "SOL3910",
    name: "CertiK 2026 - Exit Scam Function",
    severity: "critical",
    pattern: /(?:drain|rug|emergency_withdraw|owner_withdraw)[\s\S]{0,50}(?:all|entire|full)/i,
    description: "Function to drain all funds. Common rug pull indicator.",
    recommendation: "Remove owner-only drain functions. Use timelock for emergency operations."
  },
  {
    id: "SOL3911",
    name: "CertiK 2026 - Flash Loan Without Guard",
    severity: "high",
    pattern: /(?:flash.?loan|borrow.?return)[\s\S]{0,100}(?!reentrancy|guard|lock)/i,
    description: "Flash loan implementation without reentrancy protection.",
    recommendation: "Implement reentrancy guards for all flash loan functions."
  },
  {
    id: "SOL3912",
    name: "CertiK 2026 - Single Oracle Dependency",
    severity: "high",
    pattern: /(?:oracle|price.?feed)[\s\S]{0,100}(?!fallback|backup|aggregate|multiple)/i,
    description: "Single oracle without fallback. Oracle manipulation is #1 DeFi attack vector.",
    recommendation: "Use multiple oracle sources with median or weighted aggregation."
  },
  {
    id: "SOL3913",
    name: "CertiK 2026 - Protocol Without Insurance",
    severity: "medium",
    pattern: /(?:protocol|defi|lending)[\s\S]{0,200}(?!insurance|reserve|coverage)/i,
    description: "Protocol without insurance fund for black swan events.",
    recommendation: "Maintain insurance reserve of 5-10% of TVL."
  },
  // ============================================================================
  // ADVANCED ACCOUNT VALIDATION (DEV.to Deep Patterns)
  // ============================================================================
  {
    id: "SOL3914",
    name: "Advanced - AccountInfo Without Framework",
    severity: "high",
    pattern: /AccountInfo[\s\S]{0,100}(?!Account<|Signer<|UncheckedAccount)/i,
    description: "Raw AccountInfo usage without Anchor type wrappers increases vulnerability surface.",
    recommendation: "Use Anchor Account<T> types for automatic validation."
  },
  {
    id: "SOL3915",
    name: "Advanced - Manual Deserialization Risk",
    severity: "high",
    pattern: /(?:try_from_slice|deserialize|borsh::from)[\s\S]{0,80}(?!discriminator|check)/i,
    description: "Manual deserialization without discriminator verification.",
    recommendation: "Always check discriminator bytes before deserializing account data."
  },
  {
    id: "SOL3916",
    name: "Advanced - UncheckedAccount Without Doc",
    severity: "medium",
    pattern: /UncheckedAccount[\s\S]{0,30}(?!CHECK:|SAFETY:)/i,
    description: "UncheckedAccount without safety documentation.",
    recommendation: "Add /// CHECK: comment explaining why account is safe to use unchecked."
  },
  {
    id: "SOL3917",
    name: "Advanced - Shared Data Layout Attack",
    severity: "critical",
    pattern: /struct[\s\S]{0,200}pub[\s\S]{0,30}:[\s\S]{0,30}u64[\s\S]{0,100}pub[\s\S]{0,30}:[\s\S]{0,30}Pubkey/i,
    description: "Struct layout similar to other types enables type cosplay attacks.",
    recommendation: "Use unique discriminators and validate account type before use."
  },
  {
    id: "SOL3918",
    name: "Advanced - Zero Discriminator Check",
    severity: "critical",
    pattern: /discriminator[\s\S]{0,30}==[\s\S]{0,20}\[0[\s\S]{0,20}\]/i,
    description: "Zero discriminator check allows uninitialized accounts to pass validation.",
    recommendation: "Check for non-zero discriminator and match expected type."
  },
  // ============================================================================
  // PDA SECURITY (DEV.to #5 Deep Patterns)
  // ============================================================================
  {
    id: "SOL3919",
    name: "PDA - create_program_address Without find",
    severity: "high",
    pattern: /create_program_address[\s\S]{0,100}(?!find_program_address)/i,
    description: "Using create_program_address directly risks non-canonical bumps.",
    recommendation: "Always use find_program_address to get canonical bump."
  },
  {
    id: "SOL3920",
    name: "PDA - User-Controlled Seeds",
    severity: "high",
    pattern: /seeds[\s\S]{0,50}(?:user|input|param)[\s\S]{0,30}(?:\.as_ref|\.to_bytes)/i,
    description: "User-controlled values in PDA seeds can create collisions or shadow PDAs.",
    recommendation: "Validate user inputs used in seeds. Use fixed prefixes."
  },
  {
    id: "SOL3921",
    name: "PDA - Bump Not Stored",
    severity: "medium",
    pattern: /find_program_address[\s\S]{0,100}(?!bump[\s\S]{0,20}=|store.*bump)/i,
    description: "PDA bump not stored for later verification.",
    recommendation: "Store canonical bump in account data for subsequent validations."
  },
  {
    id: "SOL3922",
    name: "PDA - Shadow PDA Creation Risk",
    severity: "high",
    pattern: /seeds[\s\S]{0,80}bump[\s\S]{0,50}(?:user|param|input)/i,
    description: "User-provided bump allows creation of shadow PDAs at different addresses.",
    recommendation: "Always derive bump using find_program_address, never accept from input."
  },
  // ============================================================================
  // CPI SECURITY (DEV.to #7 Deep Patterns)
  // ============================================================================
  {
    id: "SOL3923",
    name: "CPI - Unchecked Target Program",
    severity: "critical",
    pattern: /invoke(?:_signed)?[\s\S]{0,80}(?:program|target)[\s\S]{0,50}(?!spl_token|token_program|system_program)/i,
    description: "CPI to potentially user-controlled program ID.",
    recommendation: "Hardcode trusted program IDs or validate against whitelist."
  },
  {
    id: "SOL3924",
    name: "CPI - Program ID From Account",
    severity: "critical",
    pattern: /(?:program|target)[\s\S]{0,30}\.key[\s\S]{0,50}invoke/i,
    description: "CPI program ID read from account allows arbitrary program invocation.",
    recommendation: "Use Program<T> type to verify program ID matches expected."
  },
  {
    id: "SOL3925",
    name: "CPI - Token Transfer Without SPL Verify",
    severity: "critical",
    pattern: /transfer[\s\S]{0,100}invoke[\s\S]{0,50}(?!spl_token::id|token_program::check)/i,
    description: "Token transfer CPI without verifying SPL Token program ID.",
    recommendation: "Always verify token_program.key() == spl_token::id() before CPI."
  },
  {
    id: "SOL3926",
    name: "CPI - Seeds With User Data",
    severity: "high",
    pattern: /invoke_signed[\s\S]{0,100}seeds[\s\S]{0,50}(?:user|input|param)/i,
    description: "CPI seeds include user-controlled data, enabling seed manipulation.",
    recommendation: "Validate all user inputs used in CPI seeds."
  },
  {
    id: "SOL3927",
    name: "CPI - Account Order Manipulation",
    severity: "high",
    pattern: /invoke[\s\S]{0,100}accounts[\s\S]{0,80}(?:vec!|&\[)[\s\S]{0,50}(?:input|user|param)/i,
    description: "Account order in CPI can be manipulated if not validated.",
    recommendation: "Validate account positions match expected program interface."
  },
  // ============================================================================
  // REENTRANCY (DEV.to Deep Patterns)
  // ============================================================================
  {
    id: "SOL3928",
    name: "Reentrancy - State After CPI",
    severity: "critical",
    pattern: /invoke[\s\S]{0,150}(?:\.amount|\.balance|\.data)[\s\S]{0,30}=/i,
    description: "State modified after CPI call is vulnerable to reentrancy.",
    recommendation: "Update all state before CPI calls (checks-effects-interactions)."
  },
  {
    id: "SOL3929",
    name: "Reentrancy - Callback Without Guard",
    severity: "critical",
    pattern: /(?:callback|on_receive|after_transfer)[\s\S]{0,100}(?!reentrancy|guard|lock)/i,
    description: "Callback function without reentrancy protection.",
    recommendation: "Implement reentrancy guard using flag or mutex pattern."
  },
  {
    id: "SOL3930",
    name: "Reentrancy - Cross-Instruction Leak",
    severity: "high",
    pattern: /(?:instruction|ix)[\s\S]{0,100}(?:state|storage)[\s\S]{0,50}(?!reset|clear|finalize)/i,
    description: "State not finalized between instructions allows cross-instruction attacks.",
    recommendation: "Finalize all state changes at instruction end."
  },
  {
    id: "SOL3931",
    name: "Reentrancy - CPI Depth Exhaustion",
    severity: "medium",
    pattern: /invoke[\s\S]{0,80}invoke[\s\S]{0,80}invoke/i,
    description: "Deep CPI chains can exceed stack depth (4 levels).",
    recommendation: "Limit CPI depth and handle StackExhausted errors."
  },
  // ============================================================================
  // PHISHING & SOCIAL ENGINEERING (Jan 2026)
  // ============================================================================
  {
    id: "SOL3932",
    name: "Phishing - SetAuthority Without Confirmation",
    severity: "critical",
    pattern: /(?:set_authority|transfer_authority|change_owner)[\s\S]{0,100}(?!confirm|two.?step|delay)/i,
    description: "Authority change without two-step confirmation. Top phishing vector in Jan 2026.",
    recommendation: "Implement two-step authority transfer with timelock."
  },
  {
    id: "SOL3933",
    name: "Phishing - Silent Ownership Transfer",
    severity: "critical",
    pattern: /(?:owner|authority)[\s\S]{0,50}=[\s\S]{0,50}(?:new|input|param)[\s\S]{0,50}(?!event|emit|log)/i,
    description: "Ownership transfer without event emission hides malicious changes.",
    recommendation: "Emit events for all authority/ownership changes."
  },
  {
    id: "SOL3934",
    name: "Phishing - Memo-Based Attack Vector",
    severity: "medium",
    pattern: /(?:memo|message|note)[\s\S]{0,80}(?:instruction|transaction)/i,
    description: "Memo fields used for phishing. Users see legitimate-looking messages.",
    recommendation: "Warn users not to trust memo contents for authorization."
  },
  {
    id: "SOL3935",
    name: "Phishing - Fake Airdrop Claim",
    severity: "high",
    pattern: /(?:airdrop|claim|reward)[\s\S]{0,100}(?:transfer|approve|delegate)/i,
    description: "Airdrop claims that secretly approve token access.",
    recommendation: "Never bundle approval operations with claims."
  },
  {
    id: "SOL3936",
    name: "Phishing - Unlimited Token Approval",
    severity: "critical",
    pattern: /(?:approve|delegate)[\s\S]{0,50}(?:u64::MAX|MAX_AMOUNT|unlimited)/i,
    description: "Unlimited token approval enables future wallet drain.",
    recommendation: "Request only necessary approval amounts with expiration."
  },
  {
    id: "SOL3937",
    name: "Phishing - Session Key Without Expiry",
    severity: "high",
    pattern: /(?:session|delegate|permission)[\s\S]{0,80}(?!expiry|expires|valid_until|ttl)/i,
    description: "Session keys without expiration remain perpetually valid.",
    recommendation: "All delegated permissions must have expiration timestamps."
  },
  {
    id: "SOL3938",
    name: "Phishing - Simulation Bypass via Owner",
    severity: "critical",
    pattern: /(?:simulate|preview)[\s\S]{0,100}(?:owner|authority)[\s\S]{0,50}(?:change|modify)/i,
    description: "Owner field changes bypass transaction simulation protection.",
    recommendation: "Simulation must include full ownership transfer detection."
  },
  // ============================================================================
  // ORACLE SECURITY DEEP PATTERNS
  // ============================================================================
  {
    id: "SOL3939",
    name: "Oracle - Solend Attack Pattern ($1.26M)",
    severity: "critical",
    pattern: /(?:oracle|price)[\s\S]{0,100}(?:single|one)[\s\S]{0,50}(?:pool|source|feed)/i,
    description: "Single oracle source like Solend attack. USDH priced at $8.80 instead of $1.",
    recommendation: "Use multiple price sources with deviation checks."
  },
  {
    id: "SOL3940",
    name: "Oracle - Staleness Without Check",
    severity: "high",
    pattern: /(?:price|oracle)[\s\S]{0,100}(?!staleness|timestamp|age|fresh)/i,
    description: "Oracle data used without staleness validation.",
    recommendation: "Verify oracle timestamp within acceptable freshness window."
  },
  {
    id: "SOL3941",
    name: "Oracle - Confidence Interval Ignored",
    severity: "high",
    pattern: /(?:pyth|oracle)[\s\S]{0,80}(?:price|value)[\s\S]{0,50}(?!conf|confidence|deviation)/i,
    description: "Oracle confidence interval not checked. Wide spreads indicate manipulation.",
    recommendation: "Reject prices where confidence interval exceeds threshold."
  },
  {
    id: "SOL3942",
    name: "Oracle - TWAP Window Too Short",
    severity: "high",
    pattern: /(?:twap|time.?weighted)[\s\S]{0,50}(?:window|period)[\s\S]{0,30}(?:60|120|300)/i,
    description: "TWAP window under 10 minutes susceptible to flash manipulation.",
    recommendation: "Use minimum 30-minute TWAP for price-sensitive operations."
  },
  {
    id: "SOL3943",
    name: "Oracle - Flash Loan Price Attack",
    severity: "critical",
    pattern: /(?:flash.?loan|borrow)[\s\S]{0,100}(?:price|oracle|value)/i,
    description: "Price read during flash loan can be manipulated within single transaction.",
    recommendation: "Use TWAP or block-delayed prices for flash-loan-sensitive operations."
  },
  // ============================================================================
  // LENDING PROTOCOL SECURITY
  // ============================================================================
  {
    id: "SOL3944",
    name: "Lending - Health Factor Bypass",
    severity: "critical",
    pattern: /(?:health|collateral)[\s\S]{0,80}(?:factor|ratio)[\s\S]{0,50}(?!check|require|assert)/i,
    description: "Health factor not properly validated before borrow/withdraw.",
    recommendation: "Require health_factor > 1.0 for all position changes."
  },
  {
    id: "SOL3945",
    name: "Lending - Liquidation Bonus Inflation",
    severity: "high",
    pattern: /(?:liquidation|bonus|incentive)[\s\S]{0,80}(?!max|cap|limit)/i,
    description: "Unbounded liquidation bonus can be exploited. Solend pattern.",
    recommendation: "Cap liquidation bonus at reasonable percentage (5-10%)."
  },
  {
    id: "SOL3946",
    name: "Lending - Interest Rate Spike",
    severity: "high",
    pattern: /(?:interest|rate|apy)[\s\S]{0,80}(?:utilization|curve)[\s\S]{0,50}(?!max|cap|ceiling)/i,
    description: "Unbounded interest rate can spike to extreme values.",
    recommendation: "Implement interest rate ceiling and gradual adjustment."
  },
  {
    id: "SOL3947",
    name: "Lending - Bad Debt Socialization",
    severity: "high",
    pattern: /(?:bad.?debt|underwater|insolvent)[\s\S]{0,100}(?!insurance|reserve|fund)/i,
    description: "No mechanism to handle bad debt can leave protocol insolvent.",
    recommendation: "Maintain insurance fund and implement bad debt socialization."
  },
  {
    id: "SOL3948",
    name: "Lending - Borrow Exceeds Collateral",
    severity: "critical",
    pattern: /(?:borrow|debt)[\s\S]{0,80}(?!<=|<|collateral|max)/i,
    description: "Borrow amount not properly capped by collateral value.",
    recommendation: "Enforce borrow_amount <= collateral_value * LTV."
  },
  // ============================================================================
  // AMM/DEX SECURITY
  // ============================================================================
  {
    id: "SOL3949",
    name: "AMM - Constant Product Violation",
    severity: "critical",
    pattern: /(?:swap|trade)[\s\S]{0,100}(?:reserve|pool)[\s\S]{0,50}(?!invariant|k.*check|product)/i,
    description: "AMM swap without constant product (k) verification.",
    recommendation: "Verify reserve_a * reserve_b >= k after every swap."
  },
  {
    id: "SOL3950",
    name: "AMM - LP Token Inflation Attack",
    severity: "critical",
    pattern: /(?:mint|lp.?token)[\s\S]{0,100}(?:first|initial)[\s\S]{0,50}(?!minimum|burn|lock)/i,
    description: "First depositor can inflate LP tokens. Classic vault attack.",
    recommendation: "Burn minimum LP tokens on first deposit or use dead shares."
  },
  {
    id: "SOL3951",
    name: "AMM - Sandwich Attack Vector",
    severity: "high",
    pattern: /(?:swap|trade)[\s\S]{0,100}(?!slippage|min.?out|deadline)/i,
    description: "Swap without slippage protection enables sandwich attacks.",
    recommendation: "Require minimum output amount and deadline for all swaps."
  },
  {
    id: "SOL3952",
    name: "AMM - Reserve Manipulation",
    severity: "critical",
    pattern: /(?:reserve|pool.?balance)[\s\S]{0,50}=[\s\S]{0,50}(?!sync|update.?balance)/i,
    description: "Direct reserve manipulation without sync to actual balances.",
    recommendation: "Sync reserves from actual token balances, not cached values."
  },
  // ============================================================================
  // GOVERNANCE SECURITY
  // ============================================================================
  {
    id: "SOL3953",
    name: "Governance - Flash Vote Attack",
    severity: "critical",
    pattern: /(?:vote|proposal)[\s\S]{0,100}(?:power|weight)[\s\S]{0,50}(?!snapshot|lock|delay)/i,
    description: "Voting power not snapshotted allows flash loan governance attacks.",
    recommendation: "Snapshot voting power at proposal creation."
  },
  {
    id: "SOL3954",
    name: "Governance - No Execution Delay",
    severity: "high",
    pattern: /(?:proposal|governance)[\s\S]{0,100}(?:execute|apply)[\s\S]{0,50}(?!delay|timelock|queue)/i,
    description: "Proposals execute immediately without delay for review.",
    recommendation: "Implement 24-48 hour delay between approval and execution."
  },
  {
    id: "SOL3955",
    name: "Governance - Quorum Manipulation",
    severity: "high",
    pattern: /(?:quorum|threshold)[\s\S]{0,80}(?:total|supply)[\s\S]{0,50}(?!snapshot|fixed)/i,
    description: "Quorum based on current supply can be manipulated via minting/burning.",
    recommendation: "Use fixed or snapshotted quorum values."
  },
  {
    id: "SOL3956",
    name: "Governance - Audius Pattern ($6.1M)",
    severity: "critical",
    pattern: /(?:proposal|governance)[\s\S]{0,100}(?:create|submit)[\s\S]{0,50}(?!validate|verify)/i,
    description: "Malicious proposals without validation. Audius lost $6.1M to governance hijack.",
    recommendation: "Validate proposal data and require multi-sig for sensitive operations."
  },
  // ============================================================================
  // TOKEN-2022 SECURITY
  // ============================================================================
  {
    id: "SOL3957",
    name: "Token-2022 - Transfer Hook Reentrancy",
    severity: "critical",
    pattern: /(?:transfer.?hook|on.?transfer)[\s\S]{0,100}(?!reentrancy|guard|lock)/i,
    description: "Transfer hooks can be reentrant, executing arbitrary code mid-transfer.",
    recommendation: "Implement reentrancy guards in transfer hook handlers."
  },
  {
    id: "SOL3958",
    name: "Token-2022 - Confidential Transfer Leak",
    severity: "high",
    pattern: /(?:confidential|private)[\s\S]{0,80}(?:transfer|amount)[\s\S]{0,50}(?!decrypt|reveal)/i,
    description: "Confidential transfer amounts may leak through side channels.",
    recommendation: "Audit confidential transfer implementation for timing/size leaks."
  },
  {
    id: "SOL3959",
    name: "Token-2022 - Transfer Fee Bypass",
    severity: "high",
    pattern: /(?:transfer.?fee|fee.?config)[\s\S]{0,100}(?!enforce|validate|require)/i,
    description: "Transfer fees can be bypassed through approval-based transfers.",
    recommendation: "Enforce fees on all transfer paths including approvals."
  },
  {
    id: "SOL3960",
    name: "Token-2022 - Interest Bearing Manipulation",
    severity: "high",
    pattern: /(?:interest|rebase|rate)[\s\S]{0,80}(?:update|change)[\s\S]{0,50}(?!admin|auth|timelock)/i,
    description: "Interest rate changes without proper authorization.",
    recommendation: "Require admin + timelock for interest rate modifications."
  },
  {
    id: "SOL3961",
    name: "Token-2022 - Permanent Delegate Abuse",
    severity: "critical",
    pattern: /(?:permanent|unlimited)[\s\S]{0,50}(?:delegate|approval)/i,
    description: "Permanent delegate can drain tokens at any time.",
    recommendation: "Avoid permanent delegates. Use time-limited approvals."
  },
  // ============================================================================
  // INFRASTRUCTURE SECURITY
  // ============================================================================
  {
    id: "SOL3962",
    name: "Infra - Jito Client Concentration",
    severity: "medium",
    pattern: /(?:validator|client|node)[\s\S]{0,100}(?:jito|mev)/i,
    description: "Jito client at 88% concentration. Single vulnerability affects entire network.",
    recommendation: "Encourage client diversity in documentation and partnerships."
  },
  {
    id: "SOL3963",
    name: "Infra - RPC Provider Manipulation",
    severity: "high",
    pattern: /(?:rpc|provider|endpoint)[\s\S]{0,100}(?!validate|verify|multiple)/i,
    description: "Single RPC provider can return manipulated data.",
    recommendation: "Use multiple RPC providers with response validation."
  },
  {
    id: "SOL3964",
    name: "Infra - Address Lookup Table Poisoning",
    severity: "high",
    pattern: /(?:lookup.?table|alt|address.?table)[\s\S]{0,100}(?!verify|validate|check)/i,
    description: "Lookup tables can be poisoned with malicious addresses.",
    recommendation: "Validate all addresses from lookup tables before use."
  },
  {
    id: "SOL3965",
    name: "Infra - Priority Fee Front-Running",
    severity: "medium",
    pattern: /(?:priority|fee)[\s\S]{0,80}(?:set|compute)/i,
    description: "Priority fee setting enables MEV extraction through front-running.",
    recommendation: "Use private transaction submission or Jito bundles."
  },
  {
    id: "SOL3966",
    name: "Infra - Durable Nonce Replay",
    severity: "high",
    pattern: /(?:durable|nonce)[\s\S]{0,80}(?:advance|use)[\s\S]{0,50}(?!single|once|consume)/i,
    description: "Durable nonce reuse enables transaction replay.",
    recommendation: "Consume nonce in same transaction as signed operation."
  },
  // ============================================================================
  // TESTING & DEPLOYMENT PATTERNS
  // ============================================================================
  {
    id: "SOL3967",
    name: "Deploy - Devnet Address in Mainnet",
    severity: "critical",
    pattern: /(?:devnet|testnet)[\s\S]{0,50}(?:address|pubkey|program)/i,
    description: "Devnet addresses in mainnet code will fail or use wrong programs.",
    recommendation: "Use environment-specific configuration for all addresses."
  },
  {
    id: "SOL3968",
    name: "Deploy - Debug Code in Production",
    severity: "high",
    pattern: /(?:#\[cfg\(debug|println!|dbg!|console\.log)/i,
    description: "Debug code in production increases attack surface and compute costs.",
    recommendation: "Remove all debug statements before mainnet deployment."
  },
  {
    id: "SOL3969",
    name: "Deploy - Upgrade Authority Active",
    severity: "medium",
    pattern: /(?:upgrade|authority)[\s\S]{0,80}(?:active|enabled|present)/i,
    description: "Active upgrade authority can push malicious updates.",
    recommendation: "Set upgrade authority to null for immutable programs."
  },
  {
    id: "SOL3970",
    name: "Deploy - Missing Audit",
    severity: "high",
    pattern: /(?:mainnet|production)[\s\S]{0,100}(?!audit|review|certik|ottersec|sec3)/i,
    description: "Deployment to mainnet without security audit.",
    recommendation: "Obtain professional security audit before mainnet launch."
  },
  // ============================================================================
  // MISCELLANEOUS CRITICAL PATTERNS
  // ============================================================================
  {
    id: "SOL3971",
    name: "Misc - Slot-Based Randomness",
    severity: "high",
    pattern: /(?:random|seed)[\s\S]{0,50}(?:slot|clock|timestamp)/i,
    description: "Slot/timestamp-based randomness is predictable by validators.",
    recommendation: "Use VRF (Switchboard) or commit-reveal for randomness."
  },
  {
    id: "SOL3972",
    name: "Misc - CPI Return Data Spoofing",
    severity: "high",
    pattern: /(?:return.?data|get_return|sol_get_return)/i,
    description: "CPI return data can be spoofed by malicious programs.",
    recommendation: "Verify calling program ID matches expected before trusting return data."
  },
  {
    id: "SOL3973",
    name: "Misc - Close Account Balance Drain",
    severity: "high",
    pattern: /(?:close|lamports.*=.*0)[\s\S]{0,80}(?:destination|recipient)/i,
    description: "Close account destination can be manipulated to drain lamports.",
    recommendation: "Hardcode or validate close account destination."
  },
  {
    id: "SOL3974",
    name: "Misc - Rent Exemption Threshold",
    severity: "medium",
    pattern: /(?:rent|lamports)[\s\S]{0,80}(?!minimum|exempt|check)/i,
    description: "Account below rent exemption will be garbage collected.",
    recommendation: "Verify rent exemption before account creation."
  },
  {
    id: "SOL3975",
    name: "Misc - Compute Unit Limit Griefing",
    severity: "medium",
    pattern: /(?:compute|cu)[\s\S]{0,80}(?:limit|budget)[\s\S]{0,50}(?!set|configure)/i,
    description: "Default compute limits may be insufficient for complex operations.",
    recommendation: "Set explicit compute unit limits for all instructions."
  }
];
var ALL_BATCH_78_PATTERNS = [
  ...STEP_FINANCE_PATTERNS
];
function checkBatch78Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  if (!content) return findings;
  for (const pattern of ALL_BATCH_78_PATTERNS) {
    if (pattern.pattern.test(content)) {
      const lines = content.split("\n");
      let lineNumber = 1;
      for (let i = 0; i < lines.length; i++) {
        if (pattern.pattern.test(lines[i])) {
          lineNumber = i + 1;
          break;
        }
      }
      findings.push({
        id: pattern.id,
        title: pattern.name,
        severity: pattern.severity,
        description: pattern.description,
        location: { file: input.path, line: lineNumber },
        recommendation: pattern.recommendation
      });
    }
  }
  return findings;
}
var solana_batched_patterns_78_default = {
  checkBatch78Patterns,
  patterns: ALL_BATCH_78_PATTERNS,
  count: ALL_BATCH_78_PATTERNS.length
};

// src/patterns/solana-batched-patterns-79.ts
function checkBatch79Patterns(parsed, filePath) {
  const findings = [];
  const content = parsed.content;
  const lines = content.split("\n");
  const hasSlotOrClockCheck = /get_slot|Clock::get|clock\.slot/i.test(content);
  const hasRandomnessOrRoulette = /random|roulette|gambl|lottery|dice|flip/i.test(content);
  if (hasRandomnessOrRoulette && !hasSlotOrClockCheck) {
    findings.push({
      id: "SOL3976",
      title: "Cope Roulette - Transaction Reversion Gaming",
      severity: "high",
      description: "Randomness-based programs without proper slot/block validation can be exploited via transaction reversion attacks. Attackers can submit transactions and revert unfavorable outcomes.",
      location: { file: filePath, line: 1 },
      recommendation: "Use commit-reveal schemes, validate slot progression, or implement VRF-based randomness to prevent reversion gaming."
    });
  }
  const hasWithdrawMax = /max_withdraw|withdraw_max|maximum.*withdraw/i.test(content);
  const hasCalculationAfterCheck = /if.*<=.*\{[\s\S]*?amount\s*=|amount\s*=[\s\S]*?if/i.test(content);
  if (hasWithdrawMax && hasCalculationAfterCheck) {
    findings.push({
      id: "SOL3977",
      title: "Port Finance Max Withdraw Bug Pattern",
      severity: "high",
      description: "Max withdrawal calculation may have ordering issues where amount is modified after validation checks, allowing withdrawal of more than intended.",
      location: { file: filePath, line: 1 },
      recommendation: "Calculate max withdrawal before any conditional logic and validate the final amount against the calculated maximum."
    });
  }
  const hasReserveConfig = /reserve.*config|lending.*config|market.*config/i.test(content);
  const hasNoOwnershipCheck = !/owner.*==|has_one\s*=\s*owner|authority.*check/i.test(content);
  if (hasReserveConfig && hasNoOwnershipCheck) {
    findings.push({
      id: "SOL3978",
      title: "Solend Malicious Market Pattern - Unchecked Reserve Configuration",
      severity: "critical",
      description: "Lending market reserve configurations without proper ownership validation can allow malicious markets to be created and used to drain funds.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate ownership/authority for all reserve configuration changes. Implement allowlists for trusted markets."
    });
  }
  const hasApprove = /approve|delegation/i.test(content);
  const hasNoRevoke = !/revoke|revocation|clear_delegation/i.test(content);
  const hasTokenTransfer = /token.*transfer|transfer.*token|spl_token/i.test(content);
  if (hasApprove && hasTokenTransfer && hasNoRevoke) {
    findings.push({
      id: "SOL3979",
      title: "SPL Token Approve Without Revocation Path",
      severity: "medium",
      description: "Token approval patterns without corresponding revocation mechanism can leave users exposed to unlimited token drains if approved address is compromised.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement explicit token revocation functions and consider time-limited approvals."
    });
  }
  const hasSimulationCheck = /is_simulation|simulating|test_mode/i.test(content);
  const hasDifferentBehavior = /if.*simulation[\s\S]*?return|simulation.*\?.*:/i.test(content);
  if (hasSimulationCheck && hasDifferentBehavior) {
    findings.push({
      id: "SOL3980",
      title: "Simulation Detection May Cause Behavior Mismatch",
      severity: "high",
      description: "Programs that detect simulation mode and behave differently can be exploited. Attackers may bypass simulation-based security checks.",
      location: { file: filePath, line: 1 },
      recommendation: "Avoid different behavior paths based on simulation detection. Use consistent logic regardless of execution context."
    });
  }
  const hasBreakInLoop = /loop\s*\{[\s\S]*?break[\s\S]*?\}/i.test(content);
  const hasCalculationAfterBreak = /break[\s\S]*?amount|amount[\s\S]*?break/i.test(content);
  if (hasBreakInLoop && hasCalculationAfterBreak) {
    findings.push({
      id: "SOL3981",
      title: "Jet Protocol Break Bug - Premature Loop Exit",
      severity: "high",
      description: "Improper use of break statements in loops can cause premature exit before critical calculations are complete, potentially allowing over-borrowing or fund drainage.",
      location: { file: filePath, line: 1 },
      recommendation: "Ensure all critical calculations complete before loop exit. Use explicit state tracking instead of break for complex logic."
    });
  }
  const hasRounding = /round|\.div\(|\/\s*\d/i.test(content);
  const hasNoDirectionControl = !/floor|ceil|round_down|round_up/i.test(content);
  const hasMonetaryCalc = /amount|balance|deposit|withdraw|borrow|repay/i.test(content);
  if (hasRounding && hasNoDirectionControl && hasMonetaryCalc) {
    findings.push({
      id: "SOL3982",
      title: "Neodyme Rounding Attack - Uncontrolled Rounding Direction",
      severity: "critical",
      description: "Monetary calculations with rounding but without explicit direction (floor vs ceil) can accumulate to significant losses. The $2.6B Neodyme disclosure showed how innocent-looking rounding can be exploited.",
      location: { file: filePath, line: 1 },
      recommendation: "Use floor() when user is receiving value, ceil() when protocol is receiving value. Never use default rounding for monetary calculations."
    });
  }
  const hasGuardianSig = /guardian|signature.*set|verify.*signature/i.test(content);
  const hasNoVerifiedCheck = !/verified|is_valid|signature_valid/i.test(content);
  if (hasGuardianSig && hasNoVerifiedCheck) {
    findings.push({
      id: "SOL3983",
      title: "Wormhole-Style Guardian Verification Bypass",
      severity: "critical",
      description: "Guardian signature verification that delegates to other accounts without proper verification chain can be bypassed, as seen in the $320M Wormhole exploit.",
      location: { file: filePath, line: 1 },
      recommendation: "Always verify signature sets completely. Validate entire verification chain. Never trust delegated verification without explicit validation."
    });
  }
  const hasCollateral = /collateral|backing|reserve/i.test(content);
  const hasMinting = /mint|create_token/i.test(content);
  const hasNoTrustValidation = !/trusted|verified|allowlist/i.test(content);
  if (hasCollateral && hasMinting && hasNoTrustValidation) {
    findings.push({
      id: "SOL3984",
      title: "Cashio Root of Trust Missing - Collateral Validation",
      severity: "critical",
      description: "Minting backed by collateral without establishing a root of trust can allow attackers to provide fake collateral and mint unbacked tokens, as in the $52M Cashio exploit.",
      location: { file: filePath, line: 1 },
      recommendation: "Establish clear root of trust for all collateral. Validate token mints against trusted registries. Implement allowlists for acceptable collateral."
    });
  }
  const hasStakePool = /stake.*pool|staking.*pool/i.test(content);
  const hasUpdateAndWithdraw = /update[\s\S]*?withdraw|withdraw[\s\S]*?update/i.test(content);
  if (hasStakePool && hasUpdateAndWithdraw) {
    findings.push({
      id: "SOL3985",
      title: "Stake Pool Semantic Inconsistency Pattern",
      severity: "high",
      description: "Stake pool operations with update and withdraw logic may have semantic inconsistencies where state updates dont reflect actual values correctly.",
      location: { file: filePath, line: 1 },
      recommendation: "Ensure atomic consistency between stake pool state updates and actual stake values. Add invariant checks after each operation."
    });
  }
  const hasStateEnum = /enum\s+\w+State|State\s*\{/i.test(content);
  const hasStateTransition = /state\s*=\s*\w+State::|\.state\s*=/i.test(content);
  const hasNoStateValidation = !/match\s+.*state|if.*state\s*==/i.test(content);
  if (hasStateEnum && hasStateTransition && hasNoStateValidation) {
    findings.push({
      id: "SOL3986",
      title: "Sec3 Business Logic - State Machine Violation",
      severity: "high",
      description: "State transitions without validation allow skipping required states. Business logic vulnerabilities account for 38.5% of audit findings per Sec3 2025 report.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement explicit state machine with validated transitions. Use require! or constraint checks before each state change."
    });
  }
  const hasByteSlice = /\[u8\]|&\[u8\]|Vec<u8>/i.test(content);
  const hasNoLengthCheck = !/\.len\(\)|length|size.*check/i.test(content);
  const hasDeserialize = /deserialize|try_from_slice|unpack/i.test(content);
  if (hasByteSlice && hasDeserialize && hasNoLengthCheck) {
    findings.push({
      id: "SOL3987",
      title: "Sec3 Input Validation - Untrusted Data Length",
      severity: "high",
      description: "Deserialization without length validation can cause panics or buffer overflows. Input validation issues are 25% of audit findings per Sec3 2025.",
      location: { file: filePath, line: 1 },
      recommendation: "Always validate input length before deserialization. Use try_from_slice with explicit bounds checking."
    });
  }
  const hasCpi = /invoke|invoke_signed|CpiContext/i.test(content);
  const hasNoProgramCheck = !/key\(\)\s*==|program_id.*==|owner.*==.*program/i.test(content);
  if (hasCpi && hasNoProgramCheck) {
    findings.push({
      id: "SOL3988",
      title: "Sec3 Access Control - Missing CPI Program Verification",
      severity: "critical",
      description: "Cross-program invocations without verifying the target program ID can allow arbitrary program execution. Access control issues are 19% of audit findings.",
      location: { file: filePath, line: 1 },
      recommendation: "Always verify program IDs before CPI. Use Anchor program attribute or explicit key comparison."
    });
  }
  const hasCriticalMath = /(amount|balance|deposit|withdraw|stake).*[\+\-\*\/]/i.test(content);
  const hasNoCheckedMath = !/checked_add|checked_sub|checked_mul|checked_div|saturating/i.test(content);
  if (hasCriticalMath && hasNoCheckedMath) {
    findings.push({
      id: "SOL3989",
      title: "Sec3 Data Integrity - Critical Path Arithmetic Unchecked",
      severity: "high",
      description: "Financial calculations without checked arithmetic can overflow/underflow. Data integrity issues are 8.9% of findings but often critical severity.",
      location: { file: filePath, line: 1 },
      recommendation: "Use checked_* or saturating_* methods for all financial arithmetic. Enable overflow-checks in release builds."
    });
  }
  const hasLoop = /for\s+\w+\s+in|while|loop\s*\{/i.test(content);
  const hasUserInput = /remaining_accounts|accounts\.len\(\)|instruction_data/i.test(content);
  const hasNoLimit = !/max|limit|MAX_|LIMIT_/i.test(content);
  if (hasLoop && hasUserInput && hasNoLimit) {
    findings.push({
      id: "SOL3990",
      title: "Sec3 DoS - Unbounded Iteration on User Input",
      severity: "medium",
      description: "Loops over user-controlled data without limits can exhaust compute budget. DoS/liveness issues are 8.5% of audit findings.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement maximum iteration limits. Use pagination for large datasets. Consider compute budget reservation."
    });
  }
  const hasAccountInfo = /AccountInfo|Account<.*>|UncheckedAccount/i.test(content);
  const hasNoOwnerCheck = !/owner\s*==|has_one.*owner|\.owner|check_owner/i.test(content);
  const hasDataAccess = /data\.borrow|try_borrow_data|data_as/i.test(content);
  if (hasAccountInfo && hasDataAccess && hasNoOwnerCheck) {
    findings.push({
      id: "SOL3991",
      title: "Kudelski Audit Finding - Missing Owner Check on Data Access",
      severity: "critical",
      description: "Accessing account data without verifying account owner allows attackers to pass malicious accounts with crafted data.",
      location: { file: filePath, line: 1 },
      recommendation: "Always verify account owner before accessing data. Use Anchor #[account] with has_one constraint."
    });
  }
  const hasStakeWithdraw = /withdraw_stake|unstake|stake.*withdraw/i.test(content);
  const hasEpochCheck = /epoch|Clock::get/i.test(content);
  const hasNoDeactivationCheck = !/deactivation_epoch|is_deactivated/i.test(content);
  if (hasStakeWithdraw && hasEpochCheck && hasNoDeactivationCheck) {
    findings.push({
      id: "SOL3992",
      title: "Bramah Audit - Stake Withdrawal Deactivation Race",
      severity: "high",
      description: "Stake withdrawal without checking deactivation epoch can allow withdrawal of stakes that should still be locked.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify stake deactivation epoch before allowing withdrawals. Implement proper stake lifecycle management."
    });
  }
  const hasLpToken = /lp_token|pool_token|share_token/i.test(content);
  const hasPriceCalc = /price|value|worth|amount.*\//i.test(content);
  const hasNoTwap = !/twap|time_weighted|moving_average/i.test(content);
  if (hasLpToken && hasPriceCalc && hasNoTwap) {
    findings.push({
      id: "SOL3993",
      title: "OtterSec Finding - LP Token Price Manipulation",
      severity: "critical",
      description: "LP token pricing without TWAP allows flash loan manipulation of prices for collateral attacks, as detailed in OtterSec $200M oracle manipulation report.",
      location: { file: filePath, line: 1 },
      recommendation: "Use fair LP pricing formulas. Implement TWAP for price feeds. Add manipulation resistance checks."
    });
  }
  const hasRemainingAccounts = /remaining_accounts|ctx\.remaining/i.test(content);
  const hasNoRemainingValidation = !/remaining.*\.len\(\)|remaining.*is_empty|validate.*remaining/i.test(content);
  if (hasRemainingAccounts && hasNoRemainingValidation) {
    findings.push({
      id: "SOL3994",
      title: "Zellic Finding - Unchecked Remaining Accounts",
      severity: "high",
      description: "Using remaining_accounts without validation can allow attackers to inject malicious accounts into processing logic.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate all remaining accounts for expected types, ownership, and constraints before use."
    });
  }
  const hasInvariant = /assert|require|invariant/i.test(content);
  const hasStateChange = /ctx\.accounts\.\w+\.\w+\s*=/i.test(content);
  const hasNoPostCheck = !/(assert|require|check)[\s\S]{0,50}(after|post|final)/i.test(content);
  if (hasStateChange && hasInvariant && hasNoPostCheck) {
    findings.push({
      id: "SOL3995",
      title: "Missing Post-State Invariant Checks",
      severity: "medium",
      description: "State modifications without post-condition invariant checks can leave protocol in inconsistent state.",
      location: { file: filePath, line: 1 },
      recommendation: "Add invariant checks after state modifications. Verify expected state holds after each operation."
    });
  }
  const hasAccountMut = /#\[account\(mut\)\]|mut\s+\w+:\s*Account/i.test(content);
  const hasNoSignerCheck = !/#\[account\(.*signer.*\)\]|is_signer|Signer<.*>/i.test(content);
  const hasAuthAction = /transfer|withdraw|update|modify/i.test(content);
  if (hasAccountMut && hasAuthAction && hasNoSignerCheck) {
    findings.push({
      id: "SOL3996",
      title: "Armani Sealevel - Missing Signer on Mutable Account",
      severity: "critical",
      description: "Mutable accounts without signer requirement allow anyone to modify account state. Classic Sealevel attack.",
      location: { file: filePath, line: 1 },
      recommendation: "Require signer for all accounts that perform privileged operations. Use #[account(signer)] or Signer type."
    });
  }
  const hasRewards = /reward|emission|distribute/i.test(content);
  const hasTimestamp = /timestamp|unix_timestamp|Clock::get/i.test(content);
  const hasNoRewardPeriodCheck = !/reward_period|last_reward|reward_interval/i.test(content);
  if (hasRewards && hasTimestamp && hasNoRewardPeriodCheck) {
    findings.push({
      id: "SOL3997",
      title: "Quantstamp Finding - Reward Distribution Timing Attack",
      severity: "high",
      description: "Reward distribution based on timestamps without period tracking can allow rapid claim attacks or reward gaming.",
      location: { file: filePath, line: 1 },
      recommendation: "Track last reward time per user. Implement minimum reward periods. Use accumulator patterns."
    });
  }
  const hasSwap = /swap|exchange|trade/i.test(content);
  const hasSlippage = /slippage|minimum_out|min_amount/i.test(content);
  const hasNoSlippageEnforcement = !/require.*min|assert.*>=.*min|check.*slippage/i.test(content);
  if (hasSwap && hasSlippage && hasNoSlippageEnforcement) {
    findings.push({
      id: "SOL3998",
      title: "Halborn Finding - Slippage Protection Bypass",
      severity: "high",
      description: "Slippage parameters that arent enforced allow MEV extraction and sandwich attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Enforce slippage limits with require! or assert!. Validate output amount meets minimum after swap execution."
    });
  }
  const hasYield = /yield|harvest|compound|auto.*stake/i.test(content);
  const hasCpiCall = /invoke|invoke_signed|CpiContext/i.test(content);
  const hasNoReentrancyGuard = !/reentrancy|lock|is_processing|in_progress/i.test(content);
  if (hasYield && hasCpiCall && hasNoReentrancyGuard) {
    findings.push({
      id: "SOL3999",
      title: "Certik Finding - Yield Aggregator CPI Reentrancy",
      severity: "high",
      description: "Yield operations with external CPI calls without reentrancy protection can be exploited for multiple harvests or state manipulation.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement reentrancy guards. Use checks-effects-interactions pattern. Lock state during external calls."
    });
  }
  const hasBankOrSlot = /bank|slot|recent_blockhash/i.test(content);
  const hasSimMode = /simulation|test_mode|dry_run/i.test(content);
  if (hasBankOrSlot && hasSimMode) {
    findings.push({
      id: "SOL4000",
      title: "Opcodes Finding - Bank Module Simulation Detection Exploit",
      severity: "high",
      description: "Using bank/slot data to detect simulation mode creates exploitable behavior differences between simulation and execution.",
      location: { file: filePath, line: 1 },
      recommendation: "Do not change behavior based on simulation detection. If needed for testing, use feature flags compiled out in release."
    });
  }
  const hasPriceBand = /price.*band|min.*price.*max|price_range/i.test(content);
  const hasOraclePrice = /oracle.*price|price.*oracle|pyth|switchboard/i.test(content);
  if (hasPriceBand && hasOraclePrice) {
    const hasNoDeviation = !/deviation|diff.*percent|within.*range/i.test(content);
    if (hasNoDeviation) {
      findings.push({
        id: "SOL4001",
        title: "Mango Markets Pattern - Missing Price Deviation Check",
        severity: "high",
        description: "Price bands without deviation checks from oracle can be manipulated outside acceptable ranges.",
        location: { file: filePath, line: 1 },
        recommendation: "Check price deviation from oracle before accepting. Implement circuit breakers for extreme deviations."
      });
    }
  }
  const hasShareCalc = /share|proportion|ratio.*stake/i.test(content);
  const hasTotalSupply = /total_supply|total_staked|pool_total/i.test(content);
  if (hasShareCalc && hasTotalSupply) {
    const hasDivisionByZero = /\/\s*(total|supply|pool)/i.test(content);
    const hasNoZeroCheck = !/if.*==.*0|\.is_zero\(\)|> 0/i.test(content);
    if (hasDivisionByZero && hasNoZeroCheck) {
      findings.push({
        id: "SOL4002",
        title: "Marinade Pattern - Share Calculation Division by Zero",
        severity: "high",
        description: "Share calculations dividing by total supply without zero check can cause panics or first-depositor attacks.",
        location: { file: filePath, line: 1 },
        recommendation: "Check for zero total supply before division. Handle first deposit case explicitly with 1:1 ratio."
      });
    }
  }
  const hasOrderBook = /order.*book|bid|ask|order_queue/i.test(content);
  const hasPartialFill = /partial.*fill|remaining|filled_amount/i.test(content);
  if (hasOrderBook && hasPartialFill) {
    findings.push({
      id: "SOL4003",
      title: "Phoenix DEX Pattern - Order Book State Consistency",
      severity: "medium",
      description: "Order book with partial fills must maintain consistency between order state and book state to prevent ghost orders or double fills.",
      location: { file: filePath, line: 1 },
      recommendation: "Atomically update order and book state. Verify consistency after each fill operation."
    });
  }
  const hasFundingRate = /funding.*rate|perpetual|perp/i.test(content);
  const hasMarkPrice = /mark.*price|index.*price/i.test(content);
  if (hasFundingRate && hasMarkPrice) {
    const hasNoCapOrFloor = !/max.*funding|min.*funding|cap.*rate|floor.*rate/i.test(content);
    if (hasNoCapOrFloor) {
      findings.push({
        id: "SOL4004",
        title: "Drift Pattern - Uncapped Funding Rate",
        severity: "high",
        description: "Funding rates without caps can be manipulated to extreme values, draining positions.",
        location: { file: filePath, line: 1 },
        recommendation: "Implement funding rate caps and floors. Use TWAP for mark price to resist manipulation."
      });
    }
  }
  const hasTickCrossing = /tick.*cross|cross.*tick|tick_array/i.test(content);
  const hasSqrtPrice = /sqrt.*price|price.*sqrt|Q64/i.test(content);
  if (hasTickCrossing && hasSqrtPrice) {
    findings.push({
      id: "SOL4005",
      title: "Orca Whirlpools Pattern - Tick Crossing Precision",
      severity: "medium",
      description: "Concentrated liquidity tick crossing must maintain precision in sqrt price calculations to prevent fee extraction attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Use fixed-point math with sufficient precision (Q64.64). Validate tick boundaries after each crossing."
    });
  }
  const hasAgentWallet = /agent|bot|automated/i.test(content);
  const hasPrivateKeyAccess = /private_key|secret_key|keypair|signer/i.test(content);
  if (hasAgentWallet && hasPrivateKeyAccess) {
    findings.push({
      id: "SOL4006",
      title: "2026 Pattern - AI Agent Wallet Security",
      severity: "high",
      description: "AI agents with private key access are high-value targets. Compromised agent code or dependencies can drain wallets.",
      location: { file: filePath, line: 1 },
      recommendation: "Use hardware wallets or MPC for agent signing. Implement spending limits and transaction allowlists."
    });
  }
  const hasCnft = /compressed|merkle.*tree|concurrent_merkle/i.test(content);
  const hasProof = /proof|canopy|leaf/i.test(content);
  if (hasCnft && hasProof) {
    const hasNoRootCheck = !/verify.*root|root.*match|compare.*root/i.test(content);
    if (hasNoRootCheck) {
      findings.push({
        id: "SOL4007",
        title: "2025 Pattern - cNFT Merkle Proof Manipulation",
        severity: "critical",
        description: "Compressed NFT operations without proper merkle root verification can allow proof forgery.",
        location: { file: filePath, line: 1 },
        recommendation: "Always verify merkle proofs against on-chain tree root. Use Bubblegum/Gummyroll libraries correctly."
      });
    }
  }
  const hasTransferHook = /transfer_hook|hook.*transfer|extension/i.test(content);
  const hasCallback = /callback|on_transfer|execute_hook/i.test(content);
  if (hasTransferHook && hasCallback) {
    findings.push({
      id: "SOL4008",
      title: "Token 2022 - Transfer Hook Reentrancy Vector",
      severity: "high",
      description: "Token-2022 transfer hooks execute during transfers, creating reentrancy opportunities.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement reentrancy guards in transfer hooks. Complete state changes before hook execution."
    });
  }
  const hasConfidentialTransfer = /confidential|zero_knowledge|zk_proof/i.test(content);
  const hasElgamal = /elgamal|ciphertext|decrypt/i.test(content);
  if (hasConfidentialTransfer || hasElgamal) {
    findings.push({
      id: "SOL4009",
      title: "Token 2022 - Confidential Transfer Proof Security",
      severity: "high",
      description: "Confidential transfers require rigorous zero-knowledge proof verification. Weak verification allows balance forgery.",
      location: { file: filePath, line: 1 },
      recommendation: "Use audited ZK libraries. Verify all proof components. Never skip verification in any code path."
    });
  }
  const hasBlink = /blink|action.*url|solana.*action/i.test(content);
  const hasUrlParsing = /url|parse.*action|fetch.*action/i.test(content);
  if (hasBlink && hasUrlParsing) {
    findings.push({
      id: "SOL4010",
      title: "2024 Pattern - Blinks Action Injection",
      severity: "high",
      description: "Solana Blinks/Actions that parse URLs without validation can be exploited to inject malicious transactions.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate action URLs against allowlists. Verify transaction contents before signing. Show clear transaction previews."
    });
  }
  const hasInitialize = /initialize|init/i.test(content);
  const hasPoolCreation = /create.*pool|new.*pool|pool.*init/i.test(content);
  if (hasInitialize && hasPoolCreation) {
    const hasNoAtomicCheck = !/same_transaction|atomic|single_tx/i.test(content);
    if (hasNoAtomicCheck) {
      findings.push({
        id: "SOL4011",
        title: "Flash Loan Sandwich on Pool Initialize",
        severity: "high",
        description: "Pool initialization without atomic protection can be sandwiched with flash loans to extract initial liquidity value.",
        location: { file: filePath, line: 1 },
        recommendation: "Make pool initialization atomic with initial deposit. Add dead shares or minimum lock periods."
      });
    }
  }
  const hasVaultShares = /vault.*share|share.*token|receipt.*token/i.test(content);
  const hasDeposit = /deposit|stake/i.test(content);
  if (hasVaultShares && hasDeposit) {
    findings.push({
      id: "SOL4012",
      title: "Vault Share Inflation Attack Vector",
      severity: "high",
      description: "First depositor to empty vault can inflate share price by donating assets, extracting value from subsequent depositors.",
      location: { file: filePath, line: 1 },
      recommendation: "Mint dead shares on vault creation. Use virtual offset in share calculations. Implement minimum deposit amounts."
    });
  }
  const hasGovernance = /governance|voting|proposal/i.test(content);
  const hasVotingPower = /voting_power|vote_weight|balance.*vote/i.test(content);
  if (hasGovernance && hasVotingPower) {
    const hasNoTimelock = !/timelock|lock_period|voting_escrow/i.test(content);
    if (hasNoTimelock) {
      findings.push({
        id: "SOL4013",
        title: "Governance Flash Loan Voting Attack",
        severity: "high",
        description: "Governance based on current token balance without lockup can be exploited with flash loans to pass malicious proposals.",
        location: { file: filePath, line: 1 },
        recommendation: "Implement vote escrow (veToken) model. Snapshot voting power at proposal creation. Add timelock for execution."
      });
    }
  }
  const hasJito = /jito|bundle|tip/i.test(content);
  const hasOrderingSensitive = /first|priority|sequence/i.test(content);
  if (hasJito || hasOrderingSensitive) {
    findings.push({
      id: "SOL4014",
      title: "Jito Bundle MEV Ordering Sensitivity",
      severity: "medium",
      description: "Programs sensitive to transaction ordering within blocks are vulnerable to Jito bundle-based MEV extraction.",
      location: { file: filePath, line: 1 },
      recommendation: "Design order-independent logic where possible. Use commit-reveal for order-sensitive operations."
    });
  }
  const hasCrossMargin = /cross_margin|portfolio_margin|unified_margin/i.test(content);
  const hasLiquidation = /liquidat|underwater|bad_debt/i.test(content);
  if (hasCrossMargin && hasLiquidation) {
    findings.push({
      id: "SOL4015",
      title: "Cross-Margin Liquidation Cascade Risk",
      severity: "high",
      description: "Cross-margin systems can experience cascade liquidations where one position triggers chain reaction affecting healthy positions.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement position isolation options. Add circuit breakers for cascade detection. Use gradual liquidation with incentives."
    });
  }
  const hasUpgradeAuthority = /upgrade.*authority|program.*authority|bpf_upgradeable/i.test(content);
  if (hasUpgradeAuthority) {
    const hasNoMultisig = !/multisig|multi_sig|threshold/i.test(content);
    if (hasNoMultisig) {
      findings.push({
        id: "SOL4016",
        title: "Centralized Upgrade Authority Risk",
        severity: "high",
        description: "Single upgrade authority creates single point of failure. Key compromise allows complete protocol takeover.",
        location: { file: filePath, line: 1 },
        recommendation: "Use multisig for upgrade authority. Implement timelock for upgrades. Consider immutable deployment for mature protocols."
      });
    }
  }
  const hasLookupTable = /lookup_table|address_lookup|lut/i.test(content);
  const hasTableExtend = /extend|append|add.*address/i.test(content);
  if (hasLookupTable && hasTableExtend) {
    findings.push({
      id: "SOL4017",
      title: "Address Lookup Table Poisoning",
      severity: "high",
      description: "Lookup tables that can be extended by untrusted parties can be poisoned with malicious program addresses.",
      location: { file: filePath, line: 1 },
      recommendation: "Freeze lookup tables after initialization. Use authority-controlled extension. Verify table contents on-chain."
    });
  }
  const hasDurableNonce = /durable.*nonce|nonce_account|advance_nonce/i.test(content);
  if (hasDurableNonce) {
    findings.push({
      id: "SOL4018",
      title: "Durable Nonce Transaction Replay Risk",
      severity: "medium",
      description: "Durable nonce transactions remain valid until used. Exposed signed transactions can be replayed at unfavorable times.",
      location: { file: filePath, line: 1 },
      recommendation: "Minimize transaction exposure time. Use short-lived nonces where possible. Implement application-level replay protection."
    });
  }
  const hasComputeBudget = /compute.*budget|request_units|set_compute/i.test(content);
  const hasLoops = /for|while|loop/i.test(content);
  if (hasComputeBudget && hasLoops) {
    findings.push({
      id: "SOL4019",
      title: "Compute Budget Griefing Attack",
      severity: "medium",
      description: "Attackers can craft inputs that maximize compute consumption while minimizing cost, griefing other users.",
      location: { file: filePath, line: 1 },
      recommendation: "Charge fees proportional to compute used. Implement operation cost estimates. Add per-user rate limits."
    });
  }
  const hasPriorityFee = /priority.*fee|tip|compute_unit_price/i.test(content);
  const hasTimeSensitive = /deadline|expire|timeout/i.test(content);
  if (hasPriorityFee && hasTimeSensitive) {
    findings.push({
      id: "SOL4020",
      title: "Priority Fee Auction Timing Attack",
      severity: "medium",
      description: "Time-sensitive operations with priority fee auctions can be exploited by delaying inclusion until deadline approaches.",
      location: { file: filePath, line: 1 },
      recommendation: "Design for worst-case inclusion times. Implement fallback mechanisms. Consider keeper incentive structures."
    });
  }
  const hasWebsocket = /websocket|subscribe|on_account_change/i.test(content);
  const hasStateTracking = /state|balance|position/i.test(content);
  if (hasWebsocket && hasStateTracking) {
    findings.push({
      id: "SOL4021",
      title: "WebSocket State Desynchronization",
      severity: "medium",
      description: "Client state tracking via WebSocket can desync during network issues, leading to stale data decisions.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement heartbeat/reconnection logic. Verify state with RPC before critical operations. Track subscription health."
    });
  }
  const hasRpcCall = /get_account|get_balance|send_transaction/i.test(content);
  const hasNoValidation = !/verify|validate|confirm/i.test(content);
  if (hasRpcCall && hasNoValidation) {
    findings.push({
      id: "SOL4022",
      title: "RPC Node Trust Assumption Risk",
      severity: "medium",
      description: "Blindly trusting RPC responses without validation exposes to malicious or buggy RPC nodes returning false data.",
      location: { file: filePath, line: 1 },
      recommendation: "Use multiple RPC nodes for critical data. Implement response validation. Consider light client verification where possible."
    });
  }
  const hasAutomation = /clockwork|crank|keeper|trigger/i.test(content);
  const hasCondition = /condition|when|if.*then/i.test(content);
  if (hasAutomation && hasCondition) {
    findings.push({
      id: "SOL4023",
      title: "Automation Trigger Condition Abuse",
      severity: "medium",
      description: "Automated triggers (Clockwork, keepers) can be exploited if trigger conditions can be artificially created.",
      location: { file: filePath, line: 1 },
      recommendation: "Make trigger conditions costly to fake. Add rate limits on automated actions. Implement keeper incentive alignment."
    });
  }
  const hasRentExempt = /rent_exempt|minimum_balance|rent/i.test(content);
  const hasAccountClose = /close|delete.*account/i.test(content);
  if (hasRentExempt && hasAccountClose) {
    findings.push({
      id: "SOL4024",
      title: "Rent Exemption Edge Case on Close",
      severity: "low",
      description: "Accounts closed at exact rent-exempt threshold may behave unexpectedly in edge cases.",
      location: { file: filePath, line: 1 },
      recommendation: "Always drain to zero when closing. Verify rent exemption before critical operations."
    });
  }
  const hasVersionedTx = /versioned|v0|transaction.*version/i.test(content);
  const hasLegacy = /legacy|v0.*false/i.test(content);
  if (hasVersionedTx || hasLegacy) {
    findings.push({
      id: "SOL4025",
      title: "Versioned Transaction Compatibility Issue",
      severity: "low",
      description: "Mixed versioned and legacy transaction handling can cause wallet compatibility issues and failed transactions.",
      location: { file: filePath, line: 1 },
      recommendation: "Document transaction version requirements. Handle both versions gracefully. Test with major wallets."
    });
  }
  return findings;
}

// src/patterns/solana-batched-patterns-80.ts
function checkBatch80Patterns(parsed, filePath) {
  const findings = [];
  const content = parsed.content;
  const lines = content.split("\n");
  const hasVerifySignatures = /verify.*signature|signature.*verify/i.test(content);
  const hasDelegation = /delegate|call_signed|invoke.*signed/i.test(content);
  if (hasVerifySignatures && hasDelegation) {
    findings.push({
      id: "SOL4026",
      title: "Wormhole Pattern - Signature Verification Delegation Chain",
      severity: "critical",
      description: "$320M Wormhole exploit: verify_signatures used deprecated Sysvar API allowing delegation bypass. Always verify complete signature chain.",
      location: { file: filePath, line: 1 },
      recommendation: "Use current secp256k1 instruction for verification. Never trust delegated verification without complete chain validation."
    });
  }
  const hasBankAccount = /bank|collateral_bank|backing_bank/i.test(content);
  const hasMintOperation = /mint_to|mint.*token/i.test(content);
  if (hasBankAccount && hasMintOperation) {
    const hasNoAccountValidation = !/validate.*bank|bank.*owner|trusted.*bank/i.test(content);
    if (hasNoAccountValidation) {
      findings.push({
        id: "SOL4027",
        title: "Cashio Pattern - Fake Bank Infinite Mint",
        severity: "critical",
        description: "$52M Cashio exploit: attacker provided fake bank account to mint unlimited tokens. Validate all collateral account authenticity.",
        location: { file: filePath, line: 1 },
        recommendation: "Validate bank/collateral accounts against known mints. Use PDA derivation for trusted accounts. Implement allowlists."
      });
    }
  }
  const hasOracleManipulation = /oracle|price_feed|pyth|switchboard/i.test(content);
  const hasBorrowOrLeverage = /borrow|leverage|collateral_ratio/i.test(content);
  if (hasOracleManipulation && hasBorrowOrLeverage) {
    const hasNoCircuitBreaker = !/circuit_breaker|max_deviation|price_limit/i.test(content);
    if (hasNoCircuitBreaker) {
      findings.push({
        id: "SOL4028",
        title: "Mango Markets Pattern - Oracle Price Manipulation",
        severity: "critical",
        description: "$114M Mango exploit: Attacker manipulated illiquid token price via spot market to inflate collateral value and drain protocol.",
        location: { file: filePath, line: 1 },
        recommendation: "Implement oracle deviation limits. Use TWAP not spot price. Add per-market borrow caps. Verify liquidity depth."
      });
    }
  }
  const hasTickAccount = /tick|tick_array|position_tick/i.test(content);
  const hasLiquidityCalc = /liquidity|sqrt_price|amount.*token/i.test(content);
  if (hasTickAccount && hasLiquidityCalc) {
    const hasNoTickValidation = !/validate.*tick|tick.*owner|check.*tick/i.test(content);
    if (hasNoTickValidation) {
      findings.push({
        id: "SOL4029",
        title: "Crema Finance Pattern - Tick Account Spoofing",
        severity: "critical",
        description: "$8.78M Crema exploit: Flash loaned to create fake tick accounts with inflated fee values for bogus fee claims.",
        location: { file: filePath, line: 1 },
        recommendation: "Validate tick account ownership and derivation. Verify tick accounts are created through proper protocol flow."
      });
    }
  }
  const hasKeyLogging = /log|debug|console|telemetry/i.test(content);
  const hasPrivateKey = /private_key|secret_key|seed_phrase|mnemonic/i.test(content);
  if (hasKeyLogging && hasPrivateKey) {
    findings.push({
      id: "SOL4030",
      title: "Slope Wallet Pattern - Private Key Logging",
      severity: "critical",
      description: "$8M Slope exploit: Wallet logged seed phrases in plaintext to centralized server. Never log sensitive key material.",
      location: { file: filePath, line: 1 },
      recommendation: "Never log private keys, seeds, or mnemonics. Use secure enclaves. Audit all logging paths. Sanitize debug output."
    });
  }
  const hasAdminAccess = /admin|owner|authority/i.test(content);
  const hasTreasuryAccess = /treasury|vault|withdraw_all/i.test(content);
  if (hasAdminAccess && hasTreasuryAccess) {
    const hasNoTimelock2 = !/timelock|delay|multi_sig/i.test(content);
    if (hasNoTimelock2) {
      findings.push({
        id: "SOL4031",
        title: "Cypher Protocol Pattern - Insider Treasury Access",
        severity: "high",
        description: "$1.04M Cypher exploit: Rogue developer accessed treasury keys. Implement timelocks and multisig for admin actions.",
        location: { file: filePath, line: 1 },
        recommendation: "Use multisig for all admin operations. Implement timelock on treasury withdrawals. Separate hot/cold key management."
      });
    }
  }
  const hasCloseAccount = /close|close_account|delete_account/i.test(content);
  const hasTvlAtRisk = /tvl|total_value|locked|staked/i.test(content);
  if (hasCloseAccount && hasTvlAtRisk) {
    const hasNoCloseCheck = !/can_close|is_empty|balance.*==.*0/i.test(content);
    if (hasNoCloseCheck) {
      findings.push({
        id: "SOL4032",
        title: "OptiFi Pattern - Unchecked Account Close",
        severity: "critical",
        description: "$661K OptiFi lockup: Account closed while containing user funds. Always verify accounts are empty before closing.",
        location: { file: filePath, line: 1 },
        recommendation: "Verify zero balance before close. Implement recovery mechanisms. Use drain-then-close pattern."
      });
    }
  }
  const hasGovernanceProposal = /proposal|governance|vote/i.test(content);
  const hasQuorum = /quorum|threshold|minimum_votes/i.test(content);
  if (hasGovernanceProposal && hasQuorum) {
    const hasNoReviewPeriod = !/review_period|voting_period|delay/i.test(content);
    if (hasNoReviewPeriod) {
      findings.push({
        id: "SOL4033",
        title: "Synthetify DAO Pattern - Rushed Proposal Attack",
        severity: "high",
        description: "$230K Synthetify: Malicious proposal executed before community review. Implement mandatory review periods.",
        location: { file: filePath, line: 1 },
        recommendation: "Enforce minimum review period (24-72h). Implement proposal visibility requirements. Add grace period for execution."
      });
    }
  }
  const hasBondingCurve = /bonding_curve|curve|price.*formula/i.test(content);
  const hasFlashLoan = /flash.*loan|borrow.*repay/i.test(content);
  if (hasBondingCurve && hasFlashLoan) {
    findings.push({
      id: "SOL4034",
      title: "Nirvana Finance Pattern - Bonding Curve Flash Loan Attack",
      severity: "critical",
      description: "$3.49M Nirvana exploit: Flash loan used to drain bonding curve by exploiting price formula. Implement flash loan guards.",
      location: { file: filePath, line: 1 },
      recommendation: "Add same-block swap limits. Implement anti-flash-loan checks. Use TWAP for curve pricing."
    });
  }
  const hasReserve = /reserve|lending_market|pool/i.test(content);
  const hasConfig = /config|parameter|setting/i.test(content);
  if (hasReserve && hasConfig) {
    const hasNoConfigValidation = !/validate.*config|check.*config|config.*range/i.test(content);
    if (hasNoConfigValidation) {
      findings.push({
        id: "SOL4035",
        title: "Solend Pattern - Malicious Reserve Configuration",
        severity: "high",
        description: "Solend incident: Malicious actors could create lending markets with harmful parameters. Validate all configuration values.",
        location: { file: filePath, line: 1 },
        recommendation: "Implement configuration value ranges. Require governance approval for new markets. Use allowlists for supported assets."
      });
    }
  }
  const hasVaultStrategy = /strategy|vault|yield/i.test(content);
  const hasExternalProtocol = /cpi|invoke|external/i.test(content);
  if (hasVaultStrategy && hasExternalProtocol) {
    findings.push({
      id: "SOL4036",
      title: "Tulip Protocol Pattern - Vault Strategy Manipulation",
      severity: "high",
      description: "Yield vault strategies interacting with external protocols are vulnerable to composability exploits.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate external protocol states. Implement slippage protection for all external calls. Add strategy timeout checks."
    });
  }
  const hasFrontend = /frontend|url|domain/i.test(content);
  const hasSigningRequest = /sign|approve|transaction/i.test(content);
  if (hasFrontend || hasSigningRequest) {
    findings.push({
      id: "SOL4037",
      title: "Parcl Pattern - Frontend Compromise Risk",
      severity: "high",
      description: "Parcl frontend compromised to serve malicious transaction requests. Implement content security and verification.",
      location: { file: filePath, line: 1 },
      recommendation: "Use CSP headers. Implement transaction simulation display. Sign and verify frontend assets. Use multiple mirrors."
    });
  }
  const hasAdminKey = /admin|owner_authority|upgrade_authority/i.test(content);
  const hasProtocolControl = /pool|vault|treasury/i.test(content);
  if (hasAdminKey && hasProtocolControl) {
    findings.push({
      id: "SOL4038",
      title: "Raydium Pattern - Admin Key Compromise Impact",
      severity: "critical",
      description: "Raydium admin key compromise led to pool draining. Minimize admin powers. Implement timelocks.",
      location: { file: filePath, line: 1 },
      recommendation: "Use multisig for admin keys. Implement timelocks on critical actions. Separate operational keys from upgrade keys."
    });
  }
  const hasWrappedToken = /wrapped|synthetic|receipt/i.test(content);
  const hasAccounting = /balance|total_supply|mint.*burn/i.test(content);
  if (hasWrappedToken && hasAccounting) {
    findings.push({
      id: "SOL4039",
      title: "Saber Pattern - Wrapped Token Accounting Mismatch",
      severity: "high",
      description: "Wrapped token protocols must maintain 1:1 backing. Accounting errors can cause insolvency.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement invariant checks on every mint/burn. Use separate accounting for wrapped vs underlying. Add proof of reserves."
    });
  }
  const hasDeltaNeutral = /delta|hedge|perpetual|derivative/i.test(content);
  const hasRebalancing = /rebalance|adjust|maintain/i.test(content);
  if (hasDeltaNeutral && hasRebalancing) {
    findings.push({
      id: "SOL4040",
      title: "UXD Pattern - Delta Neutral Hedging Exposure",
      severity: "high",
      description: "Delta neutral strategies can fail during extreme market conditions. UXD faced depeg risk during Mango exploit.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement circuit breakers for extreme volatility. Diversify hedging counterparties. Add insurance fund buffer."
    });
  }
  const hasKeyStorage = /store.*key|key.*storage|save.*private/i.test(content);
  const hasServerSide = /server|backend|api/i.test(content);
  if (hasKeyStorage && hasServerSide) {
    findings.push({
      id: "SOL4041",
      title: "DEXX Pattern - Server-Side Key Storage Breach",
      severity: "critical",
      description: "$21M DEXX exploit (Nov 2024): Private keys stored server-side were compromised. Never store user keys on servers.",
      location: { file: filePath, line: 1 },
      recommendation: "Use client-side key generation only. Implement hardware wallet support. Consider MPC for custodial needs."
    });
  }
  const hasPumpMechanic = /bonding|launch|fair_launch/i.test(content);
  const hasEmployeeAccess = /admin|employee|internal/i.test(content);
  if (hasPumpMechanic && hasEmployeeAccess) {
    findings.push({
      id: "SOL4042",
      title: "Pump.fun Pattern - Insider Launch Attack",
      severity: "high",
      description: "$1.9M Pump.fun (May 2024): Employee exploited privileged access to extract bonding curve funds. Implement zero-trust internally.",
      location: { file: filePath, line: 1 },
      recommendation: "Minimize internal privileged access. Implement audit trails. Use hardware keys for employee access. Background checks."
    });
  }
  const hasAdminAuthority = /authority|admin|super/i.test(content);
  const hasNoSeparation = !/separation|isolated|sandboxed/i.test(content);
  if (hasAdminAuthority && hasNoSeparation) {
    findings.push({
      id: "SOL4043",
      title: "Loopscale Pattern - Unseparated Admin Authority",
      severity: "critical",
      description: "$5.7M Loopscale (Apr 2025): Single admin authority controlled all protocol functions. Implement separation of duties.",
      location: { file: filePath, line: 1 },
      recommendation: "Separate upgrade, treasury, and operational authorities. Use different multisig sets. Implement timelocks per function type."
    });
  }
  const hasSessionKey = /session.*key|temporary.*auth|api.*key/i.test(content);
  const hasExpiry = /expire|ttl|valid_until/i.test(content);
  if (hasSessionKey && !hasExpiry) {
    findings.push({
      id: "SOL4044",
      title: "Thunder Terminal Pattern - Non-Expiring Session Keys",
      severity: "high",
      description: "$240K Thunder Terminal (Dec 2023): Session keys without expiry can be leaked and abused indefinitely.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement short-lived session keys. Add refresh mechanisms. Allow key revocation. Monitor for unusual patterns."
    });
  }
  const hasStepCalculation = /step|increment|accumulator/i.test(content);
  const hasRewardCalculation = /reward|emission|distribute/i.test(content);
  if (hasStepCalculation && hasRewardCalculation) {
    findings.push({
      id: "SOL4045",
      title: "Step Finance Pattern - Reward Calculation Error",
      severity: "high",
      description: "Step Finance had calculation bugs in reward distribution. Audit all mathematical formulas thoroughly.",
      location: { file: filePath, line: 1 },
      recommendation: "Use symbolic testing for math. Implement invariant checks. Compare on-chain vs expected values in tests."
    });
  }
  const hasSolanaWeb3 = /@solana\/web3|solana-web3|web3\.js/i.test(content);
  const hasVersionPin = /exact.*version|locked|pinned/i.test(content);
  if (hasSolanaWeb3) {
    findings.push({
      id: "SOL4046",
      title: "Supply Chain - @solana/web3.js Backdoor Risk",
      severity: "critical",
      description: "Dec 2024: Compromised @solana/web3.js versions contained key-stealing backdoor. Pin dependencies and verify integrity.",
      location: { file: filePath, line: 1 },
      recommendation: "Use lockfiles. Verify package checksums. Pin exact versions. Monitor for security advisories. Use npm audit."
    });
  }
  const hasNpmPackage = /require|import.*from/i.test(content);
  if (hasNpmPackage) {
    findings.push({
      id: "SOL4047",
      title: "Supply Chain - NPM Typosquatting Risk",
      severity: "high",
      description: 'Typosquatted packages like "soIana" (capital I) vs "solana" trick developers. Verify package names carefully.',
      location: { file: filePath, line: 1 },
      recommendation: "Double-check package names. Use verified publisher badges. Audit new dependencies. Implement allowlists."
    });
  }
  const hasAnchor = /anchor|#\[program\]|#\[derive\(Accounts\)\]/i.test(content);
  const hasVersionMismatch = /version|^0\.|^1\./i.test(content);
  if (hasAnchor) {
    findings.push({
      id: "SOL4048",
      title: "Build Risk - Anchor Version Mismatch",
      severity: "medium",
      description: "Anchor CLI and project version mismatches can cause silent build issues and unexpected behavior.",
      location: { file: filePath, line: 1 },
      recommendation: "Pin Anchor versions in CI. Use anchor verify for deployment. Document version requirements clearly."
    });
  }
  const hasCrateImport = /use\s+\w+::/i.test(content);
  if (hasCrateImport) {
    findings.push({
      id: "SOL4049",
      title: "Supply Chain - Rust Crate Backdoor Risk",
      severity: "high",
      description: "Malicious crates can be published to crates.io. Audit all dependencies, especially new or rarely-used ones.",
      location: { file: filePath, line: 1 },
      recommendation: "Review crate source. Use cargo-crev for trust chains. Pin exact versions with Cargo.lock. Regular cargo audit."
    });
  }
  const hasBuildScript = /build\.rs|build_script/i.test(content);
  if (hasBuildScript) {
    findings.push({
      id: "SOL4050",
      title: "Build Attack - Non-Reproducible Builds",
      severity: "medium",
      description: "Non-reproducible builds allow malicious binaries to differ from source. Use verifiable builds.",
      location: { file: filePath, line: 1 },
      recommendation: "Use solana-verify or anchor verify. Document build environment. Use deterministic builds with docker."
    });
  }
  const hasSwapExecution = /swap|exchange|trade/i.test(content);
  const hasSlippage = /slippage|min.*out|max.*in/i.test(content);
  if (hasSwapExecution && hasSlippage) {
    findings.push({
      id: "SOL4051",
      title: "MEV - Jito Bundle Sandwich Attack",
      severity: "high",
      description: "Solana MEV via Jito bundles enables sophisticated sandwich attacks. Implement robust slippage protection.",
      location: { file: filePath, line: 1 },
      recommendation: "Use tight slippage. Consider private transaction pools. Implement MEV-aware routing. Add bundle detection."
    });
  }
  const hasPriorityFee = /priority_fee|compute_unit_price/i.test(content);
  if (hasPriorityFee) {
    findings.push({
      id: "SOL4052",
      title: "MEV - Compute Unit Auction Front-Running",
      severity: "medium",
      description: "High priority fee transactions are visible in mempool and can be front-run with higher fees.",
      location: { file: filePath, line: 1 },
      recommendation: "Use commit-reveal for order-sensitive operations. Consider Jito private transactions. Design order-independent logic."
    });
  }
  const hasLiquidation = /liquidat|underwater|bad_debt/i.test(content);
  const hasIncentive = /bonus|discount|incentive/i.test(content);
  if (hasLiquidation && hasIncentive) {
    findings.push({
      id: "SOL4053",
      title: "MEV - Liquidation Racing",
      severity: "medium",
      description: "Liquidation incentives create racing conditions where searchers compete aggressively, sometimes causing protocol issues.",
      location: { file: filePath, line: 1 },
      recommendation: "Use Dutch auction for liquidation incentives. Implement gradual liquidations. Add keeper rotation."
    });
  }
  const hasOracleUpdate = /update.*price|price.*update|push.*price/i.test(content);
  if (hasOracleUpdate) {
    findings.push({
      id: "SOL4054",
      title: "MEV - Oracle Update Front-Running",
      severity: "high",
      description: "Pending oracle updates can be detected and front-run to profit from price movements.",
      location: { file: filePath, line: 1 },
      recommendation: "Use confidential oracle updates. Implement commit-reveal. Add randomized update timing."
    });
  }
  const hasNftMint = /mint|nft|collection/i.test(content);
  const hasPublicMint = /public|open|anyone/i.test(content);
  if (hasNftMint && hasPublicMint) {
    findings.push({
      id: "SOL4055",
      title: "MEV - NFT Mint Sniping",
      severity: "medium",
      description: "Public NFT mints are vulnerable to bot sniping of rare traits using simulation attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Use reveal mechanism. Implement fair randomness. Add bot protection (captcha, rate limits). Consider allowlists."
    });
  }
  const hasPerpetual = /perpetual|perp|futures/i.test(content);
  const hasFunding = /funding|rate|premium/i.test(content);
  if (hasPerpetual && hasFunding) {
    findings.push({
      id: "SOL4056",
      title: "Perp DEX - Funding Rate Manipulation",
      severity: "high",
      description: "Perpetual funding rates based on mark-index spread can be manipulated via concentrated position placement.",
      location: { file: filePath, line: 1 },
      recommendation: "Cap maximum funding rate. Use multi-source price feeds. Implement anti-manipulation delays. Monitor unusual activity."
    });
  }
  const hasVirtualReserve = /virtual|k_invariant|constant_product/i.test(content);
  const hasReserveDrain = /drain|extract|remove.*liquidity/i.test(content);
  if (hasVirtualReserve || hasReserveDrain) {
    findings.push({
      id: "SOL4057",
      title: "AMM - Virtual Reserves Drain Attack",
      severity: "high",
      description: "AMMs with virtual reserves can be drained if reserve calculations dont properly account for edge cases.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement minimum liquidity. Add withdrawal rate limits. Verify invariant after every operation."
    });
  }
  const hasStakePool = /stake.*pool|liquid.*staking|lst/i.test(content);
  const hasRebasing = /rebase|adjust.*supply|reward.*distribution/i.test(content);
  if (hasStakePool && hasRebasing) {
    findings.push({
      id: "SOL4058",
      title: "Stake Pool - Rebasing Attack Vector",
      severity: "high",
      description: "Rebasing stake tokens can be exploited if rebase timing is predictable or manipulable.",
      location: { file: filePath, line: 1 },
      recommendation: "Use non-rebasing receipt tokens (exchange rate model). Make rebase timing unpredictable. Add rate limiters."
    });
  }
  const hasBridge = /bridge|cross.*chain|wormhole|layerzero/i.test(content);
  const hasNonce = /nonce|sequence|message_id/i.test(content);
  if (hasBridge && !hasNonce) {
    findings.push({
      id: "SOL4059",
      title: "Bridge - Message Replay Attack",
      severity: "critical",
      description: "Cross-chain messages without nonces can be replayed for double-spending across chains.",
      location: { file: filePath, line: 1 },
      recommendation: "Include incrementing nonce in all bridge messages. Verify nonce progression. Implement replay protection per chain pair."
    });
  }
  const hasIntent = /intent|order|rfq/i.test(content);
  const hasSolver = /solver|filler|market_maker/i.test(content);
  if (hasIntent && hasSolver) {
    findings.push({
      id: "SOL4060",
      title: "Intent Protocol - Solver Collusion Risk",
      severity: "medium",
      description: "Intent-based protocols can suffer from solver collusion to provide suboptimal fills.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement solver reputation system. Use competitive auctions. Add price benchmarks. Allow user price limits."
    });
  }
  const hasSimulation = /simulat|preflight|dry_run/i.test(content);
  const hasExecution = /send|execute|submit/i.test(content);
  if (hasSimulation && hasExecution) {
    findings.push({
      id: "SOL4061",
      title: "Wallet - Simulation vs Execution Mismatch",
      severity: "high",
      description: "Transactions can produce different results between simulation and execution due to state changes.",
      location: { file: filePath, line: 1 },
      recommendation: "Show simulation warnings to users. Use recent blockhash. Implement transaction preview verification."
    });
  }
  const hasSignRequest = /sign|approve/i.test(content);
  const hasNoPreview = !/preview|display|show.*transaction/i.test(content);
  if (hasSignRequest && hasNoPreview) {
    findings.push({
      id: "SOL4062",
      title: "Wallet - Blind Signing Attack",
      severity: "high",
      description: "Users signing transactions without clear preview can be tricked into malicious approvals.",
      location: { file: filePath, line: 1 },
      recommendation: "Always show transaction effects before signing. Implement human-readable transaction parsing. Add risk warnings."
    });
  }
  const hasWalletConnect = /connect|wallet.*connect|adapter/i.test(content);
  const hasSession = /session|connection|link/i.test(content);
  if (hasWalletConnect && hasSession) {
    findings.push({
      id: "SOL4063",
      title: "Wallet - Connection Hijacking",
      severity: "medium",
      description: "Wallet connections can be hijacked if session keys are exposed or connection is unencrypted.",
      location: { file: filePath, line: 1 },
      recommendation: "Use encrypted connections. Implement session timeouts. Show connected apps clearly. Allow easy disconnection."
    });
  }
  const hasMessageSign = /sign_message|personal_sign/i.test(content);
  if (hasMessageSign) {
    findings.push({
      id: "SOL4064",
      title: "Wallet - Message Signing Phishing",
      severity: "medium",
      description: "Signed messages can be used for off-chain authorization. Phishing sites can trick users into signing malicious messages.",
      location: { file: filePath, line: 1 },
      recommendation: "Show clear message content before signing. Implement domain-specific prefixes. Warn on unusual messages."
    });
  }
  const hasMultiWallet = /wallet|account|keypair/i.test(content);
  const hasSelection = /select|choose|switch/i.test(content);
  if (hasMultiWallet && hasSelection) {
    findings.push({
      id: "SOL4065",
      title: "UX Security - Multiple Wallet Confusion",
      severity: "low",
      description: "Users with multiple wallets can accidentally sign with wrong wallet, sending from unintended accounts.",
      location: { file: filePath, line: 1 },
      recommendation: "Display active wallet clearly. Confirm wallet selection before signing. Use visual wallet identifiers."
    });
  }
  const hasFlashLoan2 = /flash.*loan|flashloan/i.test(content);
  const hasArbitrage = /arbitrage|arb|profit/i.test(content);
  if (hasFlashLoan2 && hasArbitrage) {
    findings.push({
      id: "SOL4066",
      title: "DeFi Composability - Flash Loan Arbitrage Impact",
      severity: "medium",
      description: "Flash loan arbitrage can extract value from protocol inefficiencies, sometimes destabilizing pools.",
      location: { file: filePath, line: 1 },
      recommendation: "Design arbitrage-resistant pricing. Implement gradual price updates. Consider MEV auction mechanisms."
    });
  }
  const hasComposableCpi = /invoke|cpi|call/i.test(content);
  const hasStateUpdate = /state|account.*=|data\./i.test(content);
  if (hasComposableCpi && hasStateUpdate) {
    findings.push({
      id: "SOL4067",
      title: "DeFi Composability - Cross-Protocol Reentrancy",
      severity: "high",
      description: "CPI to external protocols can trigger callbacks that reenter your protocol in unexpected state.",
      location: { file: filePath, line: 1 },
      recommendation: "Use checks-effects-interactions pattern. Implement reentrancy guards. Complete state updates before CPI."
    });
  }
  const hasCollateralFactor = /collateral.*factor|ltv|loan_to_value/i.test(content);
  const hasMultiAsset = /multi.*asset|mixed.*collateral/i.test(content);
  if (hasCollateralFactor && hasMultiAsset) {
    findings.push({
      id: "SOL4068",
      title: "Lending - Collateral Factor Correlation Risk",
      severity: "high",
      description: "Correlated assets used as collateral may crash together, making collateral factors insufficient.",
      location: { file: filePath, line: 1 },
      recommendation: "Adjust LTV for correlated assets. Implement correlation monitoring. Use portfolio-based risk assessment."
    });
  }
  const hasProtocolFee = /fee|protocol_fee|treasury_fee/i.test(content);
  const hasFeeCalculation = /calculate.*fee|fee.*percent/i.test(content);
  if (hasProtocolFee && hasFeeCalculation) {
    findings.push({
      id: "SOL4069",
      title: "DeFi - Protocol Fee Extraction Attack",
      severity: "medium",
      description: "Fee calculation edge cases can be exploited to minimize fees paid or maximize fees received.",
      location: { file: filePath, line: 1 },
      recommendation: "Use fixed-point math for fees. Implement minimum fee thresholds. Audit fee paths for gaming."
    });
  }
  const hasLiquidity = /liquidity|pool|amm/i.test(content);
  const hasMultiPool = /pool.*pool|migrate|split/i.test(content);
  if (hasLiquidity && hasMultiPool) {
    findings.push({
      id: "SOL4070",
      title: "AMM - Liquidity Fragmentation Attack",
      severity: "medium",
      description: "Splitting liquidity across many pools can degrade trading efficiency and enable manipulation.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement pool routing aggregation. Add minimum liquidity requirements. Consider pool consolidation incentives."
    });
  }
  const hasInterestBearing = /interest|accrued|rate.*bearing/i.test(content);
  const hasToken2022 = /spl_token_2022|token.*extension/i.test(content);
  if (hasInterestBearing || hasToken2022) {
    findings.push({
      id: "SOL4071",
      title: "Token-2022 - Interest-Bearing Token Exploitation",
      severity: "high",
      description: "Interest-bearing tokens accumulate value over time. DeFi integrations must handle interest accrual correctly.",
      location: { file: filePath, line: 1 },
      recommendation: "Query current amount including interest. Account for interest in pricing. Test with various interest rates."
    });
  }
  const hasPermanentDelegate = /permanent.*delegate|delegate.*permanent/i.test(content);
  if (hasPermanentDelegate) {
    findings.push({
      id: "SOL4072",
      title: "Token-2022 - Permanent Delegate Abuse",
      severity: "critical",
      description: "Permanent delegates can transfer any token amount without owner approval. Extremely dangerous if compromised.",
      location: { file: filePath, line: 1 },
      recommendation: "Avoid permanent delegates for user tokens. Use for protocol-controlled tokens only. Document risks clearly."
    });
  }
  const hasNonTransferable = /non.*transfer|soulbound|locked/i.test(content);
  const hasTransferCheck = /can.*transfer|is.*transferable/i.test(content);
  if (hasNonTransferable && !hasTransferCheck) {
    findings.push({
      id: "SOL4073",
      title: "Token-2022 - Non-Transferable Token Bypass",
      severity: "medium",
      description: "Non-transferable tokens should block all transfer paths including CPI. Missing checks allow bypasses.",
      location: { file: filePath, line: 1 },
      recommendation: "Use token-2022 non-transferable extension. Verify no alternative transfer paths exist."
    });
  }
  const hasMemoRequired = /memo.*required|require.*memo/i.test(content);
  if (hasMemoRequired) {
    findings.push({
      id: "SOL4074",
      title: "Token-2022 - Memo Requirement Bypass",
      severity: "low",
      description: "Memo-required tokens can have compliance issues if CPI transfers skip memo attachment.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify memo is attached in all transfer paths. Test CPI transfer compliance."
    });
  }
  const hasDefaultState = /default.*state|frozen|initial.*state/i.test(content);
  if (hasDefaultState) {
    findings.push({
      id: "SOL4075",
      title: "Token-2022 - Default Account State Issues",
      severity: "medium",
      description: "Default frozen state can cause UX issues. Protocols must handle thaw correctly.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement automatic thaw flow. Document frozen state handling. Test integration with frozen accounts."
    });
  }
  const hasProposal = /proposal|vote|governance/i.test(content);
  const hasSpamProtection = /deposit|stake.*vote|cooldown/i.test(content);
  if (hasProposal && !hasSpamProtection) {
    findings.push({
      id: "SOL4076",
      title: "Governance - Proposal Griefing Attack",
      severity: "medium",
      description: "Without proposal costs, attackers can spam proposals to exhaust voter attention.",
      location: { file: filePath, line: 1 },
      recommendation: "Require proposal deposit. Implement proposal limits. Add proposal quality thresholds."
    });
  }
  const hasVoteDelegation = /delegate|delegation|voting_power/i.test(content);
  if (hasVoteDelegation) {
    findings.push({
      id: "SOL4077",
      title: "Governance - Vote Buying via Delegation",
      severity: "medium",
      description: "Delegation systems can enable vote buying through off-chain agreements for delegation.",
      location: { file: filePath, line: 1 },
      recommendation: "Consider delegation lock periods. Implement transparent delegation tracking. Add anti-sybil measures."
    });
  }
  const hasEmergency = /emergency|urgent|immediate/i.test(content);
  const hasNoTimelock = !/timelock|delay|waiting/i.test(content);
  if (hasEmergency && hasNoTimelock) {
    findings.push({
      id: "SOL4078",
      title: "Governance - Emergency Action Abuse",
      severity: "high",
      description: "Emergency powers without limits can be abused to bypass normal governance.",
      location: { file: filePath, line: 1 },
      recommendation: "Limit emergency actions scope. Require multi-party approval. Implement automatic expiry."
    });
  }
  const hasGovQuorum = /quorum|threshold|minimum.*vote/i.test(content);
  const hasDynamicQuorum = /dynamic|adaptive|adjusted/i.test(content);
  if (hasGovQuorum && !hasDynamicQuorum) {
    findings.push({
      id: "SOL4079",
      title: "Governance - Static Quorum Manipulation",
      severity: "medium",
      description: "Static quorum can become too high (paralysis) or too low (attack) as participation changes.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement adaptive quorum. Track participation trends. Allow quorum updates via governance."
    });
  }
  const hasSnapshot = /snapshot|checkpoint|at_block/i.test(content);
  if (hasSnapshot) {
    findings.push({
      id: "SOL4080",
      title: "Governance - Snapshot Timing Exploitation",
      severity: "medium",
      description: "Known snapshot times allow accumulating voting power just before snapshot, then selling after.",
      location: { file: filePath, line: 1 },
      recommendation: "Use random snapshot delays. Implement time-weighted voting. Consider lock requirements."
    });
  }
  const hasAiAgent = /agent|bot|automat/i.test(content);
  const hasTransactionBuild = /build.*tx|create.*transaction/i.test(content);
  if (hasAiAgent && hasTransactionBuild) {
    findings.push({
      id: "SOL4081",
      title: "2026 Pattern - AI Agent Transaction Injection",
      severity: "high",
      description: "AI agents building transactions can be manipulated via prompt injection to create malicious transactions.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate all agent-built transactions. Implement spending limits. Use allowlist for transaction types."
    });
  }
  const hasLlmOracle = /llm|gpt|claude|ai.*oracle/i.test(content);
  if (hasLlmOracle) {
    findings.push({
      id: "SOL4082",
      title: "2026 Pattern - LLM Oracle Manipulation",
      severity: "critical",
      description: "AI/LLM-based oracles can be manipulated via adversarial inputs or prompt injection.",
      location: { file: filePath, line: 1 },
      recommendation: "Never use LLM output for financial decisions. Implement sanity checks. Use traditional oracles for prices."
    });
  }
  const hasAccountAbstraction = /account.*abstraction|smart.*account|module/i.test(content);
  if (hasAccountAbstraction) {
    findings.push({
      id: "SOL4083",
      title: "2026 Pattern - Modular Account Exploit",
      severity: "high",
      description: "Modular smart accounts can have vulnerabilities in module interactions or permission systems.",
      location: { file: filePath, line: 1 },
      recommendation: "Audit module interactions. Implement module allowlists. Use permission scoping. Test upgrade paths."
    });
  }
  const hasRestaking = /restaking|restake|shared.*security/i.test(content);
  const hasSlashing = /slash|penalty|punish/i.test(content);
  if (hasRestaking && hasSlashing) {
    findings.push({
      id: "SOL4084",
      title: "2026 Pattern - Restaking Slashing Cascade",
      severity: "high",
      description: "Restaking across multiple protocols can cause cascade slashing if one protocol has an incident.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement slashing caps. Diversify restaking across uncorrelated protocols. Add circuit breakers."
    });
  }
  const hasIntents = /intent|order|user.*preference/i.test(content);
  const hasFiller = /filler|solver|executor/i.test(content);
  if (hasIntents && hasFiller) {
    findings.push({
      id: "SOL4085",
      title: "2026 Pattern - Intent-Based MEV Extraction",
      severity: "medium",
      description: "Intent-based systems can leak MEV to fillers/solvers who have information advantage.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement fair ordering. Use encrypted intents. Add user-specified MEV protection."
    });
  }
  const hasPoints = /points|airdrop|reward.*distribution/i.test(content);
  const hasActivity = /activity|volume|interaction/i.test(content);
  if (hasPoints && hasActivity) {
    findings.push({
      id: "SOL4086",
      title: "2026 Pattern - Points/Airdrop Gaming",
      severity: "low",
      description: "Points systems based on activity metrics can be gamed via wash trading or Sybil attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Use Sybil-resistant metrics. Implement velocity limits. Consider proof-of-personhood."
    });
  }
  const hasCompressedState = /compressed.*state|state.*compression|zk.*proof/i.test(content);
  if (hasCompressedState) {
    findings.push({
      id: "SOL4087",
      title: "2026 Pattern - Compressed State Proof Attack",
      severity: "high",
      description: "State compression using ZK proofs can have vulnerabilities in proof generation or verification.",
      location: { file: filePath, line: 1 },
      recommendation: "Use audited ZK circuits. Verify proofs on-chain. Implement fallback to uncompressed state."
    });
  }
  const hasCrossRollup = /rollup|l2|svm/i.test(content);
  const hasMessage = /message|relay|bridge/i.test(content);
  if (hasCrossRollup && hasMessage) {
    findings.push({
      id: "SOL4088",
      title: "2026 Pattern - Cross-Rollup Message Attack",
      severity: "critical",
      description: "Messages between Solana rollups/L2s can be forged or replayed if not properly secured.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify message authenticity via state proofs. Implement nonces per rollup pair. Add message expiry."
    });
  }
  const hasRwa = /rwa|real.*world.*asset|tokeniz/i.test(content);
  if (hasRwa) {
    findings.push({
      id: "SOL4089",
      title: "2026 Pattern - RWA Tokenization Fraud Risk",
      severity: "high",
      description: "Real-world asset tokens depend on off-chain custody and verification which can be falsified.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement proof of reserves. Use trusted custodians. Add oracle-based verification. Consider insurance."
    });
  }
  const hasValidator = /validator|consensus|vote/i.test(content);
  if (hasValidator) {
    findings.push({
      id: "SOL4090",
      title: "Infrastructure - Validator Client Divergence Risk",
      severity: "medium",
      description: "Different validator clients may have subtle differences causing consensus issues.",
      location: { file: filePath, line: 1 },
      recommendation: "Test against all major clients. Monitor client distribution. Participate in testnet."
    });
  }
  const hasComputeMarket = /compute|resource|allocation/i.test(content);
  const hasAuction = /auction|bid|priority/i.test(content);
  if (hasComputeMarket && hasAuction) {
    findings.push({
      id: "SOL4091",
      title: "Infrastructure - Compute Market Manipulation",
      severity: "medium",
      description: "Compute resource auctions can be manipulated to block legitimate transactions.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement fair scheduling. Add compute reservation. Monitor for manipulation patterns."
    });
  }
  const hasLeaderSchedule = /leader|slot.*schedule|producer/i.test(content);
  if (hasLeaderSchedule) {
    findings.push({
      id: "SOL4092",
      title: "Infrastructure - Leader Schedule Exploitation",
      severity: "low",
      description: "Known leader schedules allow timing attacks and targeted MEV strategies.",
      location: { file: filePath, line: 1 },
      recommendation: "Design for worst-case leader behavior. Implement timeout handling. Use randomized submission."
    });
  }
  const hasTurbine = /turbine|shred|propagation/i.test(content);
  if (hasTurbine) {
    findings.push({
      id: "SOL4093",
      title: "Infrastructure - Turbine Propagation Attack",
      severity: "medium",
      description: "Turbine block propagation can be disrupted by malicious nodes causing network delays.",
      location: { file: filePath, line: 1 },
      recommendation: "Monitor propagation health. Implement fallback mechanisms. Diversify node connections."
    });
  }
  const hasGossip = /gossip|peer|discovery/i.test(content);
  if (hasGossip) {
    findings.push({
      id: "SOL4094",
      title: "Infrastructure - Gossip Network Poisoning",
      severity: "medium",
      description: "Gossip protocol can be poisoned with malicious peer information.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement peer reputation. Use verified entry points. Monitor for anomalous peers."
    });
  }
  const hasRpcRateLimit = /rate.*limit|throttle|limit.*request/i.test(content);
  if (hasRpcRateLimit) {
    findings.push({
      id: "SOL4095",
      title: "Infrastructure - RPC Rate Limit Bypass",
      severity: "low",
      description: "RPC rate limits can be bypassed using multiple endpoints or IP rotation.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement application-level rate limiting. Use authenticated RPC. Monitor usage patterns."
    });
  }
  const hasAccountSize = /account.*size|data.*length|space/i.test(content);
  const hasUserInput = /user|input|external/i.test(content);
  if (hasAccountSize && hasUserInput) {
    findings.push({
      id: "SOL4096",
      title: "Infrastructure - Account Data Size DoS",
      severity: "medium",
      description: "Allowing users to control account data size can cause compute/rent issues.",
      location: { file: filePath, line: 1 },
      recommendation: "Set maximum data sizes. Charge proportionally for storage. Implement size validation."
    });
  }
  const hasClockUsage = /Clock::get|unix_timestamp|current_time/i.test(content);
  const hasTimeSensitive = /expire|deadline|valid_until/i.test(content);
  if (hasClockUsage && hasTimeSensitive) {
    findings.push({
      id: "SOL4097",
      title: "Infrastructure - Clock Drift Exploitation",
      severity: "low",
      description: "Clock sysvar can drift from real time. Time-sensitive logic must account for drift.",
      location: { file: filePath, line: 1 },
      recommendation: "Add tolerance for clock drift. Use slots for ordering when possible. Avoid tight time constraints."
    });
  }
  const hasTxSize = /transaction.*size|tx.*limit|instruction.*count/i.test(content);
  if (hasTxSize) {
    findings.push({
      id: "SOL4098",
      title: "Infrastructure - Transaction Size Limit Gaming",
      severity: "low",
      description: "Complex operations near transaction size limits may fail unexpectedly.",
      location: { file: filePath, line: 1 },
      recommendation: "Design for worst-case transaction sizes. Implement batching for large operations. Use ALTs for address compression."
    });
  }
  const hasCrossProgram = /cross.*program|cpi|invoke/i.test(content);
  const hasDataRead = /read|load|deserialize/i.test(content);
  if (hasCrossProgram && hasDataRead) {
    findings.push({
      id: "SOL4099",
      title: "Infrastructure - Cross-Program Data Poisoning",
      severity: "high",
      description: "Data read from cross-program accounts should be treated as untrusted until validated.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate all cross-program data. Verify account ownership before reading. Check discriminators."
    });
  }
  const hasDeploy = /deploy|upgrade|buffer/i.test(content);
  const hasRace = /concurrent|parallel|simultaneous/i.test(content);
  if (hasDeploy || hasRace) {
    findings.push({
      id: "SOL4100",
      title: "Infrastructure - Program Deploy Race Condition",
      severity: "medium",
      description: "Program upgrades can create race conditions with in-flight transactions.",
      location: { file: filePath, line: 1 },
      recommendation: "Coordinate upgrades with pause mechanism. Implement version checks. Use graceful migration patterns."
    });
  }
  return findings;
}

// src/patterns/solana-batched-patterns-81.ts
function checkBatch81Patterns(parsed, filePath) {
  const findings = [];
  const content = parsed.content;
  const lines = content.split("\n");
  const hasAdminKey = /admin_key|authority_key|owner_key/i.test(content);
  const hasExternalService = /external|api|http|fetch|request/i.test(content);
  if (hasAdminKey && hasExternalService) {
    findings.push({
      id: "SOL4151",
      title: "Loopscale Pattern - Admin Key Exposure Risk",
      severity: "critical",
      description: "$5.8M Loopscale exploit: Admin keys exposed through integration vulnerabilities. Secure key storage and rotation is critical.",
      location: { file: filePath, line: 1 },
      recommendation: "Use hardware security modules (HSM). Implement multi-sig for admin operations. Never expose keys through APIs."
    });
  }
  const hasBridgeConfig = /bridge.*config|cross.*chain.*config|wormhole.*config/i.test(content);
  const hasConfigUpdate = /update_config|set_config|modify_config/i.test(content);
  if (hasBridgeConfig && hasConfigUpdate) {
    const hasNoAccessControl = !/only_owner|only_admin|require.*authority/i.test(content);
    if (hasNoAccessControl) {
      findings.push({
        id: "SOL4152",
        title: "NoOnes Pattern - Bridge Configuration Manipulation",
        severity: "critical",
        description: "NoOnes bridge exploit: Configuration changes enabled without proper authorization leading to fund theft.",
        location: { file: filePath, line: 1 },
        recommendation: "Implement strict access control for all configuration changes. Use timelocks for critical parameter updates."
      });
    }
  }
  const hasServerStorage = /store.*key|save.*key|persist.*secret/i.test(content);
  const hasCentralized = /server|backend|api.*key|centralized/i.test(content);
  if (hasServerStorage && hasCentralized) {
    findings.push({
      id: "SOL4153",
      title: "DEXX Pattern - Centralized Key Storage",
      severity: "critical",
      description: "$30M DEXX exploit: Private keys stored on centralized servers led to mass wallet compromise. Never store user keys centrally.",
      location: { file: filePath, line: 1 },
      recommendation: "Use client-side key generation and storage. Implement MPC for shared custody. Never store full private keys on servers."
    });
  }
  const hasTradingBot = /trading_bot|auto_trade|bot.*trade|sniper/i.test(content);
  const hasAutoExecution = /auto_execute|automatic.*swap|instant.*buy/i.test(content);
  if (hasTradingBot || hasAutoExecution) {
    findings.push({
      id: "SOL4154",
      title: "Banana Gun Pattern - Trading Bot Security",
      severity: "high",
      description: "$1.4M Banana Gun exploit: Trading bots with privileged access can be compromised. Limit bot permissions and implement circuit breakers.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement spending limits on trading bots. Use timelocks for large transactions. Monitor for abnormal trading patterns."
    });
  }
  const hasUnauthorizedAdmin = /admin|authority|owner/i.test(content);
  const hasWithdraw = /withdraw|transfer_all|drain/i.test(content);
  if (hasUnauthorizedAdmin && hasWithdraw) {
    const hasNoMultisig = !/multisig|multi_sig|threshold/i.test(content);
    if (hasNoMultisig) {
      findings.push({
        id: "SOL4155",
        title: "Solareum Pattern - Single-Point Admin Control",
        severity: "critical",
        description: "Solareum exploit: Single admin key control enabled unauthorized fund withdrawal. Implement multi-signature requirements.",
        location: { file: filePath, line: 1 },
        recommendation: "Require multi-sig for all admin operations. Implement timelock delays. Use DAO governance for critical changes."
      });
    }
  }
  const hasEmployeeAccess = /employee|internal|staff|team_member/i.test(content);
  const hasPrivilegedOperation = /privileged|elevated|admin_action/i.test(content);
  if (hasEmployeeAccess || hasPrivilegedOperation) {
    findings.push({
      id: "SOL4156",
      title: "Pump.fun Pattern - Insider Threat Mitigation",
      severity: "high",
      description: "$1.9M Pump.fun exploit: Former employee used retained access to exploit protocol. Implement access revocation and monitoring.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement immediate access revocation on employee departure. Use hardware-bound credentials. Monitor all privileged actions."
    });
  }
  const hasProposalSystem = /proposal|governance.*vote|dao.*action/i.test(content);
  const hasExecuteProposal = /execute_proposal|process_vote|finalize/i.test(content);
  if (hasProposalSystem && hasExecuteProposal) {
    const hasNoQuorum = !/quorum|minimum_votes|threshold_percent/i.test(content);
    if (hasNoQuorum) {
      findings.push({
        id: "SOL4157",
        title: "Saga DAO Pattern - Low Quorum Governance Attack",
        severity: "high",
        description: "Saga DAO exploit: Malicious proposal passed with insufficient quorum leading to fund drain. Enforce strict voting requirements.",
        location: { file: filePath, line: 1 },
        recommendation: "Implement minimum quorum thresholds. Add proposal review periods. Use veToken systems for sybil resistance."
      });
    }
  }
  const hasDelegation = /delegate|voting_power|proxy_vote/i.test(content);
  const hasVoteWeight = /vote_weight|voting_balance|power_calculation/i.test(content);
  if (hasDelegation && hasVoteWeight) {
    findings.push({
      id: "SOL4158",
      title: "Synthetify Pattern - Vote Delegation Exploit",
      severity: "high",
      description: "Synthetify DAO exploit: Vote delegation system exploited to pass malicious proposal unnoticed. Monitor delegation patterns.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement vote delegation caps. Add alerts for unusual delegation patterns. Require multi-block voting periods."
    });
  }
  const hasComputeResource = /compute|gpu|resource_allocation/i.test(content);
  const hasRewardPayment = /reward|payment|compensation/i.test(content);
  if (hasComputeResource && hasRewardPayment) {
    const hasNoVerification = !/verify_computation|proof_of_work|attestation/i.test(content);
    if (hasNoVerification) {
      findings.push({
        id: "SOL4159",
        title: "io.net Pattern - Compute Resource Fraud",
        severity: "high",
        description: "io.net exploit: Fake GPU reports submitted to claim rewards. Implement cryptographic proof of computation.",
        location: { file: filePath, line: 1 },
        recommendation: "Use TEE attestation for compute verification. Implement random challenge-response. Verify hardware authenticity."
      });
    }
  }
  const hasSessionManagement = /session|cookie|auth_token/i.test(content);
  const hasDatabase = /mongodb|database|db_connection/i.test(content);
  if (hasSessionManagement && hasDatabase) {
    findings.push({
      id: "SOL4160",
      title: "Thunder Terminal Pattern - Session Security",
      severity: "critical",
      description: "$240K Thunder Terminal exploit: MongoDB injection allowed session hijacking. Secure all database queries and session management.",
      location: { file: filePath, line: 1 },
      recommendation: "Use parameterized queries. Implement session encryption. Add IP binding and device fingerprinting for sessions."
    });
  }
  const hasRevertLogic = /revert|abort|rollback|error\!/i.test(content);
  const hasStateChange = /state\.|account\.data|lamports\s*=/i.test(content);
  if (hasRevertLogic && hasStateChange) {
    findings.push({
      id: "SOL4161",
      title: "Cope Roulette Pattern - Transaction Reversion Exploit",
      severity: "medium",
      description: "Transaction reverting can be exploited to retry operations until desired outcome. Common in gambling and MEV applications.",
      location: { file: filePath, line: 1 },
      recommendation: "Use commit-reveal schemes for random outcomes. Implement cooldown periods. Verify finality before state changes."
    });
  }
  const hasApprove = /approve|delegate|allowance/i.test(content);
  const hasRevoke = /revoke|reset.*approval|clear.*delegate/i.test(content);
  if (hasApprove && !hasRevoke) {
    findings.push({
      id: "SOL4162",
      title: "SPL Token Approval - Missing Revocation",
      severity: "medium",
      description: "Token approvals without revocation mechanism. Users may have unlimited approvals outstanding that can be exploited.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement explicit revocation. Use approve-and-spend in single transaction. Add approval expiry."
    });
  }
  const hasLpToken = /lp_token|liquidity_token|pool_token/i.test(content);
  const hasPriceCalc = /price|value|worth|calculate.*amount/i.test(content);
  if (hasLpToken && hasPriceCalc) {
    const hasNoFairPricing = !/fair_price|virtual_price|underlying_value/i.test(content);
    if (hasNoFairPricing) {
      findings.push({
        id: "SOL4163",
        title: "LP Token Oracle - Fair Pricing Required",
        severity: "high",
        description: "OtterSec $200M research: LP token prices can be manipulated via AMM reserves. Use fair pricing formula with underlying assets.",
        location: { file: filePath, line: 1 },
        recommendation: "Calculate LP value from underlying tokens, not reserve ratios. Use TWAP for underlying prices. Implement manipulation checks."
      });
    }
  }
  const hasOracle = /oracle|price_feed|pyth|switchboard/i.test(content);
  const hasLiquidation = /liquidate|liquidation|margin_call/i.test(content);
  if (hasOracle && hasLiquidation) {
    const hasNoGuardrails = !/deviation.*limit|max.*change|circuit.*breaker/i.test(content);
    if (hasNoGuardrails) {
      findings.push({
        id: "SOL4164",
        title: "Drift Pattern - Oracle Guardrails Required",
        severity: "high",
        description: "Drift Protocol oracle guardrails prevent manipulation. Implement price deviation limits, staleness checks, and confidence intervals.",
        location: { file: filePath, line: 1 },
        recommendation: "Add max price deviation (e.g., 10% per block). Implement staleness threshold. Use confidence intervals for Pyth."
      });
    }
  }
  const hasAnchorAccount = /#\[account\]|Account<'info/i.test(content);
  const hasMultipleStructs = (content.match(/pub\s+struct/g) || []).length > 3;
  if (hasAnchorAccount && hasMultipleStructs) {
    findings.push({
      id: "SOL4165",
      title: "Anchor Discriminator - Potential Collision",
      severity: "medium",
      description: "Multiple account structs increase discriminator collision risk. While rare, verify unique 8-byte discriminators.",
      location: { file: filePath, line: 1 },
      recommendation: "Use anchor discriminator::verify in tests. Consider custom discriminators for critical accounts. Document discriminator values."
    });
  }
  const hasUpgrade = /upgrade|deploy|migrate_program/i.test(content);
  const hasActiveState = /active|pending|in_progress/i.test(content);
  if (hasUpgrade && hasActiveState) {
    findings.push({
      id: "SOL4166",
      title: "Program Upgrade Race Condition",
      severity: "high",
      description: "Program upgrades during active transactions can cause state inconsistencies. Implement safe upgrade patterns.",
      location: { file: filePath, line: 1 },
      recommendation: "Pause protocol before upgrade. Complete all pending operations. Use versioned state for migration compatibility."
    });
  }
  const hasCrossInstance = /cross_instance|shared_account|global_state/i.test(content);
  const hasMultiplePrograms = /external_program|cpi.*program_id/i.test(content);
  if (hasCrossInstance || hasMultiplePrograms) {
    findings.push({
      id: "SOL4167",
      title: "Cross-Instance Account Security",
      severity: "medium",
      description: "Accounts shared across program instances need careful access control to prevent unauthorized modifications.",
      location: { file: filePath, line: 1 },
      recommendation: "Use PDAs with program_id in seeds. Validate account ownership on every access. Implement access control lists."
    });
  }
  const hasRemainingAccounts = /remaining_accounts|ctx\.remaining/i.test(content);
  const hasUncheckedIteration = /for.*remaining|iter.*remaining/i.test(content);
  if (hasRemainingAccounts && hasUncheckedIteration) {
    findings.push({
      id: "SOL4168",
      title: "Remaining Accounts - Arbitrary Data Risk",
      severity: "high",
      description: "Iterating over remaining_accounts without validation allows arbitrary account injection. Validate each account.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate owner, discriminator, and PDA derivation for each remaining account. Use typed account wrappers."
    });
  }
  const hasStakePool = /stake_pool|staking_pool|validator_stake/i.test(content);
  const hasStateUpdate = /update_state|modify_stake|change_delegation/i.test(content);
  if (hasStakePool && hasStateUpdate) {
    findings.push({
      id: "SOL4169",
      title: "Stake Pool - Semantic Inconsistency Risk",
      severity: "high",
      description: "Sec3 discovery: Stake pool state updates can have semantic inconsistencies leading to incorrect reward distribution or stake manipulation.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify state transitions are atomic. Cross-check stake amounts with on-chain data. Implement invariant checks."
    });
  }
  const hasLendingMarket = /lending_market|borrow_market|money_market/i.test(content);
  const hasMarketCreation = /create_market|init_market|new_market/i.test(content);
  if (hasLendingMarket && hasMarketCreation) {
    const hasNoMarketValidation = !/validate_market|trusted_market|whitelist/i.test(content);
    if (hasNoMarketValidation) {
      findings.push({
        id: "SOL4170",
        title: "Solend Pattern - Malicious Lending Market",
        severity: "critical",
        description: "Solend malicious market incident: Attacker created fake lending market to bypass auth. Validate market authenticity.",
        location: { file: filePath, line: 1 },
        recommendation: "Whitelist known market accounts. Verify market ownership chain. Check market creator authority."
      });
    }
  }
  const hasNftMinting = /candy_machine|nft_mint|collection_mint/i.test(content);
  const hasCounterLogic = /items_redeemed|mint_count|total_minted/i.test(content);
  if (hasNftMinting && hasCounterLogic) {
    findings.push({
      id: "SOL4171",
      title: "Candy Machine - Minting Counter Overflow",
      severity: "medium",
      description: "Candy Machine network outage: Counter overflow in NFT minting caused DoS. Use safe arithmetic for all counters.",
      location: { file: filePath, line: 1 },
      recommendation: "Use checked arithmetic for counters. Implement rate limiting. Add circuit breakers for high-volume operations."
    });
  }
  const hasJitoBundle = /jito|bundle|mev_bundle/i.test(content);
  const hasBundleProcessing = /process_bundle|execute_bundle|submit_bundle/i.test(content);
  if (hasJitoBundle || hasBundleProcessing) {
    findings.push({
      id: "SOL4172",
      title: "Jito Bundle - DDoS Protection Required",
      severity: "medium",
      description: "Jito DDoS incident: MEV bundles can be weaponized for network spam. Implement bundle validation and rate limiting.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate bundle economics. Implement priority fee minimums. Monitor for bundle spam patterns."
    });
  }
  const hasWalletInterface = /wallet_adapter|connect_wallet|sign_transaction/i.test(content);
  const hasDataParsing = /parse|deserialize|decode/i.test(content);
  if (hasWalletInterface && hasDataParsing) {
    findings.push({
      id: "SOL4173",
      title: "Wallet Interface - Malformed Data DoS",
      severity: "medium",
      description: "Phantom DoS: Malformed transaction data crashed wallet clients. Validate all input before processing.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement strict input validation. Use try/catch for deserialization. Add size limits on all parsed data."
    });
  }
  const hasTurbine = /turbine|shred|propagation/i.test(content);
  const hasBlockProcessing = /block|slot|leader_schedule/i.test(content);
  if (hasTurbine || hasBlockProcessing) {
    findings.push({
      id: "SOL4174",
      title: "Turbine - Block Propagation Reliability",
      severity: "info",
      description: "Turbine failure incident: Block propagation bugs caused network stalls. Monitor propagation metrics.",
      location: { file: filePath, line: 1 },
      recommendation: "Use multiple RPC endpoints. Implement fallback mechanisms. Monitor slot progression for anomalies."
    });
  }
  const hasDurableNonce = /durable_nonce|nonce_account|advance_nonce/i.test(content);
  const hasOfflineSigning = /offline|presigned|delayed_execution/i.test(content);
  if (hasDurableNonce || hasOfflineSigning) {
    findings.push({
      id: "SOL4175",
      title: "Durable Nonce - Transaction Replay Risk",
      severity: "high",
      description: "Durable nonce bug: Improper nonce handling can enable transaction replay. Advance nonce before execution.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify nonce advancement. Check nonce authority. Use nonce instruction as first in transaction."
    });
  }
  const hasJitCompilation = /jit|just_in_time|compiled/i.test(content);
  const hasProgramExecution = /execute|invoke|call_program/i.test(content);
  if (hasJitCompilation || hasProgramExecution) {
    findings.push({
      id: "SOL4176",
      title: "JIT Cache - Stale Code Risk",
      severity: "low",
      description: "JIT cache bug: Stale cached code could execute after program upgrade. Monitor program deployment.",
      location: { file: filePath, line: 1 },
      recommendation: "Wait for cache invalidation after upgrades. Use versioned program IDs. Monitor execution behavior post-upgrade."
    });
  }
  const hasElfProcessing = /elf|program_data|executable/i.test(content);
  const hasAddressHandling = /address|pointer|offset/i.test(content);
  if (hasElfProcessing && hasAddressHandling) {
    findings.push({
      id: "SOL4177",
      title: "ELF Address - Alignment Vulnerability",
      severity: "medium",
      description: "ELF alignment vulnerability: Improper address alignment could cause undefined behavior. Use aligned access.",
      location: { file: filePath, line: 1 },
      recommendation: "Use aligned memory access. Verify ELF section alignment. Test with address sanitizer."
    });
  }
  const hasConsensus = /consensus|vote|tower|fork/i.test(content);
  const hasBlockValidation = /validate_block|check_block|verify_block/i.test(content);
  if (hasConsensus || hasBlockValidation) {
    findings.push({
      id: "SOL4178",
      title: "Consensus - Duplicate Block Detection",
      severity: "info",
      description: "Duplicate block bug: Consensus issues from duplicate block processing. Monitor for chain anomalies.",
      location: { file: filePath, line: 1 },
      recommendation: "Use multiple confirmation sources. Monitor fork distance. Implement block hash verification."
    });
  }
  const hasNetworkDependency = /network|cluster|rpc_client/i.test(content);
  const hasHighLoad = /batch|bulk|high_volume/i.test(content);
  if (hasNetworkDependency && hasHighLoad) {
    findings.push({
      id: "SOL4179",
      title: "Network Dependency - Load Management",
      severity: "medium",
      description: "Grape Protocol incident: Network congestion caused 17-hour outage. Implement load shedding and fallbacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Use exponential backoff. Implement queue management. Have RPC endpoint fallbacks."
    });
  }
  const hasFrontend = /frontend|web_app|client_side/i.test(content);
  const hasCdnOrScript = /cdn|script|external_resource/i.test(content);
  if (hasFrontend || hasCdnOrScript) {
    findings.push({
      id: "SOL4180",
      title: "Frontend Supply Chain - CDN Security",
      severity: "high",
      description: "Parcl frontend compromise: CDN/script injection led to user fund theft. Implement subresource integrity.",
      location: { file: filePath, line: 1 },
      recommendation: "Use subresource integrity (SRI) for all scripts. Implement CSP headers. Self-host critical libraries."
    });
  }
  const hasGlobalState = /static\s+mut|lazy_static|once_cell/i.test(content);
  if (hasGlobalState) {
    findings.push({
      id: "SOL4181",
      title: "Bad Practice - Mutable Global State",
      severity: "medium",
      description: "arXiv research: Mutable global state leads to reentrancy and race conditions. Use account state instead.",
      location: { file: filePath, line: 1 },
      recommendation: "Store all state in accounts. Use PDA-based state management. Avoid static mut in Solana programs."
    });
  }
  const hasArrayAccess = /\[\s*\d+\s*\]|\[\s*\w+\s*\]/g.test(content);
  const hasNoLengthCheck = !/\.len\(\)|\.is_empty\(\)|bounds.*check/i.test(content);
  if (hasArrayAccess && hasNoLengthCheck) {
    findings.push({
      id: "SOL4182",
      title: "Coding Error - Unchecked Array Access",
      severity: "medium",
      description: "Array access without bounds checking can cause panics or undefined behavior.",
      location: { file: filePath, line: 1 },
      recommendation: "Use .get() for safe access. Check array length before indexing. Handle Option return properly."
    });
  }
  const hasInit = /initialize|init\s*\(|setup\s*\(/i.test(content);
  const hasNoInitGuard = !/is_initialized|already_initialized|init_once/i.test(content);
  if (hasInit && hasNoInitGuard) {
    findings.push({
      id: "SOL4183",
      title: "Initialization Race - Double Init Risk",
      severity: "high",
      description: "Initialization without guard allows reinitialization attacks. Use is_initialized flag.",
      location: { file: filePath, line: 1 },
      recommendation: "Check is_initialized before init. Use Anchor init constraint. Make init idempotent or one-time."
    });
  }
  const hasRandom = /random|rand|rng|seed/i.test(content);
  const hasBlockhash = /blockhash|recent_blockhash|slot/i.test(content);
  if (hasRandom && hasBlockhash) {
    const hasNoCommitReveal = !/commit.*reveal|vrf|chainlink|switchboard.*vrf/i.test(content);
    if (hasNoCommitReveal) {
      findings.push({
        id: "SOL4184",
        title: "Insufficient Entropy - Predictable Randomness",
        severity: "high",
        description: "Using blockhash/slot for randomness is predictable by validators. Use VRF or commit-reveal.",
        location: { file: filePath, line: 1 },
        recommendation: "Use Switchboard VRF or Chainlink VRF. Implement commit-reveal scheme. Never use only on-chain data for randomness."
      });
    }
  }
  const hasStateModification = /\.data\.borrow_mut\(\)|account\.data\s*=/i.test(content);
  const hasNoEvent = !/emit!|msg!.*event|log_instruction/i.test(content);
  if (hasStateModification && hasNoEvent) {
    findings.push({
      id: "SOL4185",
      title: "Missing Events - Unindexed State Changes",
      severity: "low",
      description: "State changes without event emission make indexing and monitoring difficult.",
      location: { file: filePath, line: 1 },
      recommendation: "Emit events for all significant state changes. Use Anchor emit! macro. Include relevant data in events."
    });
  }
  const hasExpect = /\.expect\(|\.unwrap\(/g.test(content);
  const hasCriticalOp = /transfer|mint|burn|close/i.test(content);
  if (hasExpect && hasCriticalOp) {
    findings.push({
      id: "SOL4186",
      title: "Unsafe Unwrap - Panic on Critical Path",
      severity: "medium",
      description: "Using expect/unwrap on critical operations can cause program panic and DoS.",
      location: { file: filePath, line: 1 },
      recommendation: "Use Result propagation with ?. Return custom errors. Handle all None/Err cases explicitly."
    });
  }
  const hasSwap = /swap|exchange|trade/i.test(content);
  const hasAmountCalc = /amount_out|output_amount|receive_amount/i.test(content);
  if (hasSwap && hasAmountCalc) {
    const hasNoSlippage = !/slippage|min_amount|minimum_out|max_amount_in/i.test(content);
    if (hasNoSlippage) {
      findings.push({
        id: "SOL4187",
        title: "Missing Slippage - Sandwich Attack Vulnerable",
        severity: "high",
        description: "Swaps without slippage protection are vulnerable to sandwich attacks.",
        location: { file: filePath, line: 1 },
        recommendation: "Implement minimum output amount parameter. Calculate slippage tolerance. Revert if slippage exceeded."
      });
    }
  }
  const hasTokenAccount = /TokenAccount|spl_token|token_program/i.test(content);
  const hasNoAuthorityCheck = !/authority.*==|owner.*==|check.*authority/i.test(content);
  if (hasTokenAccount && hasNoAuthorityCheck) {
    findings.push({
      id: "SOL4188",
      title: "Token Authority - Missing Verification",
      severity: "critical",
      description: "Token account operations without authority verification can lead to unauthorized transfers.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify token account authority matches expected PDA or signer. Use Anchor token constraints."
    });
  }
  const hasPdaDerivation = /find_program_address|create_program_address/i.test(content);
  const hasVariableSeeds = /user\.|account\.|input/i.test(content);
  if (hasPdaDerivation && hasVariableSeeds) {
    const hasNoCanonicalization = !/canonical|normalize|lowercase|trim/i.test(content);
    if (hasNoCanonicalization) {
      findings.push({
        id: "SOL4189",
        title: "PDA Seeds - Canonicalization Required",
        severity: "medium",
        description: "PDA seeds from user input should be canonicalized to prevent collision attacks.",
        location: { file: filePath, line: 1 },
        recommendation: "Normalize all string seeds (lowercase, trim). Use fixed-size hashes for variable-length inputs."
      });
    }
  }
  const hasDecimals = /decimals|decimal_places|precision/i.test(content);
  const hasTokenAmount = /amount|balance|value/i.test(content);
  if (hasDecimals && hasTokenAmount) {
    const hasNoDecimalCheck = !/check_decimals|verify_decimals|decimals.*==|mint\.decimals/i.test(content);
    if (hasNoDecimalCheck) {
      findings.push({
        id: "SOL4190",
        title: "Token Decimals - Precision Loss Risk",
        severity: "medium",
        description: "Token operations without decimal verification can cause significant precision loss.",
        location: { file: filePath, line: 1 },
        recommendation: "Query token mint for decimals. Scale amounts appropriately. Use consistent precision across operations."
      });
    }
  }
  const hasFundingRate = /funding_rate|funding_payment|perp_funding/i.test(content);
  const hasPositionValue = /position_value|notional|open_interest/i.test(content);
  if (hasFundingRate && hasPositionValue) {
    findings.push({
      id: "SOL4191",
      title: "Perpetual DEX - Funding Rate Manipulation",
      severity: "high",
      description: "Funding rate calculations can be manipulated through position imbalance. Implement rate caps.",
      location: { file: filePath, line: 1 },
      recommendation: "Cap maximum funding rate. Use TWAP for rate calculation. Implement position size limits."
    });
  }
  const hasVaultShares = /shares|vault_token|receipt_token/i.test(content);
  const hasDeposit = /deposit|stake|add_liquidity/i.test(content);
  if (hasVaultShares && hasDeposit) {
    const hasNoInflationCheck = !/first_deposit|initial_deposit|minimum_deposit/i.test(content);
    if (hasNoInflationCheck) {
      findings.push({
        id: "SOL4192",
        title: "Vault Share Inflation - First Depositor Attack",
        severity: "high",
        description: "First depositor can manipulate share price through small initial deposit followed by direct transfer.",
        location: { file: filePath, line: 1 },
        recommendation: "Require minimum initial deposit. Lock initial shares. Use virtual shares for price floor."
      });
    }
  }
  const hasCrossMargin = /cross_margin|shared_collateral|unified_margin/i.test(content);
  const hasMultiPosition = /positions|multi_asset|portfolio/i.test(content);
  if (hasCrossMargin && hasMultiPosition) {
    findings.push({
      id: "SOL4193",
      title: "Cross-Margin - Account Isolation",
      severity: "high",
      description: "Cross-margin systems need careful position isolation to prevent cascade liquidations.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement position-level risk checks. Add isolation modes. Monitor margin utilization per position."
    });
  }
  const hasRoyalty = /royalty|creator_fee|seller_fee/i.test(content);
  const hasNftTransfer = /transfer.*nft|nft.*transfer|token_transfer/i.test(content);
  if (hasRoyalty && hasNftTransfer) {
    const hasNoEnforcement = !/enforce.*royalty|royalty.*required|mandatory.*fee/i.test(content);
    if (hasNoEnforcement) {
      findings.push({
        id: "SOL4194",
        title: "NFT Royalty - Bypass Risk",
        severity: "medium",
        description: "NFT royalties can be bypassed through direct transfers. Use Metaplex royalty enforcement.",
        location: { file: filePath, line: 1 },
        recommendation: "Use pNFT standard with enforced royalties. Implement marketplace-level enforcement. Consider Royalty Guard."
      });
    }
  }
  const hasRestaking = /restaking|liquid_staking|staking_derivative/i.test(content);
  const hasSlashing = /slash|penalty|punishment/i.test(content);
  if (hasRestaking && hasSlashing) {
    findings.push({
      id: "SOL4195",
      title: "Restaking - Slashing Condition Clarity",
      severity: "medium",
      description: "Restaking protocols need clear slashing conditions to prevent disputes and unexpected losses.",
      location: { file: filePath, line: 1 },
      recommendation: "Document all slashing conditions. Implement slashing limits. Use timelocked slashing with appeal period."
    });
  }
  const hasSocialFeatures = /follow|like|post|comment|social/i.test(content);
  const hasTokenReward = /reward|incentive|earn|distribute/i.test(content);
  if (hasSocialFeatures && hasTokenReward) {
    findings.push({
      id: "SOL4196",
      title: "Social-Fi - Sybil Attack Vulnerable",
      severity: "medium",
      description: "Social platforms with token rewards are vulnerable to spam account attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement proof-of-humanity. Use social graph analysis. Require stake for participation."
    });
  }
  const hasPredictionMarket = /prediction|outcome|binary_option|betting/i.test(content);
  const hasResolution = /resolve|settle|determine_winner/i.test(content);
  if (hasPredictionMarket && hasResolution) {
    findings.push({
      id: "SOL4197",
      title: "Prediction Market - Resolution Oracle Risk",
      severity: "high",
      description: "Prediction market resolution can be manipulated through oracle control or timing attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Use decentralized oracles with dispute periods. Implement multi-source resolution. Add challenge mechanism."
    });
  }
  const hasRwa = /real_world_asset|rwa|tokenized_asset/i.test(content);
  const hasCollateral = /collateral|backing|reserve/i.test(content);
  if (hasRwa && hasCollateral) {
    findings.push({
      id: "SOL4198",
      title: "RWA - Off-Chain Collateral Verification",
      severity: "high",
      description: "Real-world asset tokens require verifiable off-chain collateral. Implement proof of reserves.",
      location: { file: filePath, line: 1 },
      recommendation: "Use attestation oracles. Implement regular audits. Provide on-chain proof of reserve updates."
    });
  }
  const hasIntent = /intent|order|user_intent/i.test(content);
  const hasSolver = /solver|filler|executor|relayer/i.test(content);
  if (hasIntent && hasSolver) {
    findings.push({
      id: "SOL4199",
      title: "Intent-Based - Solver Manipulation Risk",
      severity: "medium",
      description: "Intent-based systems can be exploited by malicious solvers through selective execution.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement solver competition. Add execution guarantees. Monitor solver behavior for manipulation."
    });
  }
  const hasCompressedNft = /compressed|cnft|merkle_tree|state_tree/i.test(content);
  const hasProofVerification = /proof|verify_leaf|merkle_proof/i.test(content);
  if (hasCompressedNft && hasProofVerification) {
    findings.push({
      id: "SOL4200",
      title: "Compressed NFT - Merkle Proof Verification",
      severity: "medium",
      description: "Compressed NFT operations require valid merkle proofs. Verify proof validity and freshness.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify proof against current tree root. Check proof path validity. Handle concurrent updates."
    });
  }
  return findings;
}

// src/patterns/solana-batched-patterns-82.ts
function checkBatch82Patterns(parsed, filePath) {
  const findings = [];
  const content = parsed.content;
  const lines = content.split("\n");
  const hasGovernance = /governance|proposal|vote/i.test(content);
  const hasPdaCreation = /create_program_address|find_program_address/i.test(content);
  if (hasGovernance && hasPdaCreation) {
    const hasVariableSeeds = /proposal_id|vote_id|user/i.test(content);
    if (hasVariableSeeds) {
      findings.push({
        id: "SOL4201",
        title: "OtterSec Pattern - Governance PDA Collision",
        severity: "high",
        description: "Jet Governance audit: PDA seeds with variable user input can cause collision. Hash inputs for fixed-size seeds.",
        location: { file: filePath, line: 1 },
        recommendation: "Use keccak256 hash of variable inputs. Include program_id in seeds. Verify PDA uniqueness."
      });
    }
  }
  const hasVaultMath = /calculate_shares|share_price|vault_ratio/i.test(content);
  const hasRoundingIssue = /\/\s*\d|as\s+u64/i.test(content);
  if (hasVaultMath && hasRoundingIssue) {
    findings.push({
      id: "SOL4202",
      title: "OtterSec Pattern - Vault Share Rounding",
      severity: "high",
      description: "Cega audit: Vault share calculations with rounding errors can be exploited for profit extraction.",
      location: { file: filePath, line: 1 },
      recommendation: "Use ceil for minting, floor for redemption. Implement minimum share amounts. Add rounding direction parameter."
    });
  }
  const hasTimeLogic = /clock|timestamp|current_time/i.test(content);
  const hasExpiry = /expiry|deadline|maturity/i.test(content);
  if (hasTimeLogic && hasExpiry) {
    const hasNoBuffer = !/buffer|grace_period|tolerance/i.test(content);
    if (hasNoBuffer) {
      findings.push({
        id: "SOL4203",
        title: "OtterSec Pattern - Time-Based Expiry Race",
        severity: "medium",
        description: "Port Sundial audit: Time-based expiry without buffer enables last-moment manipulation.",
        location: { file: filePath, line: 1 },
        recommendation: "Add buffer period before expiry. Use block-based epochs. Implement grace period for time-sensitive ops."
      });
    }
  }
  const hasOrderBook = /order_book|bid|ask|order_queue/i.test(content);
  const hasStateUpdate = /update_state|modify_order|cancel_order/i.test(content);
  if (hasOrderBook && hasStateUpdate) {
    findings.push({
      id: "SOL4204",
      title: "OtterSec Pattern - Order Book State Consistency",
      severity: "high",
      description: "Phoenix audit: Order book state must be atomically consistent. Partial updates can be exploited.",
      location: { file: filePath, line: 1 },
      recommendation: "Use single-instruction state updates. Implement state rollback on failure. Verify order book invariants."
    });
  }
  const hasMultisig = /multisig|threshold|signers/i.test(content);
  const hasProposalExec = /execute_proposal|process_transaction/i.test(content);
  if (hasMultisig && hasProposalExec) {
    const hasNoThresholdCheck = !/threshold.*>=|signers.*>=|required_signers/i.test(content);
    if (hasNoThresholdCheck) {
      findings.push({
        id: "SOL4205",
        title: "OtterSec Pattern - Multi-sig Threshold Bypass",
        severity: "critical",
        description: "Squads audit: Multi-sig execution without threshold verification enables single-signer attacks.",
        location: { file: filePath, line: 1 },
        recommendation: "Verify signature count >= threshold before execution. Validate signer uniqueness. Check all signers are authorized."
      });
    }
  }
  const hasOracleData = /oracle_data|price_data|feed_data/i.test(content);
  const hasTimestamp = /last_update|timestamp|slot/i.test(content);
  if (hasOracleData && hasTimestamp) {
    const hasNoStalenessCheck = !/staleness|max_age|fresh/i.test(content);
    if (hasNoStalenessCheck) {
      findings.push({
        id: "SOL4206",
        title: "Neodyme Pattern - Oracle Staleness Check",
        severity: "high",
        description: "Mango v3 audit: Oracle data without staleness check enables stale price exploitation.",
        location: { file: filePath, line: 1 },
        recommendation: "Check oracle timestamp against current slot. Revert if data too old. Use configurable max age parameter."
      });
    }
  }
  const hasStakePool = /stake_pool|delegation|validator_list/i.test(content);
  const hasRebalance = /rebalance|redistribute|reallocate/i.test(content);
  if (hasStakePool && hasRebalance) {
    findings.push({
      id: "SOL4207",
      title: "Neodyme Pattern - Stake Pool Rebalancing Risk",
      severity: "medium",
      description: "Marinade audit: Stake rebalancing can be front-run. Implement rebalancing limits and cooldowns.",
      location: { file: filePath, line: 1 },
      recommendation: "Add rebalancing cooldown periods. Limit per-epoch rebalancing amount. Use commit-reveal for large rebalances."
    });
  }
  const hasWhirlpool = /whirlpool|tick_array|price_range/i.test(content);
  const hasTickCross = /cross_tick|tick_transition|price_movement/i.test(content);
  if (hasWhirlpool || hasTickCross) {
    findings.push({
      id: "SOL4208",
      title: "Neodyme Pattern - CLMM Tick Crossing",
      severity: "medium",
      description: "Orca Whirlpool audit: Tick crossing in CLMM requires careful liquidity accounting. Verify fee accrual.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify liquidity changes at tick boundaries. Accumulate fees correctly. Handle tick array transitions."
    });
  }
  const hasCrossChainMessage = /cross_chain|message|bridge_payload/i.test(content);
  const hasMessageProcess = /process_message|handle_message|receive/i.test(content);
  if (hasCrossChainMessage && hasMessageProcess) {
    const hasNoReplayProtection = !/nonce|message_id|processed_messages/i.test(content);
    if (hasNoReplayProtection) {
      findings.push({
        id: "SOL4209",
        title: "Neodyme Pattern - Cross-chain Message Replay",
        severity: "critical",
        description: "Debridge audit: Cross-chain messages without replay protection can be executed multiple times.",
        location: { file: filePath, line: 1 },
        recommendation: "Track processed message IDs. Use nonce for message ordering. Implement idempotent handlers."
      });
    }
  }
  const hasSignatureSet = /signature_set|guardian_signatures|attestation/i.test(content);
  const hasQuorumCheck = /quorum|required_signatures|threshold/i.test(content);
  if (hasSignatureSet && hasQuorumCheck) {
    findings.push({
      id: "SOL4210",
      title: "Neodyme Pattern - Signature Set Validation",
      severity: "critical",
      description: "Wormhole audit: Signature set must verify quorum and signature validity. Check all signatures are from guardians.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify each signature individually. Check signer is in guardian set. Ensure no duplicate signers."
    });
  }
  const hasReserve = /reserve|lending_pool|money_market/i.test(content);
  const hasConfigUpdate = /update_reserve|set_config|modify_reserve/i.test(content);
  if (hasReserve && hasConfigUpdate) {
    findings.push({
      id: "SOL4211",
      title: "Kudelski Pattern - Reserve Configuration Security",
      severity: "high",
      description: "Solend audit: Reserve configuration changes can impact all borrowers. Implement governance and timelocks.",
      location: { file: filePath, line: 1 },
      recommendation: "Use timelock for config changes. Notify users of pending changes. Limit maximum parameter changes."
    });
  }
  const hasVaultStrategy = /strategy|vault_strategy|yield_strategy/i.test(content);
  const hasStrategySwitch = /switch_strategy|migrate_strategy|update_strategy/i.test(content);
  if (hasVaultStrategy && hasStrategySwitch) {
    findings.push({
      id: "SOL4212",
      title: "Kudelski Pattern - Vault Strategy Migration",
      severity: "high",
      description: "Friktion audit: Strategy switches can leave funds in limbo. Ensure complete fund accounting during migration.",
      location: { file: filePath, line: 1 },
      recommendation: "Pause deposits during migration. Verify all funds accounted for. Implement rollback capability."
    });
  }
  const hasCollateralRatio = /collateral_ratio|ltv|loan_to_value/i.test(content);
  const hasPriceUpdate = /price_update|oracle_update|feed_update/i.test(content);
  if (hasCollateralRatio && hasPriceUpdate) {
    findings.push({
      id: "SOL4213",
      title: "Kudelski Pattern - Collateral Ratio Manipulation",
      severity: "high",
      description: "Hubble audit: Collateral ratio can be manipulated through oracle update timing. Use TWAP for ratio calculations.",
      location: { file: filePath, line: 1 },
      recommendation: "Use time-weighted average prices. Add price deviation checks. Implement liquidation delay for sudden price changes."
    });
  }
  const hasCrossPool = /cross_pool|multi_pool|pool_routing/i.test(content);
  const hasArbitrage = /arbitrage|price_diff|imbalance/i.test(content);
  if (hasCrossPool && hasArbitrage) {
    findings.push({
      id: "SOL4214",
      title: "Kudelski Pattern - Cross-pool Arbitrage Protection",
      severity: "medium",
      description: "Swim audit: Cross-pool operations can enable arbitrage extraction. Implement virtual price balancing.",
      location: { file: filePath, line: 1 },
      recommendation: "Use uniform pricing across pools. Implement anti-arbitrage fees. Monitor for sandwich attacks."
    });
  }
  const hasSynthetic = /synthetic|synth|pegged_asset/i.test(content);
  const hasPegMechanism = /peg|backing|collateralization/i.test(content);
  if (hasSynthetic && hasPegMechanism) {
    findings.push({
      id: "SOL4215",
      title: "Kudelski Pattern - Synthetic Asset Peg Stability",
      severity: "high",
      description: "Synthetify audit: Synthetic peg stability requires robust collateralization. Monitor debt ratio continuously.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement over-collateralization buffers. Use dynamic minting fees. Add global debt ceiling."
    });
  }
  const hasMargin = /margin|maintenance_requirement|initial_margin/i.test(content);
  const hasPositionCalc = /position_value|unrealized_pnl|notional/i.test(content);
  if (hasMargin && hasPositionCalc) {
    findings.push({
      id: "SOL4216",
      title: "Zellic Pattern - Margin Calculation Precision",
      severity: "high",
      description: "Drift audit: Margin calculations require high precision. Use fixed-point arithmetic with sufficient decimals.",
      location: { file: filePath, line: 1 },
      recommendation: "Use 128-bit fixed-point for margin. Round conservatively for liquidation. Verify margin across all positions."
    });
  }
  const hasPyth = /pyth|PriceFeed|get_price/i.test(content);
  const hasPrice = /price|value|quote/i.test(content);
  if (hasPyth && hasPrice) {
    const hasNoConfidence = !/confidence|conf|uncertainty/i.test(content);
    if (hasNoConfidence) {
      findings.push({
        id: "SOL4217",
        title: "Zellic Pattern - Pyth Confidence Ignored",
        severity: "high",
        description: "Pyth audit: Using price without confidence interval enables exploitation during volatile periods.",
        location: { file: filePath, line: 1 },
        recommendation: "Check Pyth confidence interval. Reject prices with high uncertainty. Use conservative price bounds."
      });
    }
  }
  const hasAnchorDeserialize = /Account::try_from|from_account_info/i.test(content);
  const hasNoDiscriminatorCheck = !/discriminator|try_deserialize/i.test(content);
  if (hasAnchorDeserialize && hasNoDiscriminatorCheck) {
    findings.push({
      id: "SOL4218",
      title: "Zellic Pattern - Account Discriminator Check",
      severity: "high",
      description: "Zellic research: Manual deserialization without discriminator check enables type confusion attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Use Anchor Account wrapper. Verify 8-byte discriminator. Never use raw try_from without type check."
    });
  }
  const hasCloseAccount = /close_account|close\s*=|CloseAccount/i.test(content);
  const hasRentRefund = /lamports|rent|refund/i.test(content);
  if (hasCloseAccount && hasRentRefund) {
    findings.push({
      id: "SOL4219",
      title: "Zellic Pattern - Close Account Rent Handling",
      severity: "medium",
      description: "Zellic research: Closing accounts must handle rent refund correctly to prevent fund loss.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify rent recipient is correct. Zero account data before close. Check account is not reused same slot."
    });
  }
  const hasInitIfNeeded = /init_if_needed|init.*if.*not|conditional_init/i.test(content);
  if (hasInitIfNeeded) {
    findings.push({
      id: "SOL4220",
      title: "Zellic Pattern - Init If Needed Risk",
      severity: "high",
      description: "Zellic research: init_if_needed can cause race conditions and unexpected reinitialization.",
      location: { file: filePath, line: 1 },
      recommendation: "Prefer explicit init instruction. Use if init_if_needed, verify complete account state. Add initialization lock."
    });
  }
  const hasAmm = /amm|automated_market_maker|constant_product/i.test(content);
  const hasPriceImpact = /price_impact|slippage|output_amount/i.test(content);
  if (hasAmm && hasPriceImpact) {
    const hasNoImpactLimit = !/max_impact|impact_limit|impact_threshold/i.test(content);
    if (hasNoImpactLimit) {
      findings.push({
        id: "SOL4221",
        title: "Halborn Pattern - AMM Price Impact Limit",
        severity: "medium",
        description: "Cropper audit: Large trades without impact limits can drain pools. Implement maximum price impact.",
        location: { file: filePath, line: 1 },
        recommendation: "Limit maximum price impact per trade. Implement dynamic fees for large trades. Add circuit breakers."
      });
    }
  }
  const hasFeeCollection = /collect_fee|fee_account|protocol_fee/i.test(content);
  const hasFeeWithdraw = /withdraw_fee|claim_fee|transfer_fee/i.test(content);
  if (hasFeeCollection && hasFeeWithdraw) {
    findings.push({
      id: "SOL4222",
      title: "Halborn Pattern - Fee Extraction Security",
      severity: "medium",
      description: "GooseFx audit: Fee extraction must verify authority and destination. Prevent fee theft.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify fee authority is protocol-controlled. Use PDA for fee accounts. Implement fee withdrawal limits."
    });
  }
  const hasCollateralType = /collateral_type|asset_type|backing_asset/i.test(content);
  const hasCollateralAdd = /add_collateral|new_collateral|register_asset/i.test(content);
  if (hasCollateralType && hasCollateralAdd) {
    findings.push({
      id: "SOL4223",
      title: "Halborn Pattern - Collateral Type Validation",
      severity: "high",
      description: "Parrot audit: Adding new collateral types must be validated against security criteria.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate collateral token parameters. Check oracle availability. Require governance approval for new types."
    });
  }
  const hasNftStore = /nft_store|marketplace|nft_sale/i.test(content);
  const hasExternalCall = /invoke|cpi|external_call/i.test(content);
  if (hasNftStore && hasExternalCall) {
    const hasReentrancyGuard = /reentrancy|guard|locked/i.test(content);
    if (!hasReentrancyGuard) {
      findings.push({
        id: "SOL4224",
        title: "Halborn Pattern - NFT Marketplace Reentrancy",
        severity: "high",
        description: "Phantasia audit: NFT purchases with external calls need reentrancy protection.",
        location: { file: filePath, line: 1 },
        recommendation: "Use checks-effects-interactions pattern. Add reentrancy guard. Update state before external calls."
      });
    }
  }
  const hasAiAgent = /ai_agent|autonomous|agent_wallet/i.test(content);
  const hasAutomatedAction = /auto_execute|scheduled|cron/i.test(content);
  if (hasAiAgent || hasAutomatedAction) {
    findings.push({
      id: "SOL4225",
      title: "2026 Threat - AI Agent Wallet Security",
      severity: "high",
      description: "Emerging threat: AI agents with wallet access can be exploited through prompt injection or logic flaws.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement spending limits for agents. Use multi-sig for large operations. Add human-in-the-loop for sensitive actions."
    });
  }
  const hasMpc = /mpc|multi_party_computation|threshold_signature/i.test(content);
  const hasThresholdChange = /update_threshold|change_threshold|modify_signers/i.test(content);
  if (hasMpc && hasThresholdChange) {
    findings.push({
      id: "SOL4226",
      title: "2026 Threat - MPC Threshold Reduction",
      severity: "critical",
      description: "Emerging threat: MPC threshold reduction attacks can compromise wallet security.",
      location: { file: filePath, line: 1 },
      recommendation: "Require full threshold for threshold changes. Add timelock. Notify all key holders on config changes."
    });
  }
  const hasZkProof = /zk_proof|zero_knowledge|snark|stark/i.test(content);
  const hasVerification = /verify_proof|proof_verification|validate_proof/i.test(content);
  if (hasZkProof && hasVerification) {
    findings.push({
      id: "SOL4227",
      title: "2026 Threat - ZK Proof Verification",
      severity: "critical",
      description: "Emerging threat: ZK proof verification bugs can allow invalid proofs. Use audited verification libraries.",
      location: { file: filePath, line: 1 },
      recommendation: "Use battle-tested ZK libraries. Verify all public inputs. Test with malformed proofs."
    });
  }
  const hasTransferHook = /transfer_hook|hook_program|on_transfer/i.test(content);
  const hasToken2022 = /token_2022|token-2022|spl_token_2022/i.test(content);
  if (hasTransferHook || hasToken2022) {
    findings.push({
      id: "SOL4228",
      title: "2026 Threat - Transfer Hook Exploitation",
      severity: "high",
      description: "Emerging threat: Token-2022 transfer hooks can be exploited for DoS or fund locking.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate transfer hook programs. Implement gas limits. Have fallback if hook fails."
    });
  }
  const hasAtomicArb = /atomic|flash.*arb|arbitrage.*bundle/i.test(content);
  const hasProfitCalc = /profit|expected_return|gain/i.test(content);
  if (hasAtomicArb && hasProfitCalc) {
    findings.push({
      id: "SOL4229",
      title: "2026 Threat - Atomic Arbitrage Protection",
      severity: "medium",
      description: "Emerging threat: Atomic arbitrage bots can extract value. Implement MEV protection.",
      location: { file: filePath, line: 1 },
      recommendation: "Use private mempools. Implement fair ordering. Consider Jito bundles for MEV protection."
    });
  }
  const hasCrossChain = /cross_chain|bridge|wormhole|layerzero/i.test(content);
  const hasChainId = /chain_id|network_id|domain/i.test(content);
  if (hasCrossChain && !hasChainId) {
    findings.push({
      id: "SOL4230",
      title: "2026 Threat - Cross-chain Fork Replay",
      severity: "critical",
      description: "Emerging threat: Cross-chain messages without chain ID can be replayed on forks.",
      location: { file: filePath, line: 1 },
      recommendation: "Include chain ID in all cross-chain messages. Verify destination chain. Use domain separator."
    });
  }
  const hasWebSocket = /websocket|ws_connection|real_time/i.test(content);
  const hasDataHandling = /on_message|handle_data|process_event/i.test(content);
  if (hasWebSocket && hasDataHandling) {
    findings.push({
      id: "SOL4231",
      title: "2026 Threat - WebSocket Data Injection",
      severity: "medium",
      description: "Emerging threat: WebSocket connections can be hijacked for data injection.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate all WebSocket data. Use authenticated connections. Implement message signing."
    });
  }
  const hasValidatorInteraction = /validator|leader|slot_leader/i.test(content);
  const hasOrderDependent = /order|sequence|priority/i.test(content);
  if (hasValidatorInteraction && hasOrderDependent) {
    findings.push({
      id: "SOL4232",
      title: "2026 Threat - Validator MEV Collusion",
      severity: "medium",
      description: "Emerging threat: Validators can collude for MEV extraction. Design for fair ordering.",
      location: { file: filePath, line: 1 },
      recommendation: "Use commit-reveal for sensitive operations. Implement encrypted mempools. Monitor for suspicious ordering."
    });
  }
  const hasExternalDep = /use\s+\w+::|extern\s+crate|dependencies/i.test(content);
  const hasSensitiveOp = /private_key|secret|transfer|mint/i.test(content);
  if (hasExternalDep && hasSensitiveOp) {
    findings.push({
      id: "SOL4233",
      title: "2026 Threat - Dependency Supply Chain",
      severity: "high",
      description: "Web3.js Dec 2024 attack: Dependencies can be compromised. Pin versions and verify checksums.",
      location: { file: filePath, line: 1 },
      recommendation: "Use Cargo.lock. Pin dependency versions. Audit critical dependencies. Use cargo-audit."
    });
  }
  const hasAccountAbstraction = /account_abstraction|aa_wallet|smart_wallet/i.test(content);
  const hasSignatureVerify = /verify_signature|check_sig|validate_auth/i.test(content);
  if (hasAccountAbstraction && hasSignatureVerify) {
    findings.push({
      id: "SOL4234",
      title: "2026 Threat - AA Signature Malleability",
      severity: "high",
      description: "Emerging threat: Account abstraction wallets need strict signature canonicalization.",
      location: { file: filePath, line: 1 },
      recommendation: "Use canonical signature format. Check signature s-value. Implement replay protection."
    });
  }
  const hasDepin = /depin|device_network|iot_network/i.test(content);
  const hasAttestation = /attestation|device_proof|hardware_verify/i.test(content);
  if (hasDepin && hasAttestation) {
    findings.push({
      id: "SOL4235",
      title: "2026 Threat - DePIN Device Spoofing",
      severity: "high",
      description: "Emerging threat: DePIN device attestation can be spoofed. Use TEE-based verification.",
      location: { file: filePath, line: 1 },
      recommendation: "Use TEE attestation (SGX/TDX). Implement device registration. Regular liveness checks."
    });
  }
  const hasProgramOwned = /program_owned|owned_by_program/i.test(content);
  const hasNoOwnerCheck = !/owner\s*==|check_owner/i.test(content);
  if (hasProgramOwned && hasNoOwnerCheck) {
    findings.push({
      id: "SOL4236",
      title: "Program-Owned Account - Missing Owner Check",
      severity: "critical",
      description: "Accounts claimed to be program-owned must verify owner field matches expected program.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify account.owner == program_id. Use Anchor constraints. Never trust account type alone."
    });
  }
  const hasInstructionData = /instruction_data|ix_data|data\[/i.test(content);
  const hasNoLengthValidation = !/data\.len\(\)|length.*check|size.*validate/i.test(content);
  if (hasInstructionData && hasNoLengthValidation) {
    findings.push({
      id: "SOL4237",
      title: "Instruction Data - Length Validation Required",
      severity: "medium",
      description: "Instruction data must be validated for expected length to prevent buffer overflow.",
      location: { file: filePath, line: 1 },
      recommendation: "Check instruction data length before parsing. Use Borsh with size limits. Handle short data gracefully."
    });
  }
  const hasSysvarClock = /sysvar::clock|Clock::get|clock_sysvar/i.test(content);
  if (hasSysvarClock) {
    findings.push({
      id: "SOL4238",
      title: "Sysvar Clock - Manipulation Awareness",
      severity: "low",
      description: "Clock sysvar can have minor drift. For critical timing, consider additional validation.",
      location: { file: filePath, line: 1 },
      recommendation: "Use slot-based logic when possible. Account for clock drift. Use block-based epochs for precision."
    });
  }
  const hasAccountClose = /close|close_account/i.test(content);
  const hasNoZeroing = !/zero|clear|wipe|memset/i.test(content);
  if (hasAccountClose && hasNoZeroing) {
    findings.push({
      id: "SOL4239",
      title: "Account Close - Data Zeroing Required",
      severity: "high",
      description: "Accounts must be zeroed before closing to prevent revival attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Zero all account data fields. Set discriminator to closed state. Use Anchor close constraint."
    });
  }
  const hasMintAuthority = /mint_authority|SetAuthority|set_mint_authority/i.test(content);
  const hasAuthorityTransfer = /transfer_authority|new_authority|change_authority/i.test(content);
  if (hasMintAuthority && hasAuthorityTransfer) {
    findings.push({
      id: "SOL4240",
      title: "Mint Authority - Transfer Security",
      severity: "critical",
      description: "Mint authority transfers are permanent. Verify new authority before transfer.",
      location: { file: filePath, line: 1 },
      recommendation: "Use two-step authority transfer. Verify new authority is valid. Consider multi-sig for mint authority."
    });
  }
  const hasFeeOnTransfer = /fee_on_transfer|transfer_fee|deflationary/i.test(content);
  const hasTransferAmount = /transfer_amount|expected_amount|receive_amount/i.test(content);
  if (hasFeeOnTransfer || hasTransferAmount) {
    findings.push({
      id: "SOL4241",
      title: "Fee-on-Transfer - Amount Verification",
      severity: "medium",
      description: "Fee-on-transfer tokens deliver less than expected. Verify received amount.",
      location: { file: filePath, line: 1 },
      recommendation: "Check balance before and after transfer. Account for transfer fees. Support both fee and non-fee tokens."
    });
  }
  const hasLookupTable = /lookup_table|address_lookup|alt/i.test(content);
  const hasTableUpdate = /extend_table|add_address|append/i.test(content);
  if (hasLookupTable && hasTableUpdate) {
    findings.push({
      id: "SOL4242",
      title: "Lookup Table - Address Inclusion Attack",
      severity: "medium",
      description: "Lookup tables with untrusted addresses can enable account substitution attacks.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify all addresses before adding to lookup table. Use program-controlled tables. Validate at runtime."
    });
  }
  const hasDelegate = /delegate|delegated_amount|approval/i.test(content);
  const hasDelegateAction = /approve|delegate_to|set_delegate/i.test(content);
  if (hasDelegate && hasDelegateAction) {
    findings.push({
      id: "SOL4243",
      title: "Token Delegate - Exploitation Risk",
      severity: "high",
      description: "Token delegates have spending power. Limit delegation amount and implement revocation.",
      location: { file: filePath, line: 1 },
      recommendation: "Use exact delegation amounts. Implement auto-revocation. Clear delegation after use."
    });
  }
  const hasBpfLoader = /bpf_loader|program_deploy|upgrade/i.test(content);
  const hasUpgradeFreeze = /freeze_upgrade|immutable|disable_upgrade/i.test(content);
  if (hasBpfLoader && hasUpgradeFreeze) {
    findings.push({
      id: "SOL4244",
      title: "BPF Loader - Upgrade Authority Freeze",
      severity: "info",
      description: "Freezing upgrade authority is permanent. Ensure program is fully audited before freeze.",
      location: { file: filePath, line: 1 },
      recommendation: "Conduct multiple audits before freeze. Test all edge cases. Have emergency procedures documented."
    });
  }
  const hasConcurrent = /concurrent|parallel|simultaneous/i.test(content);
  const hasStateModify = /modify|update|change_state/i.test(content);
  if (hasConcurrent && hasStateModify) {
    findings.push({
      id: "SOL4245",
      title: "Concurrent Access - State Conflict",
      severity: "medium",
      description: "Concurrent transactions modifying same state can cause conflicts. Use versioning or locks.",
      location: { file: filePath, line: 1 },
      recommendation: "Implement optimistic locking. Use version numbers. Handle conflicts gracefully with retry logic."
    });
  }
  const hasEventEmission = /emit!|emit_event|log_event/i.test(content);
  const hasMultipleEvents = (content.match(/emit/gi) || []).length > 2;
  if (hasEventEmission && hasMultipleEvents) {
    findings.push({
      id: "SOL4246",
      title: "Event Ordering - Dependency Risk",
      severity: "low",
      description: "Multiple events in transaction may be processed out of order by indexers.",
      location: { file: filePath, line: 1 },
      recommendation: "Include sequence numbers in events. Use single aggregate event when possible. Document event ordering."
    });
  }
  const hasBumpStorage = /bump.*store|store.*bump|save.*bump/i.test(content);
  if (hasBumpStorage) {
    findings.push({
      id: "SOL4247",
      title: "PDA Bump - Storage Optimization",
      severity: "low",
      description: "Storing bump seeds uses account space. Consider deriving vs storing based on usage pattern.",
      location: { file: filePath, line: 1 },
      recommendation: "For frequent access, store bump. For rare access, derive. Use canonical bump always."
    });
  }
  const hasIntrospection = /get_instruction|load_instruction|instruction_sysvar/i.test(content);
  const hasSensitiveCheck = /if.*instruction|instruction.*match/i.test(content);
  if (hasIntrospection && hasSensitiveCheck) {
    findings.push({
      id: "SOL4248",
      title: "Instruction Introspection - Attack Surface",
      severity: "medium",
      description: "Instruction introspection can be manipulated through instruction ordering.",
      location: { file: filePath, line: 1 },
      recommendation: "Validate complete instruction context. Check all instructions in transaction. Use atomic instruction groups."
    });
  }
  const hasCpiReturn = /get_return_data|invoke_and_get|return_data/i.test(content);
  const hasReturnProcessing = /process_return|handle_result|use_return/i.test(content);
  if (hasCpiReturn && hasReturnProcessing) {
    findings.push({
      id: "SOL4249",
      title: "CPI Return Data - Validation Required",
      severity: "medium",
      description: "CPI return data must be validated. Malicious programs can return crafted data.",
      location: { file: filePath, line: 1 },
      recommendation: "Verify return data program_id. Validate data structure. Handle missing return data."
    });
  }
  const hasFreeze = /freeze|frozen|FreezeAccount/i.test(content);
  const hasTokenOperation = /transfer|burn|close/i.test(content);
  if (hasFreeze && hasTokenOperation) {
    findings.push({
      id: "SOL4250",
      title: "Frozen Account - Operation Handling",
      severity: "medium",
      description: "Operations on frozen accounts will fail. Check freeze status before operations.",
      location: { file: filePath, line: 1 },
      recommendation: "Check account freeze status. Handle frozen account errors. Document freeze authority usage."
    });
  }
  return findings;
}

// src/patterns/solana-batched-patterns-83.ts
function checkWormholeSignatureSpoofing(content, findings, path) {
  const patterns = [
    /verify_signatures?\s*\([^)]*\)\s*(?!.*verify_guardian)/is,
    /SignatureSet\s*(?!.*owner\s*==)/i,
    /guardian_set\s*(?!.*verify_)/i,
    /signature_verification\s*(?!.*guardian)/i,
    /bridge.*signature\s*(?!.*multi_sig|threshold)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4301",
        title: "Wormhole-Style Signature Verification Bypass",
        severity: "critical",
        description: `Signature verification without proper Guardian/signer validation. The Wormhole $326M exploit used a spoofed SignatureSet account to bypass Guardian validation. Pattern: ${pattern.source.substring(0, 50)}`,
        location: { file: path, line: lineNum },
        recommendation: "Always verify signature set accounts belong to the correct program. Check Guardian set membership. Use verify_guardian_set() before accepting signatures."
      });
    }
  }
}
function checkCashioInfiniteMint(content, findings, path) {
  const patterns = [
    /mint_tokens?\s*\([^)]*\)\s*(?!.*verify_collateral)/is,
    /collateral\s*(?!.*validate_mint)/i,
    /saber_swap.*arrow\s*(?!.*check_mint)/i,
    /infinite\s*mint/i,
    /mint.*without.*collateral/i,
    /create_mint\s*(?!.*require.*collateral)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4302",
        title: "Cashio-Style Infinite Mint Vulnerability",
        severity: "critical",
        description: `Minting without proper collateral validation. The Cashio $52.8M exploit minted 2B tokens with fake collateral by bypassing mint field validation in swap accounts.`,
        location: { file: path, line: lineNum },
        recommendation: "Always validate collateral mint addresses match expected tokens. Implement root of trust validation for all collateral accounts."
      });
    }
  }
}
function checkCremaTickSpoofing(content, findings, path) {
  const patterns = [
    /tick_account\s*(?!.*owner\s*==)/i,
    /tick_data\s*(?!.*verify_owner)/i,
    /claim_fee\s*(?!.*validate_tick)/i,
    /fee_accumulator\s*(?!.*owner)/i,
    /CLMM.*tick\s*(?!.*constraint)/i,
    /concentrated_liquidity.*tick/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4303",
        title: "Crema-Style Tick Account Spoofing",
        severity: "critical",
        description: `CLMM tick account without owner verification. The Crema $8.8M exploit created fake tick accounts to manipulate fee data and drain pools via flash loans.`,
        location: { file: path, line: lineNum },
        recommendation: "Always verify tick account ownership belongs to the protocol. Use PDA derivation to ensure tick accounts cannot be spoofed."
      });
    }
  }
}
function checkAudiusGovernanceExploit(content, findings, path) {
  const patterns = [
    /execute_proposal\s*(?!.*validate_proposal)/i,
    /governance.*proposal\s*(?!.*timelock)/i,
    /treasury.*transfer\s*(?!.*multi_sig)/i,
    /reconfigure.*permission/i,
    /proposal.*execute\s*(?!.*delay)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4304",
        title: "Audius-Style Governance Exploit",
        severity: "critical",
        description: `Governance proposal execution without proper validation or timelock. The Audius $6.1M exploit submitted malicious proposals that reconfigured treasury permissions.`,
        location: { file: path, line: lineNum },
        recommendation: "Implement timelocks for all governance actions. Require multi-sig for treasury operations. Add proposal validation before execution."
      });
    }
  }
}
function checkNirvanaBondingCurve(content, findings, path) {
  const patterns = [
    /bonding_curve.*mint\s*(?!.*flash_loan_check)/i,
    /price_calculation\s*(?!.*oracle)/i,
    /curve.*price\s*(?!.*twap)/i,
    /mint_at_curve\s*(?!.*rate_limit)/i,
    /flash_loan.*bonding/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4305",
        title: "Nirvana-Style Bonding Curve Flash Loan Attack",
        severity: "critical",
        description: `Bonding curve pricing vulnerable to flash loan manipulation. The Nirvana $3.5M exploit used flash loans to purchase tokens and manipulate the bonding curve rate.`,
        location: { file: path, line: lineNum },
        recommendation: "Use external oracles for pricing. Implement TWAP mechanisms. Add flash loan protection with same-block detection."
      });
    }
  }
}
function checkSlopeWalletLeak(content, findings, path) {
  const patterns = [
    /seed_phrase.*log/i,
    /mnemonic.*send|post|http/i,
    /private_key.*telemetry/i,
    /keypair.*server/i,
    /wallet.*analytics.*seed/i,
    /logging.*secret/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4306",
        title: "Slope-Style Private Key Logging",
        severity: "critical",
        description: `Potential private key/seed phrase logging detected. The Slope $8M hack occurred because seed phrases were logged to Sentry (centralized analytics).`,
        location: { file: path, line: lineNum },
        recommendation: "Never log seed phrases or private keys. Use secure enclaves for key storage. Audit all telemetry to ensure no sensitive data is transmitted."
      });
    }
  }
}
function checkMangoOracleManipulation(content, findings, path) {
  const patterns = [
    /oracle_price\s*(?!.*twap|staleness)/i,
    /price_feed\s*(?!.*confidence)/i,
    /get_price\s*(?!.*verify_source)/i,
    /liquidation.*oracle\s*(?!.*delay)/i,
    /margin.*price\s*(?!.*staleness_check)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4307",
        title: "Mango-Style Oracle Manipulation",
        severity: "critical",
        description: `Oracle usage without manipulation protection. The Mango $116M exploit manipulated oracle prices to inflate collateral value, then borrowed against it.`,
        location: { file: path, line: lineNum },
        recommendation: "Use TWAP for price calculations. Check oracle confidence intervals. Add staleness checks. Implement position size limits."
      });
    }
  }
}
function checkOptiFiClosureBug(content, findings, path) {
  const patterns = [
    /close_program\s*(?!.*verify_empty)/i,
    /account_close\s*(?!.*check_balance)/i,
    /program.*close\s*(?!.*drain_first)/i,
    /close_vault\s*(?!.*withdraw_all)/i,
    /terminate.*program/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4308",
        title: "OptiFi-Style Program Closure Lock",
        severity: "high",
        description: `Program closure without ensuring all funds are withdrawn. OptiFi permanently locked $661K by closing the program before draining user funds.`,
        location: { file: path, line: lineNum },
        recommendation: "Always verify all funds are withdrawn before program closure. Implement staged shutdown procedures. Never close accounts with remaining balances."
      });
    }
  }
}
function checkDEXXKeyLeakage(content, findings, path) {
  const patterns = [
    /store_private_key/i,
    /centralized.*key.*storage/i,
    /export.*private_key/i,
    /key_management.*server/i,
    /custodial.*wallet/i,
    /hot_wallet.*all.*funds/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4309",
        title: "DEXX-Style Centralized Key Storage",
        severity: "critical",
        description: `Centralized private key storage detected. The DEXX $30M exploit occurred because private keys were stored server-side, making them vulnerable to compromise.`,
        location: { file: path, line: lineNum },
        recommendation: "Never store private keys on servers. Use client-side key generation. Implement threshold signatures or MPC for any custodial needs."
      });
    }
  }
}
function checkThunderTerminalInjection(content, findings, path) {
  const patterns = [
    /mongodb.*session/i,
    /session_token.*database/i,
    /find\s*\(\s*\{[^}]*\$\w+/i,
    // MongoDB injection patterns
    /aggregate\s*\([^)]*\$where/i,
    /user_session.*store/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4310",
        title: "Thunder Terminal MongoDB Vulnerability",
        severity: "high",
        description: `Database session storage may be vulnerable to injection. Thunder Terminal was exploited via MongoDB session token vulnerabilities.`,
        location: { file: path, line: lineNum },
        recommendation: "Use parameterized queries. Implement session token rotation. Store sessions securely with encryption. Add rate limiting."
      });
    }
  }
}
function checkBananaGunBotSecurity(content, findings, path) {
  const patterns = [
    /trading_bot.*private_key/i,
    /bot.*wallet.*access/i,
    /automated.*transfer.*key/i,
    /sniper_bot.*funds/i,
    /mev_bot.*withdrawal/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4311",
        title: "Banana Gun-Style Bot Infrastructure Vulnerability",
        severity: "high",
        description: `Trading bot with direct wallet access. Banana Gun bot was compromised, allowing attackers to drain user funds through the bot infrastructure.`,
        location: { file: path, line: lineNum },
        recommendation: "Implement withdrawal whitelists. Use time-delayed withdrawals. Require 2FA for any fund movements. Limit bot permissions."
      });
    }
  }
}
function checkPumpFunInsiderThreat(content, findings, path) {
  const patterns = [
    /admin.*withdraw\s*(?!.*multi_sig)/i,
    /employee.*access.*treasury/i,
    /single_key.*withdrawal/i,
    /privileged.*transfer\s*(?!.*timelock)/i,
    /dev_wallet.*unrestricted/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4312",
        title: "Pump.fun-Style Insider Threat",
        severity: "high",
        description: `Admin/employee access without multi-sig protection. Pump.fun lost $1.9M to an insider exploit where a former employee drained the bonding curve.`,
        location: { file: path, line: lineNum },
        recommendation: "Require multi-sig for all admin operations. Implement key rotation upon employee offboarding. Add timelocks for large withdrawals."
      });
    }
  }
}
function checkLoopscaleRateXExploit(content, findings, path) {
  const patterns = [
    /loan.*collateral\s*(?!.*ratio_check)/i,
    /borrow\s*(?!.*collateral_factor)/i,
    /rate_calculation\s*(?!.*validate)/i,
    /undercollateralized/i,
    /leverage.*borrow\s*(?!.*health_check)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4313",
        title: "Loopscale RateX Collateral Validation Flaw",
        severity: "critical",
        description: `Lending without proper collateral ratio validation. Loopscale lost $5.8M due to undercollateralized loan creation via the RateX primitive.`,
        location: { file: path, line: lineNum },
        recommendation: "Always validate collateral ratios before loan creation. Implement health factor checks. Use oracle prices for collateral valuation."
      });
    }
  }
}
function checkCypherInsiderTheft(content, findings, path) {
  const patterns = [
    /recovery.*funds.*single_key/i,
    /post_exploit.*access/i,
    /reimbursement.*wallet.*admin/i,
    /treasury.*recovery\s*(?!.*multi_sig)/i,
    /remnant.*funds.*transfer/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4314",
        title: "Cypher-Style Post-Exploit Insider Theft",
        severity: "high",
        description: `Post-exploit fund recovery without proper controls. Cypher had $317K stolen by an insider (Hoak) from recovery funds after the initial $1M exploit.`,
        location: { file: path, line: lineNum },
        recommendation: "Use multi-sig for all recovery operations. Implement transparent fund tracking. Require independent auditor oversight for fund recovery."
      });
    }
  }
}
function checkWeb3jsSupplyChain(content, findings, path) {
  const patterns = [
    /@solana\/web3\.js.*1\.(90|91)\.[0-9]/i,
    /require\s*\(\s*['"]@solana\/web3\.js['"]\s*\)/,
    /import.*from\s*['"]@solana\/web3\.js['"]/,
    /npm.*install.*solana.*web3/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4315",
        title: "Web3.js Supply Chain Vulnerability",
        severity: "info",
        description: `Solana Web3.js dependency detected. In Dec 2024, versions 1.90.x and 1.91.x were compromised with malicious code. Verify you're using a safe version.`,
        location: { file: path, line: lineNum },
        recommendation: "Use @solana/web3.js version 1.95.8+ or 1.89.x. Implement lockfiles and integrity checks. Monitor npm advisories."
      });
    }
  }
}
function checkSolendAuthBypass2(content, findings, path) {
  const patterns = [
    /update_reserve_config\s*(?!.*verify_admin)/i,
    /lending_market.*authority\s*(?!.*owner_check)/i,
    /reserve.*config\s*(?!.*admin_auth)/i,
    /liquidation_threshold.*update/i,
    /liquidation_bonus.*modify/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4316",
        title: "Solend-Style Auth Bypass",
        severity: "critical",
        description: `Reserve configuration update without proper admin authentication. Solend's Aug 2021 exploit allowed attackers to modify liquidation parameters by bypassing auth checks.`,
        location: { file: path, line: lineNum },
        recommendation: "Always verify admin authority using program-derived addresses. Check lending market ownership before allowing config updates."
      });
    }
  }
}
function checkRaydiumPermitVuln(content, findings, path) {
  const patterns = [
    /permit.*approve\s*(?!.*verify_signature)/i,
    /approval.*unlimited/i,
    /max_approval.*token/i,
    /delegate.*all.*tokens/i,
    /approve.*u64::MAX/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4317",
        title: "Raydium-Style Permit Vulnerability",
        severity: "high",
        description: `Unlimited token approval or permit vulnerability. Raydium's exploit involved unauthorized access to approved tokens through the AMM.`,
        location: { file: path, line: lineNum },
        recommendation: "Limit approval amounts. Implement approval expiration. Provide easy revocation mechanisms. Never use MAX approvals."
      });
    }
  }
}
function checkSolareumInfrastructure(content, findings, path) {
  const patterns = [
    /platform.*hot_wallet/i,
    /infrastructure.*key.*exposure/i,
    /server.*side.*signing/i,
    /centralized.*trading.*platform/i,
    /hot_wallet.*all.*user.*funds/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4318",
        title: "Solareum-Style Infrastructure Compromise",
        severity: "high",
        description: `Centralized infrastructure with hot wallet exposure. Solareum collapsed after infrastructure compromise drained user funds.`,
        location: { file: path, line: lineNum },
        recommendation: "Use cold storage for majority of funds. Implement withdrawal delays. Require multi-sig for hot wallet management."
      });
    }
  }
}
function checkNoOnesPlatformExploit(content, findings, path) {
  const patterns = [
    /p2p.*escrow\s*(?!.*verify)/i,
    /trade.*release\s*(?!.*confirm)/i,
    /escrow.*withdraw\s*(?!.*both_parties)/i,
    /dispute.*resolution\s*(?!.*timelock)/i,
    /peer.*to.*peer.*funds/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4319",
        title: "NoOnes P2P Platform Vulnerability",
        severity: "high",
        description: `P2P escrow without proper verification. NoOnes platform was exploited through escrow release vulnerabilities.`,
        location: { file: path, line: lineNum },
        recommendation: "Require confirmation from both parties. Implement dispute resolution with timelocks. Use multi-sig for escrow release."
      });
    }
  }
}
function checkSynthetifyDAOAttack(content, findings, path) {
  const patterns = [
    /dao.*proposal\s*(?!.*quorum)/i,
    /governance.*vote\s*(?!.*snapshot)/i,
    /execute.*without.*delay/i,
    /proposal.*create\s*(?!.*stake_requirement)/i,
    /voting_power.*transfer/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4320",
        title: "Synthetify DAO Governance Attack",
        severity: "high",
        description: `DAO governance without proper protections. Synthetify DAO was manipulated through governance proposal attacks.`,
        location: { file: path, line: lineNum },
        recommendation: "Implement quorum requirements. Use vote snapshots. Add execution delays. Require stake for proposal creation."
      });
    }
  }
}
function checkMissingSignerCheck2(content, findings, path) {
  if (content.includes("AccountInfo") && !content.includes("is_signer")) {
    const match = content.match(/AccountInfo/);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4321",
        title: "Sealevel Attack: Missing Signer Check",
        severity: "critical",
        description: `AccountInfo used without is_signer verification. This is Sealevel Attack #1 - always verify signers for sensitive operations.`,
        location: { file: path, line: lineNum },
        recommendation: 'Add require!(account.is_signer, "Missing required signature"). Use Signer type in Anchor.'
      });
    }
  }
}
function checkMissingOwnerCheck2(content, findings, path) {
  const patterns = [
    /try_from_slice\s*\([^)]*\)\s*(?!.*owner)/i,
    /unpack\s*\([^)]*\)\s*(?!.*owner\s*==)/i,
    /deserialize\s*\([^)]*\)\s*(?!.*check_owner)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4322",
        title: "Sealevel Attack: Missing Owner Check",
        severity: "critical",
        description: `Account deserialized without owner verification. This is Sealevel Attack #2 - always verify the account owner matches the expected program.`,
        location: { file: path, line: lineNum },
        recommendation: "Add require!(account.owner == &expected_program_id). Use Account<> type in Anchor."
      });
    }
  }
}
function checkIntegerOverflow(content, findings, path) {
  const patterns = [
    /\+\s*(?!checked_add|saturating_add)/,
    /\-\s*(?!checked_sub|saturating_sub)/,
    /\*\s*(?!checked_mul|saturating_mul)/,
    /\/\s*(?!checked_div)/
  ];
  if (content.includes("u64") || content.includes("u128") || content.includes("i64")) {
    if (!content.includes("checked_") && !content.includes("saturating_")) {
      const match = content.match(/[+\-*/]\s*\d+/);
      if (match) {
        const lineNum = content.substring(0, match.index).split("\n").length;
        findings.push({
          id: "SOL4323",
          title: "Sealevel Attack: Integer Overflow/Underflow",
          severity: "high",
          description: `Arithmetic operation without overflow protection. This is Sealevel Attack #3 - use checked_* or saturating_* operations.`,
          location: { file: path, line: lineNum },
          recommendation: "Use checked_add(), checked_sub(), checked_mul(), checked_div(). Or saturating_* variants."
        });
      }
    }
  }
}
function checkAccountDataMatching2(content, findings, path) {
  const patterns = [
    /key\s*==\s*[^&]/i,
    /pubkey.*match\s*(?!.*require)/i,
    /account.*compare\s*(?!.*verify)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4324",
        title: "Sealevel Attack: Account Data Matching",
        severity: "high",
        description: `Account key comparison may not use proper validation. This is Sealevel Attack #4 - verify account data matches expected values.`,
        location: { file: path, line: lineNum },
        recommendation: "Use constraint macros in Anchor: #[account(constraint = account.key() == expected_key)]"
      });
    }
  }
}
function checkReinitializationAttack(content, findings, path) {
  const patterns = [
    /initialize\s*(?!.*is_initialized)/i,
    /init\s*(?!.*zero)/i,
    /create_account\s*(?!.*check_empty)/i,
    /set_initialized\s*(?!.*require.*!is_initialized)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4325",
        title: "Sealevel Attack: Reinitialization Attack",
        severity: "critical",
        description: `Initialize function without reinitialization protection. This is Sealevel Attack #5 - prevent reinitializing already-initialized accounts.`,
        location: { file: path, line: lineNum },
        recommendation: "Check is_initialized flag before initializing. Use init constraint in Anchor."
      });
    }
  }
}
function checkDuplicateMutableAccounts(content, findings, path) {
  const patterns = [
    /mut\s+\w+.*mut\s+\w+/i,
    /writable.*writable/i,
    /borrow_mut\s*\([^)]*\).*borrow_mut/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4326",
        title: "Sealevel Attack: Duplicate Mutable Accounts",
        severity: "high",
        description: `Multiple mutable borrows of potentially same account. This is Sealevel Attack #6 - ensure accounts passed multiple times are not mutably borrowed twice.`,
        location: { file: path, line: lineNum },
        recommendation: "Add account key uniqueness checks. Use Anchor constraint: #[account(constraint = account1.key() != account2.key())]"
      });
    }
  }
}
function checkTypeCosplayAttack(content, findings, path) {
  const patterns = [
    /deserialize\s*(?!.*discriminator)/i,
    /try_from_slice\s*(?!.*check_type)/i,
    /unpack.*generic\s*(?!.*verify_type)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4327",
        title: "Sealevel Attack: Type Cosplay",
        severity: "high",
        description: `Account deserialization without type discriminator check. This is Sealevel Attack #7 - accounts can impersonate other types.`,
        location: { file: path, line: lineNum },
        recommendation: "Use discriminators to verify account types. Anchor handles this automatically with 8-byte discriminators."
      });
    }
  }
}
function checkBumpSeedCanonicalization(content, findings, path) {
  const patterns = [
    /find_program_address\s*(?!.*bump)/i,
    /create_program_address\s*(?!.*canonical)/i,
    /PDA\s*(?!.*store_bump)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4328",
        title: "Sealevel Attack: Bump Seed Canonicalization",
        severity: "medium",
        description: `PDA creation without canonical bump storage. This is Sealevel Attack #8 - always store and use canonical bump seeds.`,
        location: { file: path, line: lineNum },
        recommendation: "Store the canonical bump from find_program_address. Use bump constraint in Anchor."
      });
    }
  }
}
function checkClosingAccountAttack(content, findings, path) {
  const patterns = [
    /close_account\s*(?!.*zero_lamports)/i,
    /lamports\s*=\s*0\s*(?!.*data.*=.*0)/i,
    /close\s*(?!.*set_discriminator_to_closed)/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4329",
        title: "Sealevel Attack: Closing Account Attack",
        severity: "high",
        description: `Account closure without proper cleanup. This is Sealevel Attack #9 - closed accounts can be revived within the same transaction.`,
        location: { file: path, line: lineNum },
        recommendation: "Zero out account data before closing. Set discriminator to CLOSED value. Use close constraint in Anchor."
      });
    }
  }
}
function checkPDASharingAttack(content, findings, path) {
  const patterns = [
    /seeds\s*=\s*\[[^\]]*\]\s*(?!.*user|authority)/i,
    /PDA.*global\s*(?!.*scoped)/i,
    /program_address.*shared/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4330",
        title: "Sealevel Attack: PDA Sharing",
        severity: "high",
        description: `PDA seeds may not properly scope to user/context. This is Sealevel Attack #10 - PDAs should include user-specific seeds.`,
        location: { file: path, line: lineNum },
        recommendation: "Include user pubkey or unique identifier in PDA seeds. Avoid global PDAs for user-specific data."
      });
    }
  }
}
function checkSPLLendingRounding(content, findings, path) {
  const patterns = [
    /round\s*\(\s*[^)]*\)/i,
    /interest.*calculation.*round/i,
    /accrued.*interest\s*(?!.*floor|ceil)/i,
    /decimal.*truncation/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4331",
        title: "SPL Lending Rounding Vulnerability (Neodyme)",
        severity: "critical",
        description: `Interest calculation with potential rounding errors. Neodyme discovered a $2.6B-at-risk vulnerability in SPL Token Lending from innocent-looking rounding.`,
        location: { file: path, line: lineNum },
        recommendation: "Use floor() for amounts going to users, ceil() for amounts going to protocol. Never use round() for financial calculations."
      });
    }
  }
}
function checkLPTokenOracleManipulation(content, findings, path) {
  const patterns = [
    /lp_token.*price\s*(?!.*fair)/i,
    /pool_price.*oracle\s*(?!.*twap)/i,
    /liquidity.*value\s*(?!.*fair_price)/i,
    /collateral.*lp_token/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4332",
        title: "LP Token Oracle Manipulation (OtterSec)",
        severity: "critical",
        description: `LP token pricing may be manipulatable. OtterSec's "$200M Bluff" showed how AMM prices can manipulate lending protocol oracles.`,
        location: { file: path, line: lineNum },
        recommendation: "Use fair pricing for LP tokens. Calculate sqrt(reserve0 * reserve1) / totalSupply. Add TWAP and confidence checks."
      });
    }
  }
}
function checkCopeRouletteRevert(content, findings, path) {
  const patterns = [
    /random.*revert/i,
    /gambling.*transaction/i,
    /outcome.*fail\s*(?!.*commit)/i,
    /bet.*refund.*on.*error/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4333",
        title: "Cope Roulette Revert Exploitation",
        severity: "high",
        description: `Gambling/random outcome may be exploitable via transaction reversion. Cope Roulette showed how unfavorable outcomes can be reverted.`,
        location: { file: path, line: lineNum },
        recommendation: "Use commit-reveal schemes for randomness. Separate bet commitment from outcome. Use VRF for unpredictable randomness."
      });
    }
  }
}
function checkJetBreakBug(content, findings, path) {
  const patterns = [
    /break\s*;?\s*$/m,
    /loop.*break\s*(?!.*return)/i,
    /while.*break.*early/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4334",
        title: "Jet Protocol Break Logic Bug",
        severity: "medium",
        description: `Break statement may cause unintended loop exit. Jet Protocol had a vulnerability from misuse of break that allowed TVL theft.`,
        location: { file: path, line: lineNum },
        recommendation: "Review all break statements for intended behavior. Consider using continue or explicit returns instead."
      });
    }
  }
}
function checkSchrodingersNFT(content, findings, path) {
  const patterns = [
    /nft.*burn.*recreate/i,
    /token.*metadata.*overwrite/i,
    /incinerator.*token/i,
    /burn.*mint.*same.*block/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4335",
        title: "Schrodinger's NFT Incinerator Attack",
        severity: "high",
        description: `NFT burn/recreate pattern may enable exploit chaining. Solens demonstrated combining small exploits for significant impact.`,
        location: { file: path, line: lineNum },
        recommendation: "Prevent same-block burn/recreate. Add delays between destructive and creation operations. Track token lineage."
      });
    }
  }
}
function checkTurbineBug(content, findings, path) {
  const patterns = [
    /shred.*propagation/i,
    /turbine.*repair/i,
    /block.*propagation.*delay/i,
    /validator.*shred/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4336",
        title: "Turbine Block Propagation Vulnerability",
        severity: "info",
        description: `Code related to Turbine/shred propagation. Solana has had multiple Turbine bugs causing network outages.`,
        location: { file: path, line: lineNum },
        recommendation: "Ensure proper shred validation. Handle repair requests correctly. Test propagation edge cases."
      });
    }
  }
}
function checkDurableNonceBug(content, findings, path) {
  const patterns = [
    /durable_nonce/i,
    /nonce_account.*advance/i,
    /nonce.*blockhash/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4337",
        title: "Durable Nonce Usage Pattern",
        severity: "info",
        description: `Durable nonce usage detected. Solana had a durable nonce bug in 2023 that required careful handling.`,
        location: { file: path, line: lineNum },
        recommendation: "Use latest nonce handling patterns. Test nonce advancement edge cases. Handle nonce state transitions properly."
      });
    }
  }
}
function checkJITCacheBug(content, findings, path) {
  const patterns = [
    /jit.*compile/i,
    /program.*cache/i,
    /bpf.*jit/i,
    /executable.*cache/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4338",
        title: "JIT Cache Related Code",
        severity: "info",
        description: `Code related to JIT compilation/caching. Solana's JIT cache bug caused a 5-hour outage in 2024.`,
        location: { file: path, line: lineNum },
        recommendation: "Ensure proper cache invalidation. Handle compilation failures gracefully."
      });
    }
  }
}
function checkELFAlignmentVuln(content, findings, path) {
  const patterns = [
    /elf.*align/i,
    /program.*alignment/i,
    /bpf.*load/i,
    /loader.*elf/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4339",
        title: "ELF Alignment Related Code",
        severity: "info",
        description: `Code related to ELF/program loading. Solana disclosed an ELF address alignment vulnerability in 2024.`,
        location: { file: path, line: lineNum },
        recommendation: "Use proper alignment for ELF sections. Validate program data alignment."
      });
    }
  }
}
function checkParclFrontendAttack(content, findings, path) {
  const patterns = [
    /cdn.*inject/i,
    /frontend.*compromise/i,
    /client.*side.*redirect/i,
    /dns.*hijack/i,
    /script.*src.*external/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4340",
        title: "Parcl-Style Frontend Attack Vector",
        severity: "high",
        description: `Frontend may be vulnerable to injection/compromise. Parcl's frontend was compromised, redirecting users to malicious sites.`,
        location: { file: path, line: lineNum },
        recommendation: "Use CSP headers. Implement SRI for external scripts. Monitor DNS. Use secure build pipelines."
      });
    }
  }
}
function checkKudelskiPatterns(content, findings, path) {
  if (content.includes("AccountInfo") && !content.includes("owner") && !content.includes("Owner")) {
    findings.push({
      id: "SOL4341",
      title: "Kudelski: Missing Ownership Validation",
      severity: "high",
      description: "AccountInfo used without owner validation (Kudelski Security Part 1)",
      location: { file: path },
      recommendation: "Always validate account.owner == expected_program_id"
    });
  }
  if (content.includes("data") && content.includes("borrow") && !content.includes("validate")) {
    findings.push({
      id: "SOL4342",
      title: "Kudelski: Missing Data Validation",
      severity: "medium",
      description: "Account data accessed without validation (Kudelski Security)",
      location: { file: path },
      recommendation: "Validate all account data before use"
    });
  }
}
function checkSec3Patterns(content, findings, path) {
  if ((content.includes("+ ") || content.includes(" +")) && !content.includes("checked_add") && !content.includes("saturating_add") && (content.includes("u64") || content.includes("u128"))) {
    findings.push({
      id: "SOL4351",
      title: "Sec3: Unprotected Arithmetic",
      severity: "high",
      description: "Arithmetic operation without overflow protection (Sec3 Best Practices)",
      location: { file: path },
      recommendation: "Use checked_add(), saturating_add() for all arithmetic"
    });
  }
}
function checkTrailOfBitsPatterns(content, findings, path) {
  if (content.includes("flash") || content.includes("borrow")) {
    if (!content.includes("repay") && !content.includes("return")) {
      findings.push({
        id: "SOL4361",
        title: "Trail of Bits: Flash Loan Protection Missing",
        severity: "high",
        description: "Flash loan/borrow without repayment verification",
        location: { file: path },
        recommendation: "Ensure flash loans are repaid within same transaction"
      });
    }
  }
}
function checkIncidentResponsePatterns(content, findings, path) {
  const patterns = [
    /emergency.*pause\s*(?!.*implemented)/i,
    /circuit.*breaker\s*(?!.*enabled)/i,
    /halt.*mechanism/i,
    /emergency.*shutdown/i
  ];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      const lineNum = content.substring(0, match.index).split("\n").length;
      findings.push({
        id: "SOL4371",
        title: "Emergency Response Mechanism",
        severity: "info",
        description: `Emergency response pattern detected. Best protocols can respond in minutes (Thunder Terminal: 9 min, Banana Gun: minutes).`,
        location: { file: path, line: lineNum },
        recommendation: "Implement pause/halt mechanisms. Set up monitoring alerts. Have incident response runbooks ready."
      });
    }
  }
}
function checkMitigationPatterns(content, findings, path) {
  if (content.includes("insurance") || content.includes("reserve_fund")) {
    findings.push({
      id: "SOL4372",
      title: "Insurance/Reserve Fund Pattern",
      severity: "info",
      description: "Insurance/reserve fund mechanism detected. Critical for user reimbursement after exploits.",
      location: { file: path },
      recommendation: "Maintain adequate insurance reserves. Consider coverage providers."
    });
  }
  if (content.includes("recover") || content.includes("reimburse")) {
    findings.push({
      id: "SOL4373",
      title: "Recovery Mechanism Pattern",
      severity: "info",
      description: "Recovery/reimbursement mechanism detected. Successful protocols like Wormhole, Loopscale recovered 100%.",
      location: { file: path },
      recommendation: "Have clear recovery procedures. Maintain communication channels with security researchers."
    });
  }
}
function checkEmergingThreats(content, findings, path) {
  if (content.includes("ai_agent") || content.includes("automated_action")) {
    findings.push({
      id: "SOL4381",
      title: "2025 Emerging: AI Agent Security",
      severity: "medium",
      description: "AI agent interaction detected. 2025 sees new attack vectors through AI-automated systems.",
      location: { file: path },
      recommendation: "Implement rate limiting. Add human verification for sensitive operations. Monitor automated patterns."
    });
  }
  if (content.includes("token_2022") || content.includes("transfer_hook")) {
    findings.push({
      id: "SOL4382",
      title: "2025 Emerging: Token-2022 Extension Security",
      severity: "medium",
      description: "Token-2022 extension usage detected. Transfer hooks and extensions introduce new attack surfaces.",
      location: { file: path },
      recommendation: "Audit all transfer hooks. Validate extension configurations. Test hook callback security."
    });
  }
}
function checkSecurityBestPractices(content, findings, path) {
  if (content.includes("2fa") || content.includes("two_factor")) {
    findings.push({
      id: "SOL4391",
      title: "Security: 2FA Implementation",
      severity: "info",
      description: "2FA pattern detected. Critical for protecting against insider threats (Pump.fun) and account compromise.",
      location: { file: path },
      recommendation: "Implement 2FA for all admin operations. Use hardware keys where possible."
    });
  }
  if (content.includes("monitor") || content.includes("alert")) {
    findings.push({
      id: "SOL4392",
      title: "Security: Real-time Monitoring",
      severity: "info",
      description: "Monitoring pattern detected. Early detection is key - CertiK and ZachXBT have caught many exploits.",
      location: { file: path },
      recommendation: "Set up transaction monitoring. Use anomaly detection. Join security researcher networks."
    });
  }
  if (content.includes("audit") || content.includes("security_review")) {
    findings.push({
      id: "SOL4393",
      title: "Security: Audit Reference",
      severity: "info",
      description: "Audit reference detected. Regular audits are critical - even audited code can have vulnerabilities (Stake Pool).",
      location: { file: path },
      recommendation: "Get multiple audits. Use automated tools (Sec3, Soteria). Maintain ongoing security reviews."
    });
  }
}
function checkBatch83Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const path = input.path;
  if (!content) return findings;
  checkWormholeSignatureSpoofing(content, findings, path);
  checkCashioInfiniteMint(content, findings, path);
  checkCremaTickSpoofing(content, findings, path);
  checkAudiusGovernanceExploit(content, findings, path);
  checkNirvanaBondingCurve(content, findings, path);
  checkSlopeWalletLeak(content, findings, path);
  checkMangoOracleManipulation(content, findings, path);
  checkOptiFiClosureBug(content, findings, path);
  checkDEXXKeyLeakage(content, findings, path);
  checkThunderTerminalInjection(content, findings, path);
  checkBananaGunBotSecurity(content, findings, path);
  checkPumpFunInsiderThreat(content, findings, path);
  checkLoopscaleRateXExploit(content, findings, path);
  checkCypherInsiderTheft(content, findings, path);
  checkWeb3jsSupplyChain(content, findings, path);
  checkSolendAuthBypass2(content, findings, path);
  checkRaydiumPermitVuln(content, findings, path);
  checkSolareumInfrastructure(content, findings, path);
  checkNoOnesPlatformExploit(content, findings, path);
  checkSynthetifyDAOAttack(content, findings, path);
  checkMissingSignerCheck2(content, findings, path);
  checkMissingOwnerCheck2(content, findings, path);
  checkIntegerOverflow(content, findings, path);
  checkAccountDataMatching2(content, findings, path);
  checkReinitializationAttack(content, findings, path);
  checkDuplicateMutableAccounts(content, findings, path);
  checkTypeCosplayAttack(content, findings, path);
  checkBumpSeedCanonicalization(content, findings, path);
  checkClosingAccountAttack(content, findings, path);
  checkPDASharingAttack(content, findings, path);
  checkSPLLendingRounding(content, findings, path);
  checkLPTokenOracleManipulation(content, findings, path);
  checkCopeRouletteRevert(content, findings, path);
  checkJetBreakBug(content, findings, path);
  checkSchrodingersNFT(content, findings, path);
  checkTurbineBug(content, findings, path);
  checkDurableNonceBug(content, findings, path);
  checkJITCacheBug(content, findings, path);
  checkELFAlignmentVuln(content, findings, path);
  checkParclFrontendAttack(content, findings, path);
  checkKudelskiPatterns(content, findings, path);
  checkSec3Patterns(content, findings, path);
  checkTrailOfBitsPatterns(content, findings, path);
  checkIncidentResponsePatterns(content, findings, path);
  checkMitigationPatterns(content, findings, path);
  checkEmergingThreats(content, findings, path);
  checkSecurityBestPractices(content, findings, path);
  return findings;
}

// src/patterns/solana-batched-patterns-84.ts
function checkFuzzTestingCoverage(content, findings, path) {
  if (content.includes("#[cfg(test)]") && !content.includes("proptest") && !content.includes("fuzz")) {
    findings.push({
      id: "SOL4401",
      title: "Consider Adding Fuzz Testing",
      severity: "info",
      description: "Test module found without fuzz testing. Trident and proptest can catch edge cases unit tests miss.",
      location: { file: path },
      recommendation: "Add Ackee Trident fuzz tests: https://github.com/Ackee-Blockchain/trident"
    });
  }
}
function checkCheckedMathMacro(content, findings, path) {
  if ((content.includes("u64") || content.includes("u128") || content.includes("i64")) && content.match(/[+\-*/]\s*[a-zA-Z_]+/) && !content.includes("checked!") && !content.includes("checked_math")) {
    findings.push({
      id: "SOL4402",
      title: "Use Checked Math Macro",
      severity: "medium",
      description: "Arithmetic without Blockworks checked-math macro. This macro simplifies overflow-safe arithmetic.",
      location: { file: path },
      recommendation: "Use Blockworks checked_math! macro: https://github.com/blockworks-foundation/checked-math"
    });
  }
}
function checkSoteriaPatterns(content, findings, path) {
  const soteriaPatterns = [
    { pattern: /account\.data\.borrow\(\)/, id: "SOL4403", name: "Raw Account Data Access" },
    { pattern: /invoke\s*\([^)]*\)\s*(?!\?)/, id: "SOL4404", name: "Unchecked CPI Result" },
    { pattern: /Pubkey::new_from_array/, id: "SOL4405", name: "Hardcoded Pubkey Construction" }
  ];
  for (const { pattern, id, name } of soteriaPatterns) {
    if (pattern.test(content)) {
      findings.push({
        id,
        title: `Soteria: ${name}`,
        severity: "medium",
        description: `Pattern detected by Soteria automated scanner: ${name}`,
        location: { file: path },
        recommendation: "Run Soteria scan for comprehensive analysis: https://www.sec3.dev"
      });
    }
  }
}
function checkMangoAuditPatterns(content, findings, path) {
  if (content.includes("perp") || content.includes("perpetual")) {
    if (!content.includes("funding_rate")) {
      findings.push({
        id: "SOL4406",
        title: "Mango Audit: Perpetual Funding Rate",
        severity: "medium",
        description: "Perpetual market without explicit funding rate handling. Mango audit emphasized funding rate accuracy.",
        location: { file: path },
        recommendation: "Implement proper funding rate calculations with TWAP oracle prices."
      });
    }
    if (!content.includes("liquidation") && content.includes("position")) {
      findings.push({
        id: "SOL4407",
        title: "Mango Audit: Missing Liquidation Logic",
        severity: "high",
        description: "Perpetual position handling without liquidation logic. Critical for protocol solvency.",
        location: { file: path },
        recommendation: "Implement health factor checks and liquidation mechanisms."
      });
    }
  }
  if (content.includes("oracle") && !content.includes("guardrail") && !content.includes("bounds")) {
    findings.push({
      id: "SOL4408",
      title: "Mango/Drift Audit: Missing Oracle Guardrails",
      severity: "high",
      description: "Oracle usage without guardrails. Drift protocol has example oracle guardrails to prevent manipulation.",
      location: { file: path },
      recommendation: "Add oracle price bounds and staleness checks. See Drift protocol oracle guardrails."
    });
  }
}
function checkMarinadeAuditPatterns(content, findings, path) {
  if (content.includes("stake") && content.includes("liquid")) {
    if (!content.includes("epoch")) {
      findings.push({
        id: "SOL4411",
        title: "Marinade Audit: Epoch Handling",
        severity: "medium",
        description: "Liquid staking without epoch boundary handling. Marinade audit found epoch transition edge cases.",
        location: { file: path },
        recommendation: "Handle epoch boundaries carefully. Test stake/unstake across epoch transitions."
      });
    }
    if (!content.includes("validator") && content.includes("delegate")) {
      findings.push({
        id: "SOL4412",
        title: "Marinade Audit: Validator Selection",
        severity: "medium",
        description: "Stake delegation without validator selection logic. Marinade implements validator scoring.",
        location: { file: path },
        recommendation: "Implement validator selection/scoring for stake distribution."
      });
    }
  }
  if (content.includes("msol") || content.includes("liquid_stake_token")) {
    if (!content.includes("exchange_rate")) {
      findings.push({
        id: "SOL4413",
        title: "Marinade Audit: Exchange Rate Calculation",
        severity: "high",
        description: "Liquid stake token without exchange rate. Critical for accurate mSOL/SOL conversions.",
        location: { file: path },
        recommendation: "Calculate exchange rate as total_stake / total_msol_supply."
      });
    }
  }
}
function checkOrcaAuditPatterns(content, findings, path) {
  if (content.includes("whirlpool") || content.includes("concentrated_liquidity")) {
    if (!content.includes("tick") || !content.includes("position")) {
      findings.push({
        id: "SOL4416",
        title: "Orca Audit: CLMM Tick/Position Handling",
        severity: "high",
        description: "Concentrated liquidity without tick or position handling. Critical CLMM components.",
        location: { file: path },
        recommendation: "Implement proper tick array and position management."
      });
    }
    if (!content.includes("sqrt_price")) {
      findings.push({
        id: "SOL4417",
        title: "Orca Audit: Sqrt Price Calculation",
        severity: "medium",
        description: "CLMM without sqrt price. Orca Whirlpools use sqrt(price) for efficient swap calculations.",
        location: { file: path },
        recommendation: "Use sqrt(price) representation for concentrated liquidity math."
      });
    }
  }
  if (content.includes("lp_token") && content.includes("mint")) {
    if (!content.includes("proportional")) {
      findings.push({
        id: "SOL4418",
        title: "Orca Audit: Proportional LP Minting",
        severity: "medium",
        description: "LP token minting may not be proportional. Orca audit emphasized fair LP distribution.",
        location: { file: path },
        recommendation: "Mint LP tokens proportional to liquidity contribution."
      });
    }
  }
}
function checkDriftAuditPatterns(content, findings, path) {
  if (content.includes("drift") || content.includes("perp") && content.includes("v2")) {
    if (!content.includes("margin") && content.includes("position")) {
      findings.push({
        id: "SOL4421",
        title: "Drift Audit: Margin Requirements",
        severity: "high",
        description: "Perpetual position without margin handling. Drift audit focused on margin calculations.",
        location: { file: path },
        recommendation: "Implement initial and maintenance margin requirements."
      });
    }
    if (content.includes("order") && !content.includes("auction")) {
      findings.push({
        id: "SOL4422",
        title: "Drift Audit: Order Auction Mechanism",
        severity: "medium",
        description: "Orders without auction mechanism. Drift uses auctions for fair price discovery.",
        location: { file: path },
        recommendation: "Consider auction-based order filling for better execution."
      });
    }
  }
  if (content.includes("jit") || content.includes("just_in_time")) {
    if (!content.includes("liquidity")) {
      findings.push({
        id: "SOL4423",
        title: "Drift Audit: JIT Liquidity",
        severity: "medium",
        description: "JIT mechanism without liquidity handling. Drift uses JIT liquidity for fills.",
        location: { file: path },
        recommendation: "Implement JIT liquidity provision properly."
      });
    }
  }
}
function checkPhoenixAuditPatterns(content, findings, path) {
  if (content.includes("order_book") || content.includes("orderbook")) {
    if (!content.includes("seat")) {
      findings.push({
        id: "SOL4426",
        title: "Phoenix Audit: Market Seat System",
        severity: "medium",
        description: "Order book without seat system. Phoenix uses seats for market maker management.",
        location: { file: path },
        recommendation: "Implement seat-based market maker registration."
      });
    }
    if (!content.includes("self_trade")) {
      findings.push({
        id: "SOL4427",
        title: "Phoenix Audit: Self-Trade Prevention",
        severity: "medium",
        description: "Order book without self-trade prevention. Phoenix prevents wash trading.",
        location: { file: path },
        recommendation: "Implement self-trade prevention options (cancel oldest, cancel newest, abort)."
      });
    }
  }
  if (content.includes("match") && content.includes("order")) {
    if (!content.includes("fifo")) {
      findings.push({
        id: "SOL4428",
        title: "Phoenix Audit: FIFO Matching",
        severity: "info",
        description: "Order matching may not be FIFO. Phoenix uses price-time priority.",
        location: { file: path },
        recommendation: "Consider FIFO matching for fair order execution."
      });
    }
  }
}
function checkLendingProtocolPatterns(content, findings, path) {
  if (content.includes("interest") && content.includes("rate")) {
    if (!content.includes("utilization")) {
      findings.push({
        id: "SOL4431",
        title: "Lending: Interest Rate Model",
        severity: "medium",
        description: "Interest rate without utilization-based model. Most lending protocols use kink-based models.",
        location: { file: path },
        recommendation: "Implement utilization-based interest rate with kink point."
      });
    }
  }
  if (content.includes("reserve") && !content.includes("reserve_factor")) {
    findings.push({
      id: "SOL4432",
      title: "Lending: Reserve Factor",
      severity: "low",
      description: "Lending reserve without reserve factor. Important for protocol sustainability.",
      location: { file: path },
      recommendation: "Implement reserve factor to capture protocol revenue."
    });
  }
  if (content.includes("collateral") && !content.includes("collateral_factor") && !content.includes("ltv")) {
    findings.push({
      id: "SOL4433",
      title: "Lending: Missing Collateral Factor",
      severity: "high",
      description: "Collateral handling without explicit collateral factor/LTV. Critical for risk management.",
      location: { file: path },
      recommendation: "Define collateral factors per asset based on volatility and liquidity."
    });
  }
  if (content.includes("liquidation") && !content.includes("bad_debt")) {
    findings.push({
      id: "SOL4434",
      title: "Lending: Bad Debt Handling",
      severity: "medium",
      description: "Liquidation without bad debt handling. Important for protocol solvency.",
      location: { file: path },
      recommendation: "Implement bad debt socialization or insurance fund mechanism."
    });
  }
}
function checkAMMPatterns(content, findings, path) {
  if (content.includes("swap") && content.includes("pool")) {
    if (!content.includes("k") && !content.includes("constant") && !content.includes("invariant")) {
      findings.push({
        id: "SOL4441",
        title: "AMM: Invariant Check",
        severity: "high",
        description: "Swap without invariant/constant product check. Critical for AMM security.",
        location: { file: path },
        recommendation: "Verify constant product invariant: x * y = k (or equivalent)."
      });
    }
  }
  if (content.includes("swap") && !content.includes("fee")) {
    findings.push({
      id: "SOL4442",
      title: "AMM: Swap Fee Missing",
      severity: "medium",
      description: "Swap function without fee handling. Fees incentivize LPs and protocol sustainability.",
      location: { file: path },
      recommendation: "Implement swap fees (typically 0.25-0.30% for regular pools)."
    });
  }
  if (content.includes("pool") && content.includes("deposit")) {
    if (!content.includes("imbalance") && !content.includes("proportional")) {
      findings.push({
        id: "SOL4443",
        title: "AMM: Imbalanced Deposit Protection",
        severity: "medium",
        description: "Pool deposit without imbalance protection. Can lead to manipulation.",
        location: { file: path },
        recommendation: "Require proportional deposits or charge imbalance fees."
      });
    }
  }
  if (content.includes("swap") && !content.includes("price_impact") && !content.includes("slippage")) {
    findings.push({
      id: "SOL4444",
      title: "AMM: Price Impact/Slippage Check",
      severity: "medium",
      description: "Swap without price impact or slippage protection.",
      location: { file: path },
      recommendation: "Add minimum output amount check to protect users from slippage."
    });
  }
}
function checkOptionsPatterns(content, findings, path) {
  if (content.includes("option") && (content.includes("call") || content.includes("put"))) {
    if (!content.includes("strike") || !content.includes("expiry")) {
      findings.push({
        id: "SOL4451",
        title: "Options: Missing Strike/Expiry",
        severity: "high",
        description: "Option contract without strike price or expiry. Core option parameters.",
        location: { file: path },
        recommendation: "Define strike price and expiry timestamp for all options."
      });
    }
    if (!content.includes("premium") && !content.includes("price")) {
      findings.push({
        id: "SOL4452",
        title: "Options: Premium Calculation",
        severity: "high",
        description: "Option without premium/price calculation. Required for fair option trading.",
        location: { file: path },
        recommendation: "Implement Black-Scholes or similar pricing model."
      });
    }
    if (!content.includes("exercise")) {
      findings.push({
        id: "SOL4453",
        title: "Options: Exercise Mechanism",
        severity: "high",
        description: "Option without exercise mechanism. Users need to exercise profitable options.",
        location: { file: path },
        recommendation: "Implement exercise function checking ITM status and transferring assets."
      });
    }
  }
  if (content.includes("option") && !content.includes("volatility") && !content.includes("iv")) {
    findings.push({
      id: "SOL4454",
      title: "Options: Implied Volatility",
      severity: "medium",
      description: "Options trading without implied volatility. Important for pricing accuracy.",
      location: { file: path },
      recommendation: "Incorporate IV into option pricing. Consider historical volatility as baseline."
    });
  }
}
function checkStakingProtocolPatterns(content, findings, path) {
  if (content.includes("stake") && content.includes("reward")) {
    if (!content.includes("claim") && !content.includes("distribute")) {
      findings.push({
        id: "SOL4461",
        title: "Staking: Reward Claim Mechanism",
        severity: "medium",
        description: "Staking rewards without claim mechanism.",
        location: { file: path },
        recommendation: "Implement explicit reward claiming or auto-compound."
      });
    }
    if (!content.includes("reward_per_token") && !content.includes("reward_rate")) {
      findings.push({
        id: "SOL4462",
        title: "Staking: Reward Rate Tracking",
        severity: "medium",
        description: "Staking without reward rate tracking. Use reward-per-token for gas efficiency.",
        location: { file: path },
        recommendation: "Implement reward_per_token pattern for efficient reward distribution."
      });
    }
  }
  if (content.includes("unstake") && !content.includes("cooldown") && !content.includes("unbond")) {
    findings.push({
      id: "SOL4463",
      title: "Staking: Unbonding Period",
      severity: "medium",
      description: "Unstaking without cooldown/unbonding period. Consider adding for security.",
      location: { file: path },
      recommendation: "Implement unbonding period to prevent rapid stake/unstake attacks."
    });
  }
  if (content.includes("stake") && !content.includes("slash")) {
    findings.push({
      id: "SOL4464",
      title: "Staking: Slashing Mechanism",
      severity: "info",
      description: "Staking without slashing mechanism. Consider for validator/operator accountability.",
      location: { file: path },
      recommendation: "Implement slashing for misbehavior if applicable to your staking model."
    });
  }
}
function checkBridgePatterns(content, findings, path) {
  if (content.includes("bridge") || content.includes("cross_chain")) {
    if (!content.includes("guardian") && !content.includes("validator_set") && !content.includes("multisig")) {
      findings.push({
        id: "SOL4471",
        title: "Bridge: Missing Guardian System",
        severity: "critical",
        description: "Bridge without guardian/validator verification. Wormhole uses guardian set.",
        location: { file: path },
        recommendation: "Implement multi-guardian signature verification for cross-chain messages."
      });
    }
    if (!content.includes("sequence") && !content.includes("nonce")) {
      findings.push({
        id: "SOL4472",
        title: "Bridge: Message Sequencing",
        severity: "high",
        description: "Bridge without message sequencing. Prevents replay attacks.",
        location: { file: path },
        recommendation: "Track message sequences to prevent replay attacks."
      });
    }
    if (!content.includes("finality")) {
      findings.push({
        id: "SOL4473",
        title: "Bridge: Finality Handling",
        severity: "high",
        description: "Bridge without finality handling. Critical for preventing double-spends.",
        location: { file: path },
        recommendation: "Wait for source chain finality before processing messages."
      });
    }
  }
  if (content.includes("wrapped") && content.includes("token")) {
    if (!content.includes("burn") || !content.includes("mint")) {
      findings.push({
        id: "SOL4474",
        title: "Bridge: Wrapped Token Mint/Burn",
        severity: "high",
        description: "Wrapped token without proper mint/burn mechanics. Critical for peg maintenance.",
        location: { file: path },
        recommendation: "Implement 1:1 mint/burn with locked collateral on source chain."
      });
    }
  }
}
function checkNFTPatterns(content, findings, path) {
  if (content.includes("nft") || content.includes("metadata")) {
    if (!content.includes("verify_metadata") && !content.includes("metaplex")) {
      findings.push({
        id: "SOL4481",
        title: "NFT: Metadata Validation",
        severity: "medium",
        description: "NFT handling without metadata validation. Use Metaplex standards.",
        location: { file: path },
        recommendation: "Validate NFT metadata using Metaplex token metadata program."
      });
    }
    if (!content.includes("creator") && !content.includes("verified")) {
      findings.push({
        id: "SOL4482",
        title: "NFT: Creator Verification",
        severity: "medium",
        description: "NFT without creator verification. Important for authenticity.",
        location: { file: path },
        recommendation: "Check creator signatures and verification status."
      });
    }
  }
  if (content.includes("collection") && content.includes("nft")) {
    if (!content.includes("collection_authority") && !content.includes("verify_collection")) {
      findings.push({
        id: "SOL4483",
        title: "NFT: Collection Verification",
        severity: "medium",
        description: "NFT collection without verification. Prevents fake collection items.",
        location: { file: path },
        recommendation: "Verify collection membership using Metaplex collection verification."
      });
    }
  }
  if (content.includes("royalt")) {
    if (!content.includes("seller_fee") && !content.includes("royalty_bps")) {
      findings.push({
        id: "SOL4484",
        title: "NFT: Royalty Calculation",
        severity: "medium",
        description: "Royalty handling without proper calculation. Honor creator royalties.",
        location: { file: path },
        recommendation: "Calculate royalties from on-chain metadata seller_fee_basis_points."
      });
    }
  }
}
function checkGovernancePatterns(content, findings, path) {
  if (content.includes("proposal")) {
    if (!content.includes("quorum")) {
      findings.push({
        id: "SOL4491",
        title: "Governance: Missing Quorum",
        severity: "high",
        description: "Governance proposal without quorum requirement. Prevents low-participation attacks.",
        location: { file: path },
        recommendation: "Implement quorum requirement (typically 4-10% of total supply)."
      });
    }
    if (!content.includes("timelock") && !content.includes("delay")) {
      findings.push({
        id: "SOL4492",
        title: "Governance: Missing Timelock",
        severity: "high",
        description: "Governance without execution timelock. Allows users to exit before changes.",
        location: { file: path },
        recommendation: "Implement timelock delay between proposal passing and execution (24-72 hours)."
      });
    }
    if (!content.includes("voting_period") && !content.includes("end_time")) {
      findings.push({
        id: "SOL4493",
        title: "Governance: Voting Period",
        severity: "medium",
        description: "Proposal without defined voting period. Needed for fair participation.",
        location: { file: path },
        recommendation: "Set explicit voting period (typically 3-7 days)."
      });
    }
  }
  if (content.includes("vote") && !content.includes("delegate")) {
    findings.push({
      id: "SOL4494",
      title: "Governance: Vote Delegation",
      severity: "info",
      description: "Voting without delegation support. Enables better participation.",
      location: { file: path },
      recommendation: "Consider adding vote delegation for users who cannot actively participate."
    });
  }
  if (content.includes("vote") && content.includes("balance")) {
    if (!content.includes("snapshot") && !content.includes("checkpoint")) {
      findings.push({
        id: "SOL4495",
        title: "Governance: Vote Snapshot",
        severity: "high",
        description: "Voting using live balance without snapshot. Vulnerable to flash loan attacks.",
        location: { file: path },
        recommendation: "Use balance snapshot at proposal creation to determine voting power."
      });
    }
  }
  if (content.includes("create_proposal") && !content.includes("threshold") && !content.includes("minimum")) {
    findings.push({
      id: "SOL4496",
      title: "Governance: Proposal Threshold",
      severity: "medium",
      description: "Proposal creation without minimum token threshold. Prevents spam.",
      location: { file: path },
      recommendation: "Require minimum token holdings to create proposals (typically 0.5-1% of supply)."
    });
  }
  if (content.includes("governance") && !content.includes("emergency") && !content.includes("guardian")) {
    findings.push({
      id: "SOL4497",
      title: "Governance: Emergency Powers",
      severity: "medium",
      description: "Governance without emergency powers. Needed for rapid response to exploits.",
      location: { file: path },
      recommendation: "Implement guardian role for emergency pause/actions with timelock override."
    });
  }
}
function checkBatch84Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const path = input.path;
  if (!content) return findings;
  checkFuzzTestingCoverage(content, findings, path);
  checkCheckedMathMacro(content, findings, path);
  checkSoteriaPatterns(content, findings, path);
  checkMangoAuditPatterns(content, findings, path);
  checkMarinadeAuditPatterns(content, findings, path);
  checkOrcaAuditPatterns(content, findings, path);
  checkDriftAuditPatterns(content, findings, path);
  checkPhoenixAuditPatterns(content, findings, path);
  checkLendingProtocolPatterns(content, findings, path);
  checkAMMPatterns(content, findings, path);
  checkOptionsPatterns(content, findings, path);
  checkStakingProtocolPatterns(content, findings, path);
  checkBridgePatterns(content, findings, path);
  checkNFTPatterns(content, findings, path);
  checkGovernancePatterns(content, findings, path);
  return findings;
}

// src/patterns/solana-batched-patterns-85.ts
var batch85Patterns = [
  // ===== SEC3 2025 BUSINESS LOGIC PATTERNS (38.5% of all vulns) =====
  {
    id: "SOL4501",
    title: "Protocol State Machine Violation",
    severity: "critical",
    category: "business-logic",
    description: "State machine transitions not properly validated. Sec3 2025: Business logic is 38.5% of all vulnerabilities.",
    detector: /state\s*[=:]\s*(State|Status|Phase|Mode)\s*[^;]*(?!match|if|require)/i,
    recommendation: "Use explicit state machine pattern with exhaustive match statements for all transitions."
  },
  {
    id: "SOL4502",
    title: "Missing Pre-Condition Validation",
    severity: "high",
    category: "business-logic",
    description: "Function lacks pre-condition checks before state mutation. Sec3 2025: Input validation is 25% of issues.",
    detector: /pub\s+fn\s+\w+\([^)]*\)\s*->\s*Result[^{]*\{\s*(?!require|assert|if|let\s+\w+\s*=\s*ctx\.accounts)/,
    recommendation: "Add pre-condition validation at function entry before any state modifications."
  },
  {
    id: "SOL4503",
    title: "Semantic Inconsistency Between Functions",
    severity: "high",
    category: "business-logic",
    description: "Same calculation performed differently across functions (Solana Stake Pool vuln). May lead to arbitrage.",
    detector: /(stake|share|token|rate|price).*calc|calc.*(stake|share|token|rate|price)/i,
    recommendation: "Extract common calculations to shared functions. Ensure semantic consistency across all entry points."
  },
  {
    id: "SOL4504",
    title: "Protocol Invariant Not Enforced",
    severity: "critical",
    category: "business-logic",
    description: "Core protocol invariants (total supply, TVL, ratios) not validated after mutations.",
    detector: /(total_supply|total_value|total_staked|tvl|invariant)\s*[+-=]/i,
    recommendation: "Add invariant checks after every state mutation. Consider using invariant!() macro."
  },
  {
    id: "SOL4505",
    title: "Unidirectional Flow Bypass",
    severity: "high",
    category: "business-logic",
    description: "Protocol allows bidirectional operations where only one direction should be permitted.",
    detector: /(deposit|stake|lock)\s*\([^)]*\)|\.transfer\s*\(/i,
    recommendation: "Enforce unidirectional flows with time locks or admin-only reversal mechanisms."
  },
  // ===== COPE ROULETTE REVERTING TRANSACTION PATTERNS =====
  {
    id: "SOL4506",
    title: "Reverting Transaction Exploitation (Cope Roulette)",
    severity: "critical",
    category: "transaction-security",
    description: "Vulnerable to reverting transaction attacks where attacker can observe outcome and revert unfavorable txns.",
    detector: /rand|random|rng|lottery|raffle|roulette|dice|flip|bet/i,
    recommendation: "Use commit-reveal scheme or VRF (Verifiable Random Function). Never use on-chain randomness that can be front-run."
  },
  {
    id: "SOL4507",
    title: "Outcome-Dependent Branching Exploitable",
    severity: "high",
    category: "transaction-security",
    description: "Transaction outcome determines different paths that attacker can exploit by reverting.",
    detector: /if\s*\([^)]*\)\s*\{[^}]*revert|return\s+Err|panic!/,
    recommendation: "Design atomic operations where partial completion is not beneficial to attacker."
  },
  {
    id: "SOL4508",
    title: "Slot-Based Randomness Manipulation",
    severity: "critical",
    category: "randomness",
    description: "Using slot hash or slot number for randomness. Validators can manipulate or attackers can predict.",
    detector: /slot_hashes|SlotHashes|Clock::get\(\)\.unwrap\(\)\.slot|current_slot/i,
    recommendation: "Use Switchboard VRF or commit-reveal with user-provided entropy combined with block hash."
  },
  // ===== PORT FINANCE MAX WITHDRAW BUG PATTERNS =====
  {
    id: "SOL4509",
    title: "Maximum Withdrawal Calculation Error",
    severity: "critical",
    category: "lending",
    description: "Port Finance bug: max withdrawal calculations may allow draining more than entitled.",
    detector: /max_withdraw|calculate_max|available_to_withdraw|withdrawable/i,
    recommendation: "Use conservative floor() for user withdrawals. Re-validate max after every partial withdrawal."
  },
  {
    id: "SOL4510",
    title: "Collateral Factor Edge Case",
    severity: "high",
    category: "lending",
    description: "Collateral factor calculations at boundaries (0%, 100%) may have unexpected behavior.",
    detector: /collateral_factor|loan_to_value|ltv|health_factor/i,
    recommendation: "Test edge cases at 0%, 100%, and near-boundary values. Add explicit bounds checking."
  },
  {
    id: "SOL4511",
    title: "Iterative Balance Reduction Exploit",
    severity: "critical",
    category: "lending",
    description: "Neodyme lending bug: Repeated small withdrawals accumulate rounding errors draining protocol.",
    detector: /while.*withdraw|loop.*transfer|for.*amount/i,
    recommendation: "Track cumulative withdrawal against original balance. Use checked math with floor for all reductions."
  },
  // ===== JET PROTOCOL BREAK LOGIC BUG =====
  {
    id: "SOL4512",
    title: "Unintended Break Statement in Loop (Jet Bug)",
    severity: "high",
    category: "control-flow",
    description: "Jet Protocol bug: break statement exits loop prematurely, skipping critical validations.",
    detector: /for\s+[^{]*\{[^}]*break[^}]*\}/,
    recommendation: "Review all break/continue statements. Ensure loop invariants are maintained."
  },
  {
    id: "SOL4513",
    title: "Early Return Skipping Cleanup",
    severity: "medium",
    category: "control-flow",
    description: "Early return statements may skip necessary cleanup or state updates.",
    detector: /return\s+Ok\([^)]*\);[^}]*\}/,
    recommendation: "Use RAII pattern or ensure cleanup runs regardless of return path."
  },
  // ===== SEC3 ACCESS CONTROL PATTERNS (19% of vulns) =====
  {
    id: "SOL4514",
    title: "Authority Derivation Without Seeds",
    severity: "critical",
    category: "access-control",
    description: "Authority derived from PDA without proper seeds, allowing impersonation.",
    detector: /authority|admin|owner|governance/i,
    recommendation: "Derive authority PDAs with program_id + unique identifier seeds. Verify derivation on every call."
  },
  {
    id: "SOL4515",
    title: "Privilege Escalation via Delegation Chain",
    severity: "critical",
    category: "access-control",
    description: "Delegation chains can be exploited to escalate privileges. Wormhole signature chain vuln pattern.",
    detector: /delegate|proxy|forward|relay/i,
    recommendation: "Validate entire delegation chain. Prevent circular delegations. Limit delegation depth."
  },
  {
    id: "SOL4516",
    title: "Missing Role-Based Access Control",
    severity: "high",
    category: "access-control",
    description: "Function accessible to all users when it should be role-restricted.",
    detector: /pub\s+fn\s+(admin|governance|emergency|upgrade|migrate|pause)/i,
    recommendation: "Implement RBAC with explicit role checks. Use #[access_control] attribute in Anchor."
  },
  {
    id: "SOL4517",
    title: "Authority Transfer Without Timelock",
    severity: "high",
    category: "access-control",
    description: "Critical authority can be transferred instantly without delay for community review.",
    detector: /set_authority|transfer_authority|update_admin|change_owner/i,
    recommendation: "Implement 2-step transfer with timelock. Emit events for community monitoring."
  },
  // ===== SOLEND MALICIOUS LENDING MARKET PATTERN =====
  {
    id: "SOL4518",
    title: "Fake Lending Market Account (Solend Auth Bypass)",
    severity: "critical",
    category: "account-validation",
    description: "Solend 2021: Attacker creates fake lending market passing it as legitimate to bypass auth checks.",
    detector: /lending_market|market_authority|reserve_authority/i,
    recommendation: "Validate market account is derived from known program. Check all authority chains back to root."
  },
  {
    id: "SOL4519",
    title: "Configurable Parameter Manipulation",
    severity: "high",
    category: "configuration",
    description: "Protocol parameters (thresholds, rates, fees) can be manipulated without proper validation.",
    detector: /update_config|set_fee|set_rate|set_threshold|configure/i,
    recommendation: "Add bounds checking for all configurable parameters. Use timelocks for critical changes."
  },
  // ===== LP TOKEN ORACLE MANIPULATION (OtterSec $200M) =====
  {
    id: "SOL4520",
    title: "LP Token Oracle Manipulation ($200M Risk)",
    severity: "critical",
    category: "oracle",
    description: "OtterSec finding: LP token prices can be manipulated by moving AMM reserves.",
    detector: /lp_token|pool_token|share_token|liquidity_token/i,
    recommendation: "Use fair pricing formula: 2 * sqrt(reserve0 * reserve1) / totalSupply. Never use spot reserves."
  },
  {
    id: "SOL4521",
    title: "Single-Block Price Manipulation",
    severity: "critical",
    category: "oracle",
    description: "Using single-block price for collateral valuation. Can be manipulated within same block.",
    detector: /price\s*=|current_price|get_price/i,
    recommendation: "Use TWAP with minimum window of 10+ minutes. Add price deviation bounds."
  },
  {
    id: "SOL4522",
    title: "Missing Drift Oracle Guardrails",
    severity: "high",
    category: "oracle",
    description: "Drift protocol uses oracle guardrails to prevent manipulation. Pattern for similar implementations.",
    detector: /oracle_price|pyth_price|switchboard/i,
    recommendation: "Implement oracle guardrails: max deviation from TWAP, confidence intervals, staleness checks."
  },
  // ===== SEC3 DATA INTEGRITY PATTERNS (8.9% of vulns) =====
  {
    id: "SOL4523",
    title: "Integer Truncation in Token Decimals",
    severity: "high",
    category: "arithmetic",
    description: "Truncation when converting between tokens with different decimals.",
    detector: /decimals|10_u64\.pow|as\s+u64|as\s+u32/i,
    recommendation: "Always handle decimal conversion explicitly. Use checked multiplication before division."
  },
  {
    id: "SOL4524",
    title: "Rounding Direction Attack",
    severity: "high",
    category: "arithmetic",
    description: "Neodyme $2.6B risk: Rounding in favor of users allows draining via repeated operations.",
    detector: /round|\.div|\/\s*\d+/i,
    recommendation: "Always round against the user (floor for withdrawals, ceil for deposits)."
  },
  {
    id: "SOL4525",
    title: "Precision Loss in Rate Calculations",
    severity: "medium",
    category: "arithmetic",
    description: "Interest rate or exchange rate calculations lose precision over time.",
    detector: /rate|interest|apy|apr|yield/i,
    recommendation: "Use high-precision fixed-point math (e.g., U192). Accumulate rates multiplicatively."
  },
  // ===== CASHIO ROOT OF TRUST PATTERNS =====
  {
    id: "SOL4526",
    title: "Missing Root of Trust (Cashio $52M)",
    severity: "critical",
    category: "account-validation",
    description: "Cashio bug: Failed to validate account chain back to known root, allowing fake collateral.",
    detector: /collateral|backing|reserve|mint/i,
    recommendation: "Establish clear root of trust. Validate entire account derivation chain. Use samczsun pattern."
  },
  {
    id: "SOL4527",
    title: "Saber LP Token Validation Missing",
    severity: "critical",
    category: "account-validation",
    description: "Cashio-specific: Missing validation of saber_swap.arrow mint field.",
    detector: /saber|arrow|lp_mint|pool_mint/i,
    recommendation: "Validate all fields of nested account structures, not just top-level accounts."
  },
  // ===== SEC3 DOS/LIVENESS PATTERNS (8.5% of vulns) =====
  {
    id: "SOL4528",
    title: "Unbounded Iteration DoS",
    severity: "high",
    category: "dos",
    description: "Unbounded iteration over user-controlled data can exhaust compute budget.",
    detector: /for\s+\w+\s+in\s+\w+\.iter\(\)|\.iter\(\)\.enumerate\(\)/,
    recommendation: "Add explicit bounds. Process in batches with continuation token."
  },
  {
    id: "SOL4529",
    title: "Account Dust Attack",
    severity: "medium",
    category: "dos",
    description: "Attacker creates many small accounts to bloat iteration or state.",
    detector: /accounts\.|remaining_accounts|\.len\(\)/i,
    recommendation: "Require minimum account size. Charge creation fees. Limit total account count."
  },
  {
    id: "SOL4530",
    title: "Compute Unit Exhaustion via Complex Calculation",
    severity: "medium",
    category: "dos",
    description: "Complex calculations (sqrt, pow, log) can exhaust compute budget.",
    detector: /sqrt|pow|log|exp|isqrt/i,
    recommendation: "Pre-compute expensive values. Use lookup tables. Profile compute usage."
  },
  // ===== 2026 EMERGING THREAT PATTERNS =====
  {
    id: "SOL4531",
    title: "Simulation-Only Code Path",
    severity: "high",
    category: "simulation-bypass",
    description: "Code that behaves differently in simulation vs execution. Used to hide malicious behavior.",
    detector: /is_simulation|simulate|preflight|skip_preflight/i,
    recommendation: "Never branch on simulation detection. All code paths should be identical."
  },
  {
    id: "SOL4532",
    title: "MEV-Extractable State Transition",
    severity: "high",
    category: "mev",
    description: "State transition that can be profitably front-run by MEV searchers.",
    detector: /liquidate|swap|trade|exchange|settle/i,
    recommendation: "Use Jito bundles for atomicity. Consider commit-reveal for sensitive operations."
  },
  {
    id: "SOL4533",
    title: "Cross-Program State Dependency",
    severity: "medium",
    category: "composability",
    description: "Relying on external program state that may change between transactions.",
    detector: /invoke|invoke_signed|cpi_context/i,
    recommendation: "Validate external state is fresh. Use atomic operations where possible."
  },
  // ===== WORMHOLE GUARDIAN SIGNATURE PATTERNS =====
  {
    id: "SOL4534",
    title: "Signature Verification Delegation Chain",
    severity: "critical",
    category: "signature",
    description: "Wormhole bug: Delegated signature verification can be bypassed if chain is broken.",
    detector: /verify_signatures|guardian|quorum|multisig/i,
    recommendation: "Validate signature verification chain end-to-end. Never trust intermediate verification."
  },
  {
    id: "SOL4535",
    title: "Fake SignatureSet Account",
    severity: "critical",
    category: "account-validation",
    description: "Wormhole pattern: Attacker creates fake SignatureSet account to bypass verification.",
    detector: /signature_set|sig_verify|secp256k1/i,
    recommendation: "Derive SignatureSet PDA from message hash. Validate derivation on use."
  },
  // ===== SYNTHETIFY DAO GOVERNANCE ATTACK =====
  {
    id: "SOL4536",
    title: "Inactive DAO Governance Takeover",
    severity: "high",
    category: "governance",
    description: "Synthetify DAO: Low engagement allows attacker to pass malicious proposals unnoticed.",
    detector: /proposal|vote|quorum|governance/i,
    recommendation: "Require minimum participation. Add notification systems. Implement veto council."
  },
  {
    id: "SOL4537",
    title: "Multi-Proposal Smokescreen Attack",
    severity: "high",
    category: "governance",
    description: "Attacker submits many benign proposals to hide malicious one.",
    detector: /create_proposal|submit_proposal|new_proposal/i,
    recommendation: "Limit proposals per address. Require stake lock. Add mandatory review period."
  },
  // ===== THUNDER TERMINAL MONGODB INJECTION =====
  {
    id: "SOL4538",
    title: "Third-Party Database Injection",
    severity: "critical",
    category: "infrastructure",
    description: "Thunder Terminal: MongoDB connection URL leak allowed unauthorized access.",
    detector: /mongodb|database|connection_url|db_uri/i,
    recommendation: "Never expose database credentials. Use managed secrets. Implement IP allowlisting."
  },
  {
    id: "SOL4539",
    title: "External Service Credential Exposure",
    severity: "critical",
    category: "infrastructure",
    description: "API keys or credentials for external services exposed in code or logs.",
    detector: /api_key|secret_key|access_token|bearer/i,
    recommendation: "Use environment variables. Rotate credentials regularly. Audit access logs."
  },
  // ===== INCINERATOR NFT ATTACK CHAIN =====
  {
    id: "SOL4540",
    title: "NFT Burn Validation Missing",
    severity: "high",
    category: "nft",
    description: "Solens Incinerator: NFT burn operations can be exploited with crafted SPL token program.",
    detector: /burn|incinerate|destroy|close_account/i,
    recommendation: "Validate token program is official SPL Token. Check mint authority."
  },
  {
    id: "SOL4541",
    title: "Exploit Chain Combination",
    severity: "critical",
    category: "exploit-chain",
    description: "Solens Royal Flush: Multiple small vulnerabilities chained for significant exploit.",
    detector: /remaining_accounts|ctx\.accounts|AccountInfo/i,
    recommendation: "Consider exploit chaining during audits. Fix all issues regardless of individual severity."
  },
  // ===== ADVANCED AUDIT PATTERNS =====
  {
    id: "SOL4542",
    title: "Unchecked Account Constraints Missing Documentation",
    severity: "medium",
    category: "anchor",
    description: "Anchor requires UncheckedAccount to have /// CHECK documentation explaining safety.",
    detector: /UncheckedAccount[^/]*(?!\/\/\/\s*CHECK)/,
    recommendation: "Add /// CHECK comment explaining why account is safe. Or use proper account type."
  },
  {
    id: "SOL4543",
    title: "Zero Account Confusion",
    severity: "high",
    category: "anchor",
    description: "Candy Machine bug: Using #[account(zero)] incorrectly vs #[account(init, zero)].",
    detector: /#\[account\(zero\)\]/,
    recommendation: "Use #[account(init, zero)] for new accounts. Understand Anchor account lifecycle."
  },
  {
    id: "SOL4544",
    title: "SPL Token Approval Lingering",
    severity: "medium",
    category: "token",
    description: "Token approval not revoked after use, allowing future unauthorized transfers.",
    detector: /approve|set_authority.*delegate/i,
    recommendation: "Revoke approvals immediately after use. Check approval balances in frontend."
  },
  {
    id: "SOL4545",
    title: "Transaction Simulation Detection",
    severity: "high",
    category: "simulation-bypass",
    description: "Opcodes research: Programs can detect simulation and behave differently.",
    detector: /recent_blockhash|Bank|simulate|preflight/i,
    recommendation: "Audit for simulation detection. Test with randomized blockhashes."
  },
  // ===== KUDELSKI OWNERSHIP CHECK PATTERNS =====
  {
    id: "SOL4546",
    title: "Missing Owner Check on Token Account",
    severity: "critical",
    category: "account-validation",
    description: "Kudelski pattern: Token account owner not verified, allowing spoofed accounts.",
    detector: /token_account|TokenAccount|Account<.*Token>/i,
    recommendation: "Verify token account owner matches expected program (Token Program or Token-2022)."
  },
  {
    id: "SOL4547",
    title: "Missing Data Length Validation",
    severity: "high",
    category: "account-validation",
    description: "Account data length not checked before deserialization.",
    detector: /\.data\.borrow|try_from_slice|deserialize/i,
    recommendation: "Check account data length matches expected struct size before deserialization."
  },
  // ===== NEODYME COMMON PITFALLS =====
  {
    id: "SOL4548",
    title: "Account Confusion Type Mismatch",
    severity: "critical",
    category: "type-safety",
    description: "Neodyme pitfall: Same account type used for different purposes enabling confusion.",
    detector: /AccountInfo|UncheckedAccount/,
    recommendation: "Use Anchor typed accounts. Add 8-byte discriminator. Validate account type on use."
  },
  {
    id: "SOL4549",
    title: "Invoke Signed Seeds Not Verified",
    severity: "critical",
    category: "cpi",
    description: "Neodyme pitfall: invoke_signed seeds not properly constructed or verified.",
    detector: /invoke_signed|seeds\s*=|signer_seeds/i,
    recommendation: "Derive seeds from known inputs. Verify PDA matches expected address."
  },
  {
    id: "SOL4550",
    title: "Missing Signer Verification",
    severity: "critical",
    category: "access-control",
    description: "Neodyme pitfall: Critical operation lacks signer check.",
    detector: /pub\s+fn\s+\w+[^}]*(?!\.is_signer|Signer<)/,
    recommendation: "Add explicit signer checks. Use Anchor Signer<> type for required signers."
  },
  // ===== DRIFT ORACLE GUARDRAILS =====
  {
    id: "SOL4551",
    title: "Missing Oracle Confidence Check",
    severity: "high",
    category: "oracle",
    description: "Drift pattern: Oracle confidence interval not checked, may accept stale/wide prices.",
    detector: /oracle|pyth|switchboard|price_feed/i,
    recommendation: "Check oracle confidence is within acceptable bounds. Reject wide spreads."
  },
  {
    id: "SOL4552",
    title: "Oracle Staleness Not Checked",
    severity: "high",
    category: "oracle",
    description: "Using oracle price without verifying freshness.",
    detector: /publish_time|update_time|last_update|timestamp/i,
    recommendation: "Verify oracle update timestamp is within acceptable staleness window."
  },
  {
    id: "SOL4553",
    title: "Missing TWAP Oracle Fallback",
    severity: "medium",
    category: "oracle",
    description: "No fallback when primary oracle fails or provides invalid data.",
    detector: /get_price|fetch_price|oracle_price/i,
    recommendation: "Implement fallback oracle. Use circuit breaker on oracle failure."
  },
  // ===== 2026 TOKEN-2022 PATTERNS =====
  {
    id: "SOL4554",
    title: "Token-2022 Transfer Hook Not Validated",
    severity: "high",
    category: "token-2022",
    description: "Token-2022 transfer hooks can execute arbitrary code during transfers.",
    detector: /transfer_hook|TransferHook|hook_program/i,
    recommendation: "Validate transfer hook program is trusted. Account for hook compute usage."
  },
  {
    id: "SOL4555",
    title: "Token-2022 Confidential Transfer Misuse",
    severity: "medium",
    category: "token-2022",
    description: "Confidential transfers require special handling for compliance.",
    detector: /confidential_transfer|ConfidentialTransfer|encrypted_balance/i,
    recommendation: "Understand confidential transfer requirements. Implement proper decryption."
  },
  {
    id: "SOL4556",
    title: "Token-2022 Interest Bearing Token Calculation",
    severity: "medium",
    category: "token-2022",
    description: "Interest-bearing tokens require time-adjusted balance calculations.",
    detector: /interest_bearing|InterestBearing|accrued_interest/i,
    recommendation: "Use amount_to_ui_amount for display. Account for interest in all calculations."
  },
  // ===== ZELLIC ANCHOR VULNERABILITY PATTERNS =====
  {
    id: "SOL4557",
    title: "Anchor Init If Needed Race Condition",
    severity: "high",
    category: "anchor",
    description: "Zellic: init_if_needed can cause race conditions in concurrent initialization.",
    detector: /init_if_needed/,
    recommendation: "Prefer separate init instruction. Add explicit initialization state tracking."
  },
  {
    id: "SOL4558",
    title: "Anchor Close Account Destination",
    severity: "high",
    category: "anchor",
    description: "Zellic: Closing account to wrong destination can lose funds.",
    detector: /#\[account\([^)]*close\s*=/,
    recommendation: "Verify close destination is protocol treasury or original depositor."
  },
  {
    id: "SOL4559",
    title: "Anchor Constraint Order Dependency",
    severity: "medium",
    category: "anchor",
    description: "Zellic: Anchor constraint evaluation order may cause unexpected behavior.",
    detector: /#\[account\([^)]*constraint\s*=/,
    recommendation: "Order constraints from least to most expensive. Test constraint combinations."
  },
  {
    id: "SOL4560",
    title: "Anchor Bump Not Canonical",
    severity: "medium",
    category: "anchor",
    description: "Using non-canonical bump allows multiple valid PDAs for same seeds.",
    detector: /bump\s*=\s*[a-zA-Z]/,
    recommendation: "Store and use canonical bump. Use find_program_address once at creation."
  },
  // ===== VIPERS VALIDATION PATTERNS =====
  {
    id: "SOL4561",
    title: "Vipers Assert Keys Equal Missing",
    severity: "high",
    category: "validation",
    description: "Saber Vipers pattern: Key comparison should use constant-time comparison.",
    detector: /==\s*ctx\.accounts\.\w+\.key\(\)|\.key\(\)\s*==/,
    recommendation: "Use vipers::assert_keys_eq! for secure key comparison."
  },
  {
    id: "SOL4562",
    title: "Vipers Unwrap or Err Pattern",
    severity: "medium",
    category: "error-handling",
    description: "Using unwrap() instead of proper error handling.",
    detector: /\.unwrap\(\)(?!\s*;?\s*\/\/\s*safe)/,
    recommendation: "Use vipers::unwrap_or_err! or proper Result propagation."
  },
  // ===== ADDITIONAL SEC3 AUDIT METHODOLOGY PATTERNS =====
  {
    id: "SOL4563",
    title: "Input Account Not In Expected Program",
    severity: "critical",
    category: "account-validation",
    description: "Sec3 methodology: Account owner not verified to be expected program.",
    detector: /AccountInfo|UncheckedAccount/,
    recommendation: "Verify account.owner == expected_program_id for all input accounts."
  },
  {
    id: "SOL4564",
    title: "Writable Account Not Needed",
    severity: "low",
    category: "optimization",
    description: "Account marked writable but not modified, wasting compute.",
    detector: /#\[account\([^)]*mut[^)]*\)]/,
    recommendation: "Remove mut from accounts that are only read. Reduces transaction size."
  },
  {
    id: "SOL4565",
    title: "Remaining Accounts Not Validated",
    severity: "high",
    category: "account-validation",
    description: "ctx.remaining_accounts used without proper validation.",
    detector: /remaining_accounts/,
    recommendation: "Validate each remaining account: owner, type, derivation, and permissions."
  },
  // ===== PENETRATION TESTING PATTERNS =====
  {
    id: "SOL4566",
    title: "PoC Framework Entry Point",
    severity: "info",
    category: "testing",
    description: "Neodyme PoC framework pattern for penetration testing.",
    detector: /Environment|LocalEnvironment|create_accounts_rent_exempt/i,
    recommendation: "Use Neodyme PoC framework for security testing. Document all test cases."
  },
  {
    id: "SOL4567",
    title: "Fuzzing Target Function",
    severity: "info",
    category: "testing",
    description: "Ackee Trident fuzzing target pattern.",
    detector: /fuzz_target|arbitrary|FuzzData/i,
    recommendation: "Implement Trident fuzzing for critical functions. Cover edge cases."
  },
  // ===== SOLANA 2026 RUNTIME PATTERNS =====
  {
    id: "SOL4568",
    title: "Compute Budget Not Requested",
    severity: "low",
    category: "compute",
    description: "Complex transaction may exceed default compute budget.",
    detector: /invoke|cpi|cross_program/i,
    recommendation: "Request appropriate compute budget. Profile compute usage in tests."
  },
  {
    id: "SOL4569",
    title: "Account Reallocation Without Rent Check",
    severity: "medium",
    category: "rent",
    description: "Reallocating account without ensuring rent exemption.",
    detector: /realloc|account_info\.realloc/i,
    recommendation: "Verify account remains rent-exempt after reallocation. Transfer SOL if needed."
  },
  {
    id: "SOL4570",
    title: "Durable Nonce Not Validated",
    severity: "high",
    category: "nonce",
    description: "Durable nonce transaction without proper nonce account validation.",
    detector: /durable_nonce|nonce_account|AdvanceNonceAccount/i,
    recommendation: "Validate nonce authority. Check nonce state before use."
  },
  // ===== FINAL BATCH: COMPREHENSIVE PATTERNS =====
  {
    id: "SOL4571",
    title: "Flash Loan Re-entrancy via CPI",
    severity: "critical",
    category: "reentrancy",
    description: "Flash loan callback can re-enter protocol via CPI.",
    detector: /flash_loan|callback|on_flash_loan/i,
    recommendation: "Use re-entrancy guard. Lock state before flash loan. Validate callback caller."
  },
  {
    id: "SOL4572",
    title: "Cross-Margin Liquidation Cascade",
    severity: "high",
    category: "defi",
    description: "Cross-margin position liquidation can cascade to other positions.",
    detector: /cross_margin|margin_account|liquidation/i,
    recommendation: "Implement circuit breakers. Limit cascade depth. Use isolated margins for risky assets."
  },
  {
    id: "SOL4573",
    title: "Vault Share Inflation Attack",
    severity: "critical",
    category: "vault",
    description: "First depositor can inflate share price to steal from subsequent depositors.",
    detector: /vault|share|deposit.*mint|withdraw.*burn/i,
    recommendation: "Seed vault with initial deposit. Use dead shares pattern. Minimum deposit amount."
  },
  {
    id: "SOL4574",
    title: "Staking Reward Manipulation",
    severity: "high",
    category: "staking",
    description: "Reward calculation can be manipulated by timing stake/unstake.",
    detector: /reward|stake|epoch|claim_rewards/i,
    recommendation: "Lock staking for minimum period. Use weighted average duration."
  },
  {
    id: "SOL4575",
    title: "Bridge Message Replay",
    severity: "critical",
    category: "bridge",
    description: "Cross-chain message can be replayed on same or different chain.",
    detector: /bridge|vaa|message|cross_chain/i,
    recommendation: "Include chain ID in message. Mark messages as processed. Validate sequence numbers."
  },
  {
    id: "SOL4576",
    title: "AMM Constant Product Invariant Violation",
    severity: "critical",
    category: "amm",
    description: "AMM operation violates x*y=k invariant.",
    detector: /constant_product|x_mul_y|k_invariant|swap/i,
    recommendation: "Verify invariant after every swap. Add tolerance for rounding only."
  },
  {
    id: "SOL4577",
    title: "Lending Protocol Utilization Cliff",
    severity: "high",
    category: "lending",
    description: "Interest rate spike at high utilization can cause liquidation cascade.",
    detector: /utilization|interest_rate|borrow_rate/i,
    recommendation: "Use gradual interest rate curves. Add utilization-based borrow limits."
  },
  {
    id: "SOL4578",
    title: "NFT Royalty Bypass",
    severity: "medium",
    category: "nft",
    description: "Metaplex royalty enforcement can be bypassed by direct transfer.",
    detector: /royalty|creator_fee|seller_fee/i,
    recommendation: "Use Metaplex royalty enforcement. Validate in marketplace contracts."
  },
  {
    id: "SOL4579",
    title: "Governance Proposal Spam DoS",
    severity: "medium",
    category: "governance",
    description: "Unlimited proposals can DoS governance by overwhelming voters.",
    detector: /create_proposal|proposal_count/i,
    recommendation: "Require proposal deposit. Limit active proposals per user. Add cooldown."
  },
  {
    id: "SOL4580",
    title: "Token Decimal Mismatch in Multi-Token Operation",
    severity: "high",
    category: "token",
    description: "Operations involving multiple tokens with different decimals.",
    detector: /token_a.*token_b|decimals.*decimals|mint_a.*mint_b/i,
    recommendation: "Normalize all amounts to common base before calculation. Validate decimals."
  },
  {
    id: "SOL4581",
    title: "Program Upgrade Backdoor",
    severity: "critical",
    category: "upgrade",
    description: "Upgradeable program with single-key upgrade authority.",
    detector: /upgrade_authority|BpfLoaderUpgradeable|set_upgrade_authority/i,
    recommendation: "Use multisig for upgrade authority. Add timelock. Consider immutability."
  },
  {
    id: "SOL4582",
    title: "Event Log Manipulation",
    severity: "low",
    category: "events",
    description: "Event logs can be manipulated or missing, affecting indexers.",
    detector: /emit!|msg!|sol_log/i,
    recommendation: "Emit events for all state changes. Include relevant data for reconstruction."
  },
  {
    id: "SOL4583",
    title: "Timestamp Dependency for Critical Logic",
    severity: "medium",
    category: "time",
    description: "Using Clock::get() timestamp for critical business logic.",
    detector: /Clock::get|unix_timestamp|current_time/i,
    recommendation: "Use slots for relative time. Account for timestamp drift. Avoid time-critical thresholds."
  },
  {
    id: "SOL4584",
    title: "PDA Authority Mismatch",
    severity: "critical",
    category: "pda",
    description: "PDA derived with different seeds than expected authority.",
    detector: /seeds|find_program_address|create_program_address/i,
    recommendation: "Document PDA derivation. Verify seeds match expected pattern. Add seed validation."
  },
  {
    id: "SOL4585",
    title: "Batch Operation Partial Failure",
    severity: "medium",
    category: "atomicity",
    description: "Batch operation can partially fail leaving inconsistent state.",
    detector: /batch|bulk|multiple|for.*in.*iter/i,
    recommendation: "Make batches atomic. Track progress for retry. Validate pre-conditions for all items."
  },
  {
    id: "SOL4586",
    title: "Priority Fee Griefing",
    severity: "medium",
    category: "mev",
    description: "Attacker can grief by submitting higher priority fee to block others.",
    detector: /priority_fee|compute_unit_price/i,
    recommendation: "Design for eventual execution. Use time-weighted operations. Add deadline checks."
  },
  {
    id: "SOL4587",
    title: "Account Data Truncation",
    severity: "high",
    category: "serialization",
    description: "Serialized data larger than account allocation causes truncation.",
    detector: /serialize|borsh|pack/i,
    recommendation: "Calculate exact serialization size. Check capacity before write. Use realloc if needed."
  },
  {
    id: "SOL4588",
    title: "Zero Amount Transfer Allowed",
    severity: "low",
    category: "validation",
    description: "Zero amount transfers waste compute and may have unintended effects.",
    detector: /transfer.*amount|amount.*transfer/i,
    recommendation: "Reject zero amount transfers. Add require!(amount > 0) check."
  },
  {
    id: "SOL4589",
    title: "Self-Transfer Handling",
    severity: "medium",
    category: "validation",
    description: "Transfer from account to itself may have unexpected behavior.",
    detector: /from.*to|source.*destination/i,
    recommendation: "Check from != to before transfer. Handle self-transfers explicitly."
  },
  {
    id: "SOL4590",
    title: "Account Close Order Dependency",
    severity: "high",
    category: "close",
    description: "Closing accounts in wrong order can leave orphaned state.",
    detector: /close|close_account|AccountClose/i,
    recommendation: "Close child accounts before parent. Validate no remaining references."
  },
  {
    id: "SOL4591",
    title: "CPI Return Data Not Checked",
    severity: "medium",
    category: "cpi",
    description: "Return data from CPI not validated.",
    detector: /invoke|cpi.*return|get_return_data/i,
    recommendation: "Check CPI return data. Validate expected response format."
  },
  {
    id: "SOL4592",
    title: "Lookup Table Manipulation",
    severity: "high",
    category: "versioned-tx",
    description: "Address lookup table can be modified after transaction creation.",
    detector: /lookup_table|AddressLookupTable|LookupTableAccount/i,
    recommendation: "Validate lookup table state. Use recent lookup table for time-sensitive txns."
  },
  {
    id: "SOL4593",
    title: "Token Freeze Authority Active",
    severity: "info",
    category: "token",
    description: "Token has active freeze authority that could be abused.",
    detector: /freeze_authority|FreezeAccount|can_freeze/i,
    recommendation: "Document freeze authority policy. Consider transferring to null for immutability."
  },
  {
    id: "SOL4594",
    title: "Instruction Data Length Not Checked",
    severity: "high",
    category: "input-validation",
    description: "Instruction data length not validated before parsing.",
    detector: /instruction_data|data\.len\(\)/i,
    recommendation: "Check instruction data length matches expected format before deserialization."
  },
  {
    id: "SOL4595",
    title: "Cross-Instruction State Assumption",
    severity: "medium",
    category: "atomicity",
    description: "Assuming state from previous instruction in same transaction.",
    detector: /instructions_sysvar|load_instruction_at|get_instruction_relative/i,
    recommendation: "Re-validate state at each instruction. Do not assume previous instruction success."
  },
  {
    id: "SOL4596",
    title: "Memo Program Injection",
    severity: "low",
    category: "memo",
    description: "Memo content not validated, could contain malicious data.",
    detector: /memo|MemoProgram|Memo\s/i,
    recommendation: "Do not process memo content as code. Treat as untrusted string."
  },
  {
    id: "SOL4597",
    title: "Associated Token Account Creation Race",
    severity: "medium",
    category: "ata",
    description: "ATA creation can fail if concurrent creation by another party.",
    detector: /get_associated_token_address|create_associated_token_account/i,
    recommendation: "Use create_if_needed pattern. Handle AlreadyInUse error gracefully."
  },
  {
    id: "SOL4598",
    title: "System Program Invoke Confusion",
    severity: "high",
    category: "cpi",
    description: "System program invocation with wrong accounts.",
    detector: /system_program::transfer|SystemInstruction|system_instruction/i,
    recommendation: "Validate system program ID. Check from/to accounts match expected."
  },
  {
    id: "SOL4599",
    title: "Rent Exemption Calculation Stale",
    severity: "low",
    category: "rent",
    description: "Using hardcoded rent values instead of querying sysvar.",
    detector: /LAMPORTS_PER_SOL.*\/\s*\d+|minimum_balance/i,
    recommendation: "Query Rent sysvar for current exemption. Do not hardcode rent values."
  },
  {
    id: "SOL4600",
    title: "Protocol Fee Extraction Vulnerability",
    severity: "high",
    category: "fees",
    description: "Fee calculation or distribution can be manipulated.",
    detector: /protocol_fee|treasury_fee|fee_rate|collect_fee/i,
    recommendation: "Validate fee destinations. Cap fee rates. Use immutable fee parameters where possible."
  }
];
function checkBatch85Patterns(parsed) {
  const findings = [];
  const lines = parsed.content.split("\n");
  for (const pattern of batch85Patterns) {
    for (let i = 0; i < lines.length; i++) {
      if (pattern.detector.test(lines[i])) {
        findings.push({
          id: pattern.id,
          title: pattern.title,
          severity: pattern.severity,
          category: pattern.category,
          description: pattern.description,
          recommendation: pattern.recommendation,
          line: i + 1
        });
      }
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-86.ts
var batch86Patterns = [
  // ===== HELIUS SUPPLY CHAIN ATTACKS =====
  {
    id: "SOL4601",
    title: "Web3.js Supply Chain Attack Pattern",
    severity: "critical",
    category: "supply-chain",
    description: "Helius 2024: @solana/web3.js v1.95.5-1.95.7 contained malicious exfiltration code targeting private keys.",
    detector: /web3\.js|@solana\/web3|solana-web3/i,
    recommendation: "Pin web3.js to audited version (>=1.95.8). Use lockfile. Enable npm audit in CI."
  },
  {
    id: "SOL4602",
    title: "Parcl Frontend Compromise Pattern",
    severity: "critical",
    category: "supply-chain",
    description: "Helius 2024: Parcl frontend hosted malicious code draining wallets via phishing modal.",
    detector: /frontend|react|next|vite|webpack/i,
    recommendation: "Implement CSP headers. Use SRI for CDN scripts. Monitor DOM for injected elements."
  },
  {
    id: "SOL4603",
    title: "NPM Package Typosquatting",
    severity: "high",
    category: "supply-chain",
    description: "Malicious packages with similar names to legitimate Solana packages.",
    detector: /require\(|import\s+.*from\s+['"]/,
    recommendation: "Verify package names. Use npm audit. Check package publishers."
  },
  {
    id: "SOL4604",
    title: "Dependency Confusion Attack",
    severity: "high",
    category: "supply-chain",
    description: "Private package names claimed on public registry with malicious code.",
    detector: /package\.json|Cargo\.toml|dependencies/i,
    recommendation: "Scope private packages. Use registry proxies. Verify package sources."
  },
  {
    id: "SOL4605",
    title: "Build Script Injection",
    severity: "critical",
    category: "supply-chain",
    description: "Malicious code in npm postinstall or cargo build scripts.",
    detector: /postinstall|preinstall|build\.rs|install.*script/i,
    recommendation: "Review install scripts. Use --ignore-scripts in CI. Audit build.rs files."
  },
  {
    id: "SOL4606",
    title: "Compromised Maintainer Account",
    severity: "critical",
    category: "supply-chain",
    description: "Legitimate package updated with malicious code after account compromise.",
    detector: /npm|cargo|crate|package/i,
    recommendation: "Use lockfiles. Pin versions. Monitor package updates. Enable 2FA for npm."
  },
  {
    id: "SOL4607",
    title: "CDN Hijacking Risk",
    severity: "high",
    category: "supply-chain",
    description: "External CDN scripts can be modified if CDN is compromised.",
    detector: /cdn\.|unpkg|jsdelivr|cdnjs/i,
    recommendation: "Use Subresource Integrity (SRI). Self-host critical scripts."
  },
  // ===== HELIUS NETWORK-LEVEL ATTACKS =====
  {
    id: "SOL4608",
    title: "Grape Protocol Network Spam (17hr Outage)",
    severity: "high",
    category: "network",
    description: "Helius 2021: Grape Protocol bot spammed network causing 17-hour outage.",
    detector: /spam|flood|rate_limit|throttle/i,
    recommendation: "Implement rate limiting. Use priority fees. Add backoff mechanisms."
  },
  {
    id: "SOL4609",
    title: "Candy Machine NFT Minting DoS",
    severity: "high",
    category: "network",
    description: "Helius 2022: Mass NFT minting caused network congestion.",
    detector: /mint|nft|candy_machine|metaplex/i,
    recommendation: "Implement minting queues. Use proof-of-humanity. Stagger mint schedules."
  },
  {
    id: "SOL4610",
    title: "Jito DDoS Attack Pattern",
    severity: "high",
    category: "network",
    description: "Helius 2024: DDoS attacks targeted Jito validators.",
    detector: /jito|bundle|tip|block_engine/i,
    recommendation: "Diversify validator connections. Implement fallback MEV providers."
  },
  {
    id: "SOL4611",
    title: "Phantom Wallet DDoS",
    severity: "medium",
    category: "network",
    description: "Helius 2024: Phantom RPC endpoints targeted causing wallet failures.",
    detector: /rpc|endpoint|phantom|wallet_adapter/i,
    recommendation: "Use multiple RPC endpoints. Implement RPC failover. Cache responses."
  },
  {
    id: "SOL4612",
    title: "Validator Concentration Risk",
    severity: "high",
    category: "infrastructure",
    description: "High validator concentration at few hosting providers creates systemic risk.",
    detector: /validator|stake|delegation|infrastructure/i,
    recommendation: "Diversify validator selections. Monitor stake concentration."
  },
  {
    id: "SOL4613",
    title: "Transaction Flood Mitigation",
    severity: "medium",
    category: "network",
    description: "Protocol vulnerable to transaction flooding attacks.",
    detector: /transaction|send_transaction|broadcast/i,
    recommendation: "Implement transaction batching. Use local fee markets. Add congestion detection."
  },
  // ===== HELIUS CORE PROTOCOL VULNERABILITIES =====
  {
    id: "SOL4614",
    title: "Solana Turbine Bug Pattern",
    severity: "critical",
    category: "core-protocol",
    description: "Helius 2022: Turbine propagation bug caused incomplete block transmission.",
    detector: /turbine|shred|propagate|block/i,
    recommendation: "Monitor block propagation. Implement verification for received shreds."
  },
  {
    id: "SOL4615",
    title: "Durable Nonce Bug Pattern",
    severity: "high",
    category: "core-protocol",
    description: "Helius 2023: Durable nonce transactions could be replayed under certain conditions.",
    detector: /durable_nonce|DurableNonce|AdvanceNonce/i,
    recommendation: "Validate nonce freshness. Use unique nonce per transaction."
  },
  {
    id: "SOL4616",
    title: "Duplicate Block Bug Pattern",
    severity: "critical",
    category: "core-protocol",
    description: "Helius 2024: Duplicate block production caused chain split.",
    detector: /block|slot|leader|fork/i,
    recommendation: "Monitor for chain splits. Implement fork resolution in dApp logic."
  },
  {
    id: "SOL4617",
    title: "Turbine Failure Pattern",
    severity: "critical",
    category: "core-protocol",
    description: "Helius 2023: Turbine failure caused network-wide outage.",
    detector: /network|outage|consensus|validator/i,
    recommendation: "Implement graceful degradation. Handle network failures in frontend."
  },
  {
    id: "SOL4618",
    title: "JIT Cache Bug Pattern",
    severity: "critical",
    category: "core-protocol",
    description: "Helius 2024: JIT compilation cache bug allowed code execution manipulation.",
    detector: /jit|cache|compile|bpf/i,
    recommendation: "Stay updated with Solana releases. Monitor for core protocol patches."
  },
  {
    id: "SOL4619",
    title: "ELF Address Alignment Vulnerability",
    severity: "critical",
    category: "core-protocol",
    description: "Helius 2024: ELF address alignment issue could cause memory corruption.",
    detector: /elf|alignment|memory|bpf_loader/i,
    recommendation: "Ensure proper alignment in BPF programs. Test on devnet after updates."
  },
  {
    id: "SOL4620",
    title: "rBPF Integer Overflow",
    severity: "critical",
    category: "core-protocol",
    description: "BlockSec 2022: Integer overflow in Solana rBPF virtual machine.",
    detector: /rbpf|bpf|vm|runtime/i,
    recommendation: "Keep Solana runtime updated. Monitor for rBPF security advisories."
  },
  // ===== INSIDER THREAT PATTERNS =====
  {
    id: "SOL4621",
    title: "Pump.fun Employee Exploit ($1.9M)",
    severity: "critical",
    category: "insider-threat",
    description: "Helius 2024: Employee used privileged access to steal bonding curve funds.",
    detector: /employee|admin|privileged|internal/i,
    recommendation: "Implement multi-sig for sensitive operations. Use timelocks. Audit trail logging."
  },
  {
    id: "SOL4622",
    title: "Cypher Insider Theft ($317K)",
    severity: "critical",
    category: "insider-threat",
    description: "Helius 2024: Core contributor stole from redemption fund.",
    detector: /contributor|team|treasury|redemption/i,
    recommendation: "Segregate duties. Multi-sig treasury. Transparent fund tracking."
  },
  {
    id: "SOL4623",
    title: "Banana Gun Bot Compromise",
    severity: "critical",
    category: "insider-threat",
    description: "Helius 2024: Trading bot infrastructure compromised leaking private keys.",
    detector: /bot|trading|automated|keys/i,
    recommendation: "Secure key storage. Use HSM for hot wallets. Implement key rotation."
  },
  {
    id: "SOL4624",
    title: "DEXX Private Key Exposure ($30M)",
    severity: "critical",
    category: "key-management",
    description: "Helius 2024: Exchange leaked private keys affecting 900 wallets.",
    detector: /private_key|secret_key|keypair/i,
    recommendation: "Never store keys in cleartext. Use secure enclaves. Regular security audits."
  },
  {
    id: "SOL4625",
    title: "Solareum Backend Compromise",
    severity: "critical",
    category: "infrastructure",
    description: "Helius 2024: Backend infrastructure compromised enabling token swap theft.",
    detector: /backend|server|api|infrastructure/i,
    recommendation: "Implement zero-trust architecture. Regular penetration testing."
  },
  // ===== WALLET EXPLOIT PATTERNS =====
  {
    id: "SOL4626",
    title: "Slope Wallet Seed Phrase Leak ($8M)",
    severity: "critical",
    category: "wallet",
    description: "Helius 2022: Mobile wallet transmitted seed phrases to central server.",
    detector: /seed|mnemonic|wallet|mobile/i,
    recommendation: "Never transmit seed phrases. Use secure enclave. Audit wallet code."
  },
  {
    id: "SOL4627",
    title: "Centralized Logging Exposure",
    severity: "critical",
    category: "wallet",
    description: "Sensitive data logged to centralized server enabling theft.",
    detector: /log|logging|telemetry|analytics/i,
    recommendation: "Never log sensitive data. Review logging libraries. Implement PII filtering."
  },
  {
    id: "SOL4628",
    title: "Wallet Approval Persistence",
    severity: "high",
    category: "wallet",
    description: "SPL token approvals persist enabling delayed attacks.",
    detector: /approve|delegation|allowance/i,
    recommendation: "Revoke approvals immediately. Implement approval management UI."
  },
  // ===== PROTOCOL-SPECIFIC EXPLOIT PATTERNS =====
  {
    id: "SOL4629",
    title: "Loopscale RateX Exploit ($5.8M)",
    severity: "critical",
    category: "lending",
    description: "Helius 2025: Undercollateralized loan exploit via pricing manipulation.",
    detector: /rate|lending|borrow|collateral/i,
    recommendation: "Validate collateral ratios. Use oracle price bounds. Add circuit breakers."
  },
  {
    id: "SOL4630",
    title: "NoOnes Platform Bridge Exploit",
    severity: "critical",
    category: "bridge",
    description: "Helius 2025: P2P platform bridge exploited via signature replay.",
    detector: /bridge|p2p|escrow|cross_chain/i,
    recommendation: "Include chain ID in signatures. Implement nonce tracking. Add finality delays."
  },
  {
    id: "SOL4631",
    title: "Aurory SyncSpace State Desync",
    severity: "high",
    category: "gaming",
    description: "Helius 2023: Gaming state synchronization vulnerability.",
    detector: /sync|game|state|multiplayer/i,
    recommendation: "Implement state verification. Use merkle proofs. Add rollback mechanism."
  },
  {
    id: "SOL4632",
    title: "Saga DAO Proposal Attack",
    severity: "high",
    category: "governance",
    description: "Helius 2024: DAO governance proposal manipulation.",
    detector: /dao|proposal|governance|vote/i,
    recommendation: "Add proposal delays. Require quorum. Implement veto mechanism."
  },
  {
    id: "SOL4633",
    title: "io.net Node Credential Leak",
    severity: "critical",
    category: "infrastructure",
    description: "Helius 2024: Distributed compute network node credentials exposed.",
    detector: /node|credential|compute|network/i,
    recommendation: "Rotate credentials regularly. Use short-lived tokens. Implement RBAC."
  },
  // ===== ADVANCED EXPLOIT CHAIN PATTERNS =====
  {
    id: "SOL4634",
    title: "Multi-Protocol Exploit Chain",
    severity: "critical",
    category: "exploit-chain",
    description: "Combining vulnerabilities across multiple protocols for amplified impact.",
    detector: /invoke|cpi|protocol|integration/i,
    recommendation: "Audit all integration points. Implement defense in depth."
  },
  {
    id: "SOL4635",
    title: "Flash Loan + Oracle Combo",
    severity: "critical",
    category: "exploit-chain",
    description: "Flash loan combined with oracle manipulation for price exploitation.",
    detector: /flash|loan|oracle|price/i,
    recommendation: "Use TWAP oracles. Add flash loan detection. Implement price bounds."
  },
  {
    id: "SOL4636",
    title: "Sandwich + Liquidation Combo",
    severity: "high",
    category: "exploit-chain",
    description: "Sandwich attack triggers cascading liquidations for profit.",
    detector: /sandwich|liquidat|front.*run|mev/i,
    recommendation: "Use private mempools. Implement slippage protection. Add liquidation delays."
  },
  {
    id: "SOL4637",
    title: "Governance + Treasury Combo",
    severity: "critical",
    category: "exploit-chain",
    description: "Governance takeover enables treasury drain.",
    detector: /governance|treasury|transfer|withdraw/i,
    recommendation: "Separate governance from treasury. Add timelock on treasury operations."
  },
  // ===== 2026 EMERGING INFRASTRUCTURE THREATS =====
  {
    id: "SOL4638",
    title: "AI Agent Wallet Compromise",
    severity: "critical",
    category: "2026-emerging",
    description: "2026 threat: AI agents with wallet access being manipulated.",
    detector: /agent|ai|autonomous|automated.*wallet/i,
    recommendation: "Limit agent permissions. Use allowlists. Implement human approval for large txns."
  },
  {
    id: "SOL4639",
    title: "LLM Prompt Injection via On-Chain Data",
    severity: "high",
    category: "2026-emerging",
    description: "2026 threat: Malicious on-chain data crafted to exploit AI agents reading it.",
    detector: /prompt|llm|gpt|claude|ai.*read/i,
    recommendation: "Sanitize on-chain data before AI processing. Use structured parsing."
  },
  {
    id: "SOL4640",
    title: "Intent-Based System Manipulation",
    severity: "high",
    category: "2026-emerging",
    description: "2026 threat: Intent-based protocols manipulated via malformed intents.",
    detector: /intent|solver|matcher|auction/i,
    recommendation: "Validate intent structure. Implement solver reputation. Add intent expiry."
  },
  {
    id: "SOL4641",
    title: "Restaking Slashing Attack",
    severity: "high",
    category: "2026-emerging",
    description: "2026 threat: Coordinated slashing attacks on restaking protocols.",
    detector: /restake|slash|avs|operator/i,
    recommendation: "Diversify restaking positions. Monitor slashing events. Implement insurance."
  },
  {
    id: "SOL4642",
    title: "Cross-Chain Intent Manipulation",
    severity: "critical",
    category: "2026-emerging",
    description: "2026 threat: Cross-chain intents manipulated during bridge delays.",
    detector: /cross_chain.*intent|intent.*bridge|multi.*chain/i,
    recommendation: "Lock intent parameters. Add finality checks. Implement timeout handling."
  },
  // ===== PROGRAM UPGRADE SECURITY =====
  {
    id: "SOL4643",
    title: "Upgradeable Program Authority Hijack",
    severity: "critical",
    category: "upgrade",
    description: "Upgrade authority can be hijacked to deploy malicious code.",
    detector: /upgrade_authority|programdata|BpfLoaderUpgradeable/i,
    recommendation: "Use multi-sig for upgrade authority. Implement timelock. Consider immutability."
  },
  {
    id: "SOL4644",
    title: "Program Data Account Manipulation",
    severity: "high",
    category: "upgrade",
    description: "Program data account can be modified to inject malicious bytecode.",
    detector: /program_data|ProgramData|executable/i,
    recommendation: "Verify program data account ownership. Use official loader."
  },
  {
    id: "SOL4645",
    title: "Buffer Account Injection",
    severity: "critical",
    category: "upgrade",
    description: "Malicious buffer account used in program upgrade.",
    detector: /buffer|deploy|upgrade.*buffer/i,
    recommendation: "Verify buffer contents before upgrade. Use deterministic builds."
  },
  // ===== ACCOUNT LIFECYCLE PATTERNS =====
  {
    id: "SOL4646",
    title: "Account Revival After Close (Wormhole Pattern)",
    severity: "critical",
    category: "account-lifecycle",
    description: "Closed account can be recreated with different data in same transaction.",
    detector: /close|close_account|transfer_lamports.*close/i,
    recommendation: "Use try_borrow_mut_data pattern. Verify account not reused."
  },
  {
    id: "SOL4647",
    title: "Account Resurrection Attack",
    severity: "high",
    category: "account-lifecycle",
    description: "Account closed and recreated with malicious data.",
    detector: /realloc|resize|close.*init/i,
    recommendation: "Track account state. Use monotonic counters. Verify discriminator."
  },
  {
    id: "SOL4648",
    title: "Rent Drain via Account Closure",
    severity: "medium",
    category: "account-lifecycle",
    description: "Account closed to drain rent to attacker address.",
    detector: /close.*destination|close.*to/i,
    recommendation: "Verify close destination is protocol-controlled or original owner."
  },
  // ===== SERIALIZATION SECURITY =====
  {
    id: "SOL4649",
    title: "Borsh Deserialization Overflow",
    severity: "high",
    category: "serialization",
    description: "Borsh deserialization can fail silently on malformed data.",
    detector: /try_from_slice|BorshDeserialize|deserialize/i,
    recommendation: "Validate data length before deserialization. Handle errors explicitly."
  },
  {
    id: "SOL4650",
    title: "Zero Copy Memory Safety",
    severity: "high",
    category: "serialization",
    description: "Zero copy deserialization may access uninitialized memory.",
    detector: /zero_copy|AccountLoader|RefMut/i,
    recommendation: "Validate account data length. Check discriminator before access."
  },
  {
    id: "SOL4651",
    title: "String Length Attack",
    severity: "medium",
    category: "serialization",
    description: "Unbounded string length in serialization can exhaust memory.",
    detector: /String|str.*len|serialize.*string/i,
    recommendation: "Add length limits on strings. Validate before deserialization."
  },
  // ===== COMPOSABILITY SECURITY =====
  {
    id: "SOL4652",
    title: "Composability Reentrancy via Hook",
    severity: "critical",
    category: "composability",
    description: "Protocol hooks can reenter calling contract.",
    detector: /hook|callback|on_.*event/i,
    recommendation: "Use reentrancy guards. Complete state changes before hooks."
  },
  {
    id: "SOL4653",
    title: "Cross-Protocol State Inconsistency",
    severity: "high",
    category: "composability",
    description: "State may be inconsistent between composed protocols.",
    detector: /invoke.*invoke|cpi.*cpi|protocol.*protocol/i,
    recommendation: "Validate state after each CPI. Use atomic patterns."
  },
  {
    id: "SOL4654",
    title: "Permission Inheritance Attack",
    severity: "high",
    category: "composability",
    description: "Composed protocol inherits excessive permissions.",
    detector: /signer_seeds|invoke_signed.*authority/i,
    recommendation: "Minimize delegated permissions. Validate authority scope."
  },
  // ===== MEV AND ORDERING PATTERNS =====
  {
    id: "SOL4655",
    title: "JIT Liquidity Front-Running",
    severity: "high",
    category: "mev",
    description: "Just-in-time liquidity provision to extract value from trades.",
    detector: /liquidity|provision|jit|just.*time/i,
    recommendation: "Implement minimum liquidity duration. Use time-weighted fees."
  },
  {
    id: "SOL4656",
    title: "Backrun Arbitrage Extraction",
    severity: "medium",
    category: "mev",
    description: "Transactions backrun to extract arbitrage from price impact.",
    detector: /arbitrage|price.*impact|swap.*fee/i,
    recommendation: "Implement MEV-share. Return excess value to users."
  },
  {
    id: "SOL4657",
    title: "Bundle Inclusion Censorship",
    severity: "high",
    category: "mev",
    description: "Jito bundles can censor specific transactions.",
    detector: /bundle|jito|tip|searcher/i,
    recommendation: "Support multiple bundle providers. Implement fallback submission."
  },
  // ===== TOKEN SECURITY PATTERNS =====
  {
    id: "SOL4658",
    title: "Mint Authority Not Revoked",
    severity: "medium",
    category: "token",
    description: "Token mint authority still active enabling inflation.",
    detector: /mint_authority|SetAuthority|MintTo/i,
    recommendation: "Revoke mint authority after initial distribution. Or use multisig."
  },
  {
    id: "SOL4659",
    title: "Token-2022 Permanent Delegate Risk",
    severity: "high",
    category: "token-2022",
    description: "Permanent delegate can transfer tokens without owner approval.",
    detector: /permanent_delegate|PermanentDelegate/i,
    recommendation: "Document delegate usage. Warn users of permanent delegate tokens."
  },
  {
    id: "SOL4660",
    title: "Transfer Fee Bypass",
    severity: "medium",
    category: "token-2022",
    description: "Token-2022 transfer fees can be bypassed via certain operations.",
    detector: /transfer_fee|TransferFee|fee_config/i,
    recommendation: "Validate fees collected. Test fee enforcement edge cases."
  },
  // ===== ORACLE DEEP PATTERNS =====
  {
    id: "SOL4661",
    title: "Pyth Price Confidence Too Wide",
    severity: "high",
    category: "oracle",
    description: "Pyth price confidence interval too wide for precise operations.",
    detector: /pyth|conf|confidence|price_feed/i,
    recommendation: "Check confidence is within acceptable bounds. Reject wide spreads."
  },
  {
    id: "SOL4662",
    title: "Switchboard Aggregator Manipulation",
    severity: "high",
    category: "oracle",
    description: "Switchboard aggregator can be manipulated if not enough oracles.",
    detector: /switchboard|aggregator|oracle_queue/i,
    recommendation: "Require minimum oracles. Check oracle count. Add deviation bounds."
  },
  {
    id: "SOL4663",
    title: "Oracle Price Deviation Attack",
    severity: "critical",
    category: "oracle",
    description: "Large price deviation exploited before oracle update.",
    detector: /price.*deviation|max.*deviation|price.*diff/i,
    recommendation: "Implement price deviation limits. Add circuit breakers."
  },
  {
    id: "SOL4664",
    title: "Missing Oracle Heartbeat Check",
    severity: "high",
    category: "oracle",
    description: "No verification that oracle is actively updating.",
    detector: /oracle|price_feed|last_update/i,
    recommendation: "Verify oracle has updated within acceptable window."
  },
  // ===== LENDING PROTOCOL PATTERNS =====
  {
    id: "SOL4665",
    title: "Interest Accrual Rounding Abuse",
    severity: "high",
    category: "lending",
    description: "Interest accrual rounding can be exploited with small positions.",
    detector: /interest|accrue|compound|rate/i,
    recommendation: "Use high-precision math. Round against user. Add minimum position size."
  },
  {
    id: "SOL4666",
    title: "Liquidation Bonus Extraction",
    severity: "high",
    category: "lending",
    description: "Self-liquidation to extract liquidation bonus.",
    detector: /liquidat|bonus|close_factor/i,
    recommendation: "Prevent self-liquidation. Cap liquidation bonus. Add delay."
  },
  {
    id: "SOL4667",
    title: "Reserve Factor Manipulation",
    severity: "medium",
    category: "lending",
    description: "Reserve factor changes can affect existing positions unfairly.",
    detector: /reserve_factor|protocol_fee|interest_rate_model/i,
    recommendation: "Timelock reserve factor changes. Grandfather existing positions."
  },
  // ===== AMM SECURITY PATTERNS =====
  {
    id: "SOL4668",
    title: "Concentrated Liquidity Tick Manipulation",
    severity: "high",
    category: "amm",
    description: "CLMM tick accounts can be manipulated (Crema pattern).",
    detector: /tick|concentrated|clmm|position/i,
    recommendation: "Validate tick account derivation. Check tick initialization."
  },
  {
    id: "SOL4669",
    title: "Impermanent Loss Exploitation",
    severity: "medium",
    category: "amm",
    description: "Strategies to maximize IL for LP providers.",
    detector: /impermanent|liquidity.*provider|lp.*loss/i,
    recommendation: "Implement IL protection. Use dynamic fees. Add position limits."
  },
  {
    id: "SOL4670",
    title: "Virtual Reserve Manipulation",
    severity: "high",
    category: "amm",
    description: "Virtual reserves can diverge from actual balances.",
    detector: /virtual|reserve|balance/i,
    recommendation: "Validate virtual reserves against actual balances."
  },
  // ===== GOVERNANCE DEEP PATTERNS =====
  {
    id: "SOL4671",
    title: "Proposal Execution Delay Bypass",
    severity: "critical",
    category: "governance",
    description: "Proposal executed before timelock expires.",
    detector: /timelock|delay|execution.*time/i,
    recommendation: "Enforce timelock in smart contract. Check block time."
  },
  {
    id: "SOL4672",
    title: "Quorum Flash Loan Attack",
    severity: "critical",
    category: "governance",
    description: "Flash loan tokens used to meet quorum and pass proposal.",
    detector: /quorum|vote.*power|governance.*token/i,
    recommendation: "Snapshot voting power before proposal. Add vote lockup."
  },
  {
    id: "SOL4673",
    title: "Vote Buying via Delegate",
    severity: "high",
    category: "governance",
    description: "Delegated voting power bought or manipulated.",
    detector: /delegate|voting.*delegate|delegate.*vote/i,
    recommendation: "Track delegation changes. Add delegation lockup."
  },
  // ===== STAKING SECURITY PATTERNS =====
  {
    id: "SOL4674",
    title: "Epoch Boundary Reward Manipulation",
    severity: "high",
    category: "staking",
    description: "Staking/unstaking at epoch boundaries to maximize rewards.",
    detector: /epoch|stake.*reward|reward.*rate/i,
    recommendation: "Use time-weighted staking. Add minimum stake duration."
  },
  {
    id: "SOL4675",
    title: "Unbonding Period Bypass",
    severity: "high",
    category: "staking",
    description: "Unbonding period can be bypassed via secondary market.",
    detector: /unbond|cooldown|withdrawal.*delay/i,
    recommendation: "Make stake tokens non-transferable during unbonding."
  },
  {
    id: "SOL4676",
    title: "Slashing Condition Exploitation",
    severity: "critical",
    category: "staking",
    description: "Attacker triggers slashing condition for competitor.",
    detector: /slash|penalty|misbehavior/i,
    recommendation: "Require proof of misbehavior. Add appeal period."
  },
  // ===== NFT SECURITY PATTERNS =====
  {
    id: "SOL4677",
    title: "NFT Metadata Manipulation",
    severity: "medium",
    category: "nft",
    description: "NFT metadata can be changed after sale.",
    detector: /metadata|uri|update.*metadata/i,
    recommendation: "Make metadata immutable. Or clearly disclose mutability."
  },
  {
    id: "SOL4678",
    title: "Edition Supply Manipulation",
    severity: "high",
    category: "nft",
    description: "NFT edition supply can be increased after initial sale.",
    detector: /edition|supply|max_supply|print/i,
    recommendation: "Lock supply after initial mint. Burn supply authority."
  },
  {
    id: "SOL4679",
    title: "Merkle Tree Proof Manipulation (cNFT)",
    severity: "high",
    category: "nft",
    description: "Compressed NFT merkle proofs can be manipulated.",
    detector: /merkle|proof|compressed|bubblegum/i,
    recommendation: "Verify proof against on-chain root. Use official Bubblegum program."
  },
  // ===== BRIDGE SECURITY PATTERNS =====
  {
    id: "SOL4680",
    title: "Guardian Set Update Attack",
    severity: "critical",
    category: "bridge",
    description: "Guardian set update allows malicious guardians.",
    detector: /guardian|guardian_set|update.*guardian/i,
    recommendation: "Require super-majority for guardian changes. Add timelock."
  },
  {
    id: "SOL4681",
    title: "VAA Replay Across Chains",
    severity: "critical",
    category: "bridge",
    description: "Verified Action Approval replayed on multiple chains.",
    detector: /vaa|message.*hash|cross_chain.*message/i,
    recommendation: "Include target chain in VAA. Mark as processed per-chain."
  },
  {
    id: "SOL4682",
    title: "Bridge Finality Assumption",
    severity: "high",
    category: "bridge",
    description: "Bridge releases assets before source chain finality.",
    detector: /finality|confirmation|block.*confirm/i,
    recommendation: "Wait for sufficient confirmations. Implement challenge period."
  },
  // ===== ERROR HANDLING PATTERNS =====
  {
    id: "SOL4683",
    title: "Silent Error Swallowing",
    severity: "high",
    category: "error-handling",
    description: "Errors caught and ignored can hide critical failures.",
    detector: /catch|ok\(\)|unwrap_or|or_else/i,
    recommendation: "Log all errors. Propagate critical errors. Audit error handling."
  },
  {
    id: "SOL4684",
    title: "Panic in Production Code",
    severity: "medium",
    category: "error-handling",
    description: "Panic can cause transaction to fail unexpectedly.",
    detector: /panic!|unwrap\(\)|expect\(/,
    recommendation: "Use Result types. Add proper error handling. Avoid unwrap."
  },
  {
    id: "SOL4685",
    title: "Error Code Information Leak",
    severity: "low",
    category: "error-handling",
    description: "Detailed error codes leak protocol internals.",
    detector: /ErrorCode|custom_error|error.*msg/i,
    recommendation: "Use generic error messages for users. Log details internally."
  },
  // ===== TESTING AND VERIFICATION PATTERNS =====
  {
    id: "SOL4686",
    title: "Missing Edge Case Test",
    severity: "info",
    category: "testing",
    description: "Critical edge cases may not be tested.",
    detector: /test|#\[cfg\(test\)\]|mod\s+tests/i,
    recommendation: "Add tests for: zero amounts, max values, empty arrays, boundary conditions."
  },
  {
    id: "SOL4687",
    title: "Insufficient Fuzzing Coverage",
    severity: "info",
    category: "testing",
    description: "Fuzzing may not cover all code paths.",
    detector: /fuzz|arbitrary|proptest/i,
    recommendation: "Use Trident fuzzer. Cover all instruction handlers."
  },
  {
    id: "SOL4688",
    title: "Mock vs Production Discrepancy",
    severity: "medium",
    category: "testing",
    description: "Test mocks may not accurately represent production.",
    detector: /mock|stub|fake|test.*only/i,
    recommendation: "Test against localnet. Verify mocks match production behavior."
  },
  // ===== FINAL COMPREHENSIVE PATTERNS =====
  {
    id: "SOL4689",
    title: "Account Array Index Out of Bounds",
    severity: "high",
    category: "memory-safety",
    description: "Accessing account array without bounds checking.",
    detector: /accounts\[|remaining_accounts\[|ctx\.accounts/i,
    recommendation: "Check array length before access. Use get() with Option handling."
  },
  {
    id: "SOL4690",
    title: "Instruction Data Parsing Overflow",
    severity: "high",
    category: "input-validation",
    description: "Instruction data parsed without length validation.",
    detector: /instruction_data|data\[|from_bytes/i,
    recommendation: "Validate instruction data length. Use safe parsing."
  },
  {
    id: "SOL4691",
    title: "Cross-Program Return Data Trust",
    severity: "high",
    category: "cpi",
    description: "Trusting return data from external program without validation.",
    detector: /get_return_data|return_data|sol_get_return/i,
    recommendation: "Validate return data source. Check expected format."
  },
  {
    id: "SOL4692",
    title: "Program Derived Address Collision",
    severity: "critical",
    category: "pda",
    description: "PDA seeds can collide with another valid derivation.",
    detector: /seeds|find_program_address|create_program_address/i,
    recommendation: "Use unique prefixes in seeds. Include discriminator."
  },
  {
    id: "SOL4693",
    title: "Authority Not Derived from State",
    severity: "high",
    category: "access-control",
    description: "Authority passed as input instead of derived from state.",
    detector: /authority|admin|owner/i,
    recommendation: "Derive authority from on-chain state. Verify derivation."
  },
  {
    id: "SOL4694",
    title: "Missing Discriminator Validation",
    severity: "critical",
    category: "account-validation",
    description: "Account discriminator not checked allowing type confusion.",
    detector: /AccountInfo|UncheckedAccount|try_from_slice/i,
    recommendation: "Validate 8-byte discriminator. Use Anchor account types."
  },
  {
    id: "SOL4695",
    title: "Token Account Authority Mismatch",
    severity: "critical",
    category: "token",
    description: "Token account authority does not match expected.",
    detector: /token_account|authority|owner/i,
    recommendation: "Verify token account authority matches expected."
  },
  {
    id: "SOL4696",
    title: "Compute Unit Limit Exceeded",
    severity: "medium",
    category: "compute",
    description: "Transaction may exceed compute unit limit.",
    detector: /for\s+.*in|while\s+|loop|invoke|cpi/i,
    recommendation: "Profile compute usage. Batch operations. Request higher CU limit."
  },
  {
    id: "SOL4697",
    title: "Program Log Sensitive Data",
    severity: "medium",
    category: "privacy",
    description: "Program logs may expose sensitive information.",
    detector: /msg!|sol_log|emit!/i,
    recommendation: "Review log contents. Avoid logging sensitive data."
  },
  {
    id: "SOL4698",
    title: "Clock Sysvar Manipulation",
    severity: "medium",
    category: "time",
    description: "Clock sysvar timestamp can have slight variations.",
    detector: /Clock|unix_timestamp|slot/i,
    recommendation: "Use slot for relative time. Add tolerance for timestamps."
  },
  {
    id: "SOL4699",
    title: "Rent Collection Attack",
    severity: "medium",
    category: "rent",
    description: "Account rent can be collected causing unexpected closure.",
    detector: /rent|lamports|minimum_balance/i,
    recommendation: "Keep accounts rent-exempt. Monitor lamport balance."
  },
  {
    id: "SOL4700",
    title: "System Program Confusion",
    severity: "high",
    category: "cpi",
    description: "System program ID not validated in CPI.",
    detector: /system_program|SystemProgram|system_instruction/i,
    recommendation: "Verify system program ID equals system_program::id()."
  }
];
function checkBatch86Patterns(parsed) {
  const findings = [];
  const lines = parsed.content.split("\n");
  for (const pattern of batch86Patterns) {
    for (let i = 0; i < lines.length; i++) {
      if (pattern.detector.test(lines[i])) {
        findings.push({
          id: pattern.id,
          title: pattern.title,
          severity: pattern.severity,
          category: pattern.category,
          description: pattern.description,
          recommendation: pattern.recommendation,
          line: i + 1
        });
      }
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-87.ts
function checkBatch87Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const lines = content.split("\n");
  if (/verify_signature|signature_set|guardian/.test(content) && !/verify_valid_signature_set|check_guardian_set/.test(content)) {
    const lineNum = lines.findIndex((l) => /verify_signature|guardian/.test(l));
    findings.push({
      id: "SOL4701",
      title: "Wormhole-Style Guardian Verification Bypass",
      severity: "critical",
      description: "Signature or guardian verification without proper set validation. The Wormhole exploit ($326M) used a forged signature to bypass Guardian validation and mint unauthorized tokens.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify guardian set membership, check signature count against quorum, validate signer authority against stored guardian keys."
    });
  }
  if (/collateral|mint_to|burn/.test(content) && /saber|arrow|lp_token/.test(content) && !/validate_collateral_mint|verify_mint_authority/.test(content)) {
    const lineNum = lines.findIndex((l) => /collateral|saber|arrow/.test(l));
    findings.push({
      id: "SOL4702",
      title: "Cashio-Style Collateral Validation Bypass",
      severity: "critical",
      description: "Collateral validation may be bypassable with fake accounts. The Cashio exploit ($52.8M) used fake LP tokens to mint 2 billion CASH tokens.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate collateral mint address matches expected token, verify LP token authority, establish root of trust for all input accounts."
    });
  }
  if (/tick|tick_account|clmm|concentrated_liquidity/.test(content) && !/verify_tick_owner|check_tick_account_owner/.test(content)) {
    const lineNum = lines.findIndex((l) => /tick|clmm/.test(l));
    findings.push({
      id: "SOL4703",
      title: "Crema-Style Tick Account Spoofing",
      severity: "critical",
      description: "CLMM tick accounts without owner verification can be spoofed. The Crema exploit ($8.8M) used fake tick accounts to claim excessive fees.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify tick account owner matches pool program, validate tick data integrity, use PDA derivation for tick accounts."
    });
  }
  if (/governance|proposal|execute|treasury/.test(content) && !/validate_proposal_signature|check_timelock|verify_quorum/.test(content)) {
    const lineNum = lines.findIndex((l) => /governance|proposal|treasury/.test(l));
    findings.push({
      id: "SOL4704",
      title: "Audius-Style Governance Proposal Injection",
      severity: "critical",
      description: "Governance without proper proposal validation. The Audius exploit ($6.1M) allowed malicious proposals to reconfigure treasury permissions.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement timelock for governance actions, require quorum validation, add proposal signature verification."
    });
  }
  if (/bonding_curve|mint_price|buy_price|ana_token/.test(content) && /flash_loan|borrow/.test(content)) {
    const lineNum = lines.findIndex((l) => /bonding_curve|mint_price/.test(l));
    findings.push({
      id: "SOL4705",
      title: "Nirvana-Style Bonding Curve Flash Loan Attack",
      severity: "critical",
      description: "Bonding curve vulnerable to flash loan manipulation. The Nirvana exploit ($3.5M) used flash loans to manipulate token prices and mint at inflated rates.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add flash loan guards (no borrow+mint in same tx), use TWAPs for pricing, implement circuit breakers for price spikes."
    });
  }
  if (/oracle|spot_price|mark_price|pyth|switchboard/.test(content) && /collateral|borrow|margin/.test(content) && !/oracle_confidence|price_band|twap_guard/.test(content)) {
    const lineNum = lines.findIndex((l) => /oracle|spot_price|margin/.test(l));
    findings.push({
      id: "SOL4706",
      title: "Mango-Style Oracle Price Manipulation",
      severity: "critical",
      description: "Oracle price used for collateral/borrowing without manipulation guards. The Mango exploit ($116M) manipulated spot prices to inflate collateral value.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use TWAP oracles, add price confidence checks, implement position limits, use multiple oracle sources."
    });
  }
  if (/seed_phrase|mnemonic|private_key|keypair/.test(content) && /http|server|api|log|sentry/.test(content)) {
    const lineNum = lines.findIndex((l) => /seed_phrase|mnemonic|private_key/.test(l));
    findings.push({
      id: "SOL4707",
      title: "Slope-Style Private Key Exposure",
      severity: "critical",
      description: "Private key material may be sent to external services. The Slope wallet exploit ($8M) leaked seed phrases to centralized servers.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Never transmit seed phrases or private keys, use client-side encryption only, audit all logging and analytics code."
    });
  }
  if (/hot_wallet|wallet_key|signing_key/.test(content) && !/hardware_signer|multisig|threshold_signature/.test(content)) {
    const lineNum = lines.findIndex((l) => /hot_wallet|wallet_key/.test(l));
    findings.push({
      id: "SOL4708",
      title: "DEXX-Style Hot Wallet Key Leak",
      severity: "critical",
      description: "Hot wallet without proper key isolation. The DEXX exploit ($30M) involved leaked private keys from inadequate key management.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use HSMs or hardware signers, implement multisig for hot wallets, rotate keys regularly, minimize hot wallet balances."
    });
  }
  if (/admin_key|authority|owner|upgrade_authority/.test(content) && !/multisig|timelock|guardian_set/.test(content)) {
    const lineNum = lines.findIndex((l) => /admin_key|authority|upgrade/.test(l));
    findings.push({
      id: "SOL4709",
      title: "Raydium-Style Authority Compromise",
      severity: "high",
      description: "Single authority without multisig protection. The Raydium exploit ($4.4M) involved compromised admin keys draining pool funds.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use multisig for admin operations, implement timelocks, consider decentralizing authority."
    });
  }
  if (/close_program|close_account|lamports\s*=\s*0/.test(content) && !/verify_close_authority|check_remaining_funds/.test(content)) {
    const lineNum = lines.findIndex((l) => /close_program|close_account/.test(l));
    findings.push({
      id: "SOL4710",
      title: "OptiFi-Style Permanent Fund Lockup",
      severity: "high",
      description: "Program closure without proper fund recovery check. OptiFi accidentally locked $661K by calling close_program() on the wrong account.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Require all funds withdrawn before closing, add balance checks, implement recovery mechanisms."
    });
  }
  if (/random|rng|roulette|lottery|gambling/.test(content) && /invoke|cpi/.test(content)) {
    const lineNum = lines.findIndex((l) => /random|rng|roulette/.test(l));
    findings.push({
      id: "SOL4711",
      title: "Cope Roulette-Style Reverting Transaction Attack",
      severity: "high",
      description: "Random outcome games vulnerable to reverting transaction attacks. Attackers can wrap calls in CPI and revert if outcome is unfavorable.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use commit-reveal schemes, require outcome acceptance in separate tx, implement VRF (Verifiable Random Function)."
    });
  }
  if (/max_withdraw|calculate_withdraw|available_liquidity/.test(content) && /round|floor|ceil/.test(content)) {
    const lineNum = lines.findIndex((l) => /max_withdraw|calculate_withdraw/.test(l));
    findings.push({
      id: "SOL4712",
      title: "Port Finance-Style Max Withdraw Rounding Bug",
      severity: "high",
      description: "Max withdraw calculation with rounding errors can be exploited. The Port Finance PoC demonstrated extracting extra funds through precise rounding manipulation.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use floor for withdrawals, ceiling for deposits, ensure rounding direction favors protocol."
    });
  }
  if (/break\s*;/.test(content) && /for|while|loop/.test(content) && /position|obligation|loan/.test(content)) {
    const lineNum = lines.findIndex((l) => /break\s*;/.test(l));
    findings.push({
      id: "SOL4713",
      title: "Jet-Style Unintended Break Statement Bug",
      severity: "high",
      description: "Break statement may cause early loop exit, skipping important checks. The Jet Protocol PoC showed how this could allow borrowing all TVL.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Review all break statements for unintended side effects, consider using continue or explicit loop control."
    });
  }
  if (/collateral_exchange_rate|exchange_rate|conversion_rate/.test(content) && !/checked_|saturating_/.test(content)) {
    const lineNum = lines.findIndex((l) => /exchange_rate|conversion_rate/.test(l));
    findings.push({
      id: "SOL4714",
      title: "Neodyme-Style Exchange Rate Rounding Vulnerability",
      severity: "critical",
      description: "Exchange rate calculations vulnerable to rounding attacks. The Neodyme disclosure put $2.6B at risk through innocent-looking rounding errors.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use floor/ceil based on direction favoring protocol, add minimum transaction sizes, implement rate change limits."
    });
  }
  if (/lending_market|market_authority/.test(content) && !/owner\.key\s*==|constraint\s*=\s*owner/.test(content)) {
    const lineNum = lines.findIndex((l) => /lending_market|market_authority/.test(l));
    findings.push({
      id: "SOL4715",
      title: "Solend-Style Malicious Lending Market Attack",
      severity: "critical",
      description: "Lending market account without owner validation can be substituted with attacker-controlled market. This enabled the Solend auth bypass.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate lending market owner matches expected program, use PDA derivation for market accounts."
    });
  }
  if (/pub\s+\w+:\s*AccountInfo/.test(content) && !/is_signer|Signer</.test(content) && /authority|admin|owner/.test(content)) {
    const lineNum = lines.findIndex((l) => /authority|admin|owner/.test(l) && /AccountInfo/.test(l));
    findings.push({
      id: "SOL4716",
      title: "Sealevel Attack: Missing Signer Check",
      severity: "critical",
      description: "Authority account without signer verification. Armani's Sealevel Attacks demonstrates how missing is_signer checks allow unauthorized access.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add #[account(signer)] or check is_signer explicitly for all authority accounts."
    });
  }
  if (/AccountInfo/.test(content) && !/owner\.key\s*==|\.owner\s*==/.test(content) && /data\.borrow|try_borrow/.test(content)) {
    const lineNum = lines.findIndex((l) => /data\.borrow|try_borrow/.test(l));
    findings.push({
      id: "SOL4717",
      title: "Sealevel Attack: Missing Owner Check",
      severity: "critical",
      description: "Account data accessed without verifying owner program. Attacker can substitute account with same data layout owned by different program.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify account.owner == expected_program_id before deserializing data."
    });
  }
  if (/deserialize|try_from_slice|unpack/.test(content) && !/discriminator|account_type|AccountDiscriminator/.test(content)) {
    const lineNum = lines.findIndex((l) => /deserialize|try_from_slice/.test(l));
    findings.push({
      id: "SOL4718",
      title: "Sealevel Attack: Account Data Type Confusion",
      severity: "high",
      description: "Account deserialization without type discriminator check. Different account types with same size can be confused.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add 8-byte discriminator to all account types, verify discriminator before deserialization."
    });
  }
  if (/init\s*=\s*true|initialize/.test(content) && !/is_initialized|already_initialized/.test(content)) {
    const lineNum = lines.findIndex((l) => /init\s*=\s*true|initialize/.test(l));
    findings.push({
      id: "SOL4719",
      title: "Sealevel Attack: Reinitialization Attack",
      severity: "critical",
      description: "Account initialization without checking if already initialized. Attacker can reinitialize with malicious data.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Check is_initialized flag before initialization, use Anchor's init constraint with seeds."
    });
  }
  if (/invoke_signed|invoke\(/.test(content) && /program_id\s*:\s*\w+\.key/.test(content) && !/PROGRAM_ID|spl_token::id|system_program::id/.test(content)) {
    const lineNum = lines.findIndex((l) => /invoke_signed|invoke\(/.test(l));
    findings.push({
      id: "SOL4720",
      title: "Sealevel Attack: Arbitrary CPI Target",
      severity: "critical",
      description: "CPI with program ID from untrusted account. Attacker can redirect CPI to malicious program.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Hardcode expected program IDs, verify program_id matches known constants."
    });
  }
  if (/&mut/.test(content) && /\w+:\s*Account</.test(content) && !/constraint\s*=\s*\w+\.key\s*!=/.test(content)) {
    const lineNum = lines.findIndex((l) => /&mut/.test(l) && /Account</.test(l));
    findings.push({
      id: "SOL4721",
      title: "Sealevel Attack: Duplicate Mutable Accounts",
      severity: "high",
      description: "Multiple mutable account parameters without uniqueness check. Same account passed twice can cause double-counting.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add constraints ensuring mutable accounts are distinct: constraint = a.key() != b.key()."
    });
  }
  if (/find_program_address|create_program_address/.test(content) && !/canonical_bump|bump_seed\s*=/.test(content)) {
    const lineNum = lines.findIndex((l) => /find_program_address|create_program_address/.test(l));
    findings.push({
      id: "SOL4722",
      title: "Sealevel Attack: Bump Seed Canonicalization",
      severity: "medium",
      description: "PDA derivation without canonical bump validation. Non-canonical bumps can create collisions.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Always use find_program_address and store/verify the canonical bump."
    });
  }
  if (/seeds\s*=\s*\[/.test(content) && !/user\.key|signer\.key|unique_seed/.test(content)) {
    const lineNum = lines.findIndex((l) => /seeds\s*=\s*\[/.test(l));
    findings.push({
      id: "SOL4723",
      title: "Sealevel Attack: PDA Sharing",
      severity: "high",
      description: "PDA seeds without user-specific component. Multiple users may share the same PDA.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Include user pubkey or unique identifier in PDA seeds to ensure per-user accounts."
    });
  }
  if (/#\[account\]/.test(content) && /pub\s+\w+:\s*u\d+/.test(content) && !/AccountDiscriminator|DISCRIMINATOR/.test(content)) {
    const lineNum = lines.findIndex((l) => /#\[account\]/.test(l));
    findings.push({
      id: "SOL4724",
      title: "Sealevel Attack: Type Cosplay",
      severity: "high",
      description: "Account struct without explicit discriminator. Attacker can create account with matching data layout.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use Anchor's automatic discriminator or add explicit 8-byte type identifier."
    });
  }
  if (/@solana\/web3\.js|solana-web3/.test(content) || /package\.json/.test(input.path)) {
    if (/1\.95\.[67]|1\.95\.8/.test(content)) {
      const lineNum = lines.findIndex((l) => /1\.95\.[678]/.test(l));
      findings.push({
        id: "SOL4725",
        title: "Web3.js Supply Chain Compromised Version",
        severity: "critical",
        description: "Detected potentially compromised @solana/web3.js version. Versions 1.95.6-1.95.8 contained malicious key-stealing code.",
        location: { file: input.path, line: lineNum + 1 },
        recommendation: "Upgrade to @solana/web3.js 1.95.9+ immediately, rotate all keys that may have been exposed."
      });
    }
  }
  if (/analytics|posthog|segment|mixpanel/.test(content) && /wallet|connect|sign/.test(content)) {
    const lineNum = lines.findIndex((l) => /analytics|posthog/.test(l));
    findings.push({
      id: "SOL4726",
      title: "Parcl-Style Frontend Analytics Compromise",
      severity: "high",
      description: "Analytics library in wallet interaction code. Parcl frontend was compromised via malicious analytics library injection.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Audit all third-party scripts, use CSP headers, isolate wallet signing from analytics."
    });
  }
  if (/bundle|jito|mev|tip/.test(content) && /for|while|loop/.test(content)) {
    const lineNum = lines.findIndex((l) => /bundle|jito|mev/.test(l));
    findings.push({
      id: "SOL4727",
      title: "Jito-Style Bundle DDoS Attack",
      severity: "medium",
      description: "Bundle submission without rate limiting. The Jito DDoS attack flooded mempools with bundles, causing validator crashes.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement bundle rate limiting, add cooldown periods, validate bundle contents."
    });
  }
  if (/validator|consensus|vote|slot/.test(content) && /loop|while\s*\(true\)/.test(content)) {
    const lineNum = lines.findIndex((l) => /validator|consensus/.test(l));
    findings.push({
      id: "SOL4728",
      title: "Grape-Style Network Stalling Attack",
      severity: "high",
      description: "Validator logic with unbounded loops can cause network stalls. Grape Protocol caused a 17-hour outage.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add loop bounds, implement timeouts, use compute budget limits."
    });
  }
  if (/shred|turbine|propagation|block_height/.test(content)) {
    const lineNum = lines.findIndex((l) => /shred|turbine|propagation/.test(l));
    findings.push({
      id: "SOL4729",
      title: "Turbine Propagation Failure Pattern",
      severity: "info",
      description: "References to Turbine/shred propagation. Core protocol vulnerabilities in block propagation caused historical outages.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Ensure proper error handling for propagation failures, implement fallback mechanisms."
    });
  }
  if (/jit|compile|cache|bpf_loader/.test(content) && /unsafe|raw_ptr/.test(content)) {
    const lineNum = lines.findIndex((l) => /jit|compile|cache/.test(l));
    findings.push({
      id: "SOL4730",
      title: "JIT Cache Bug Pattern",
      severity: "medium",
      description: "JIT compilation with unsafe operations. The JIT Cache Bug caused a 5-hour network outage.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Avoid unsafe operations in hot paths, implement proper cache invalidation."
    });
  }
  if (/employee|internal|admin_override|backdoor/.test(content)) {
    const lineNum = lines.findIndex((l) => /employee|internal|admin_override/.test(l));
    findings.push({
      id: "SOL4731",
      title: "Pump.fun-Style Insider Threat",
      severity: "high",
      description: "Potential insider threat vectors detected. The Pump.fun exploit ($1.9M) was perpetrated by a former employee with privileged access.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement least-privilege access, rotate keys on employee departure, use multisig for critical operations."
    });
  }
  if (/developer|dev_key|core_team/.test(content) && /withdraw|transfer/.test(content)) {
    const lineNum = lines.findIndex((l) => /developer|dev_key/.test(l));
    findings.push({
      id: "SOL4732",
      title: "Cypher-Style Developer Self-Dealing",
      severity: "high",
      description: "Developer-controlled withdrawal capabilities. Cypher Protocol was exploited twice by insiders.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Separate protocol funds from developer access, use DAO-controlled treasuries, implement withdrawal delays."
    });
  }
  if (/ai_agent|agent_wallet|autonomous/.test(content) && /sign|approve|transfer/.test(content)) {
    const lineNum = lines.findIndex((l) => /ai_agent|agent_wallet/.test(l));
    findings.push({
      id: "SOL4733",
      title: "2026 AI Agent Wallet Exploitation",
      severity: "high",
      description: "AI agent with wallet signing capabilities. Emerging 2026 threat vector as AI agents gain financial autonomy.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement spending limits, require human approval for large transactions, use session keys."
    });
  }
  if (/transfer_hook|TransferHook|extension/.test(content) && /invoke|callback/.test(content)) {
    const lineNum = lines.findIndex((l) => /transfer_hook|TransferHook/.test(l));
    findings.push({
      id: "SOL4734",
      title: "Token-2022 Transfer Hook Exploitation",
      severity: "high",
      description: "Token-2022 transfer hooks can be exploited for reentrancy-like attacks. Emerging vulnerability class in 2025-2026.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate transfer hook program ID, implement reentrancy guards, limit hook capabilities."
    });
  }
  if (/validator_tip|mev_reward|block_builder/.test(content)) {
    const lineNum = lines.findIndex((l) => /validator_tip|mev_reward/.test(l));
    findings.push({
      id: "SOL4735",
      title: "MEV-Validator Collusion Pattern",
      severity: "medium",
      description: "MEV reward mechanisms vulnerable to validator collusion. 88% Jito client dominance creates centralization risk.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use private mempools, implement MEV protection, consider order flow auction."
    });
  }
  if (/\+|\-|\*|\//.test(content) && /u64|u128|i64|i128/.test(content) && !/checked_|saturating_|wrapping_/.test(content)) {
    const lineNum = lines.findIndex((l) => /\+|\-|\*|\//.test(l) && /u\d+|i\d+/.test(l));
    findings.push({
      id: "SOL4736",
      title: "arXiv: Soteria-Detectable Integer Overflow",
      severity: "high",
      description: "Unchecked arithmetic on integer types. arXiv paper documents Soteria tool for detecting these vulnerabilities.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use checked_*, saturating_*, or explicitly handle overflow cases."
    });
  }
  if (/AccountInfo|Account</.test(content) && /data\s*=/.test(content) && !/is_initialized|initialized\s*:\s*bool/.test(content)) {
    const lineNum = lines.findIndex((l) => /data\s*=/.test(l) && !/is_initialized/.test(l));
    findings.push({
      id: "SOL4737",
      title: "arXiv: Missing Account Initialization Check",
      severity: "high",
      description: "Account data written without initialization flag check. Academic research identifies this as top vulnerability class.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add is_initialized field to all stateful accounts, check before all operations."
    });
  }
  if (/invoke_signed|CpiContext/.test(content) && /mut|set_lamports/.test(content)) {
    const lineNum = lines.findIndex((l) => /invoke_signed|CpiContext/.test(l));
    findings.push({
      id: "SOL4738",
      title: "arXiv: Cross-Program State Corruption",
      severity: "medium",
      description: "CPI with mutable state changes. Research shows cross-program state manipulation as emerging attack vector.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify state consistency after CPI calls, use read-only accounts where possible."
    });
  }
  if (/if|match|while|for/.test(content) && /amount|balance|price|fee/.test(content) && !/require!|assert!|ensure!/.test(content)) {
    const lineNum = lines.findIndex((l) => /amount|balance|price|fee/.test(l));
    findings.push({
      id: "SOL4739",
      title: "Sec3 2025: Business Logic Vulnerability",
      severity: "high",
      description: "Business logic without explicit validation. Sec3 2025 report shows business logic flaws as #1 vulnerability category.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add explicit assertions for all business logic invariants, document expected behavior."
    });
  }
  if (/args|params|input/.test(content) && !/validate|check|verify|require/.test(content)) {
    const lineNum = lines.findIndex((l) => /args|params|input/.test(l));
    findings.push({
      id: "SOL4740",
      title: "Sec3 2025: Input Validation Missing",
      severity: "high",
      description: "Function parameters without validation. Sec3 2025 report lists input validation as #2 vulnerability category.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate all inputs at function entry, reject invalid values early."
    });
  }
  if (/pub\s+fn/.test(content) && /admin|owner|authority/.test(content) && !/ctx\.accounts\.\w+\.is_signer|#\[access_control\]/.test(content)) {
    const lineNum = lines.findIndex((l) => /pub\s+fn/.test(l) && /admin|owner|authority/.test(l));
    findings.push({
      id: "SOL4741",
      title: "Sec3 2025: Access Control Vulnerability",
      severity: "critical",
      description: "Admin/owner function without access control. Sec3 2025 report shows access control as #3 vulnerability category.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add #[access_control] constraints, verify signer authority for all privileged operations."
    });
  }
  if (/serialize|deserialize|pack|unpack/.test(content) && !/borsh|AnchorSerialize|TryFrom/.test(content)) {
    const lineNum = lines.findIndex((l) => /serialize|deserialize/.test(l));
    findings.push({
      id: "SOL4742",
      title: "Sec3 2025: Data Integrity Vulnerability",
      severity: "medium",
      description: "Custom serialization without standard library. Sec3 2025 report shows data integrity as #4 vulnerability category.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use Borsh or Anchor serialization, validate data length and format on deserialize."
    });
  }
  if (/vec!|Vec::new|push|extend/.test(content) && /for|while|loop/.test(content) && !/\.len\(\)\s*<|max_size|limit/.test(content)) {
    const lineNum = lines.findIndex((l) => /vec!|Vec::/.test(l));
    findings.push({
      id: "SOL4743",
      title: "Sec3 2025: DoS/Liveness Vulnerability",
      severity: "medium",
      description: "Unbounded collection growth. Sec3 2025 report shows DoS/liveness as #5 vulnerability category.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add maximum size limits to all collections, use bounded data structures."
    });
  }
  if (/mongodb|session|token|cookie/.test(content) && /query|find|aggregate/.test(content)) {
    const lineNum = lines.findIndex((l) => /mongodb|session/.test(l));
    findings.push({
      id: "SOL4744",
      title: "Thunder Terminal-Style Session Theft",
      severity: "high",
      description: "Database queries handling session data. Thunder Terminal lost $300K+ via MongoDB session token exploitation.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use parameterized queries, implement session token rotation, add IP-based session binding."
    });
  }
  if (/trading_bot|auto_trade|snipe/.test(content) && /price|slippage/.test(content)) {
    const lineNum = lines.findIndex((l) => /trading_bot|auto_trade/.test(l));
    findings.push({
      id: "SOL4745",
      title: "Banana Gun-Style Bot Exploitation",
      severity: "high",
      description: "Automated trading bot vulnerable to price manipulation. Banana Gun lost $1.4M+ from oracle exploit.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use multiple price sources, implement slippage protection, add trade size limits."
    });
  }
  if (/p2p|peer_to_peer|escrow/.test(content) && /bridge|cross_chain/.test(content)) {
    const lineNum = lines.findIndex((l) => /p2p|escrow/.test(l));
    findings.push({
      id: "SOL4746",
      title: "NoOnes-Style P2P Bridge Attack",
      severity: "critical",
      description: "P2P escrow with cross-chain bridge. NoOnes lost $8M via authentication bypass and replay attacks.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement nonce-based replay protection, validate cross-chain message signatures, use timelock."
    });
  }
  if (/withdraw_all|drain|emergency_withdraw/.test(content) && /only_owner|admin_only/.test(content)) {
    const lineNum = lines.findIndex((l) => /withdraw_all|drain/.test(l));
    findings.push({
      id: "SOL4747",
      title: "Solareum-Style Exit Scam Detection",
      severity: "critical",
      description: "Owner-only full withdrawal function detected. Solareum executed a $1M rug pull using similar mechanism.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement withdrawal limits, add timelock for large withdrawals, use multisig for treasury access."
    });
  }
  if (/rate_x|interest_rate|borrow_rate/.test(content) && /oracle|price_feed/.test(content)) {
    const lineNum = lines.findIndex((l) => /rate_x|interest_rate/.test(l));
    findings.push({
      id: "SOL4748",
      title: "Loopscale-Style Interest Rate Oracle Bug",
      severity: "critical",
      description: "Interest rate calculation using oracle price. Loopscale lost $5.8M from RateX oracle manipulation.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use TWAP for rate calculations, implement rate change limits, add circuit breakers."
    });
  }
  if (/dao|governance|proposal|vote/.test(content) && !/quorum|threshold|min_votes/.test(content)) {
    const lineNum = lines.findIndex((l) => /dao|governance|proposal/.test(l));
    findings.push({
      id: "SOL4749",
      title: "Synthetify-Style Hidden Proposal Attack",
      severity: "high",
      description: "DAO governance without quorum requirements. Synthetify lost $230K to a hidden proposal that went unnoticed.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Require minimum quorum for all proposals, add voting period requirements, implement proposal visibility."
    });
  }
  if (/multi_call|batch|execute_batch/.test(content) && /for|loop/.test(content)) {
    const lineNum = lines.findIndex((l) => /multi_call|batch/.test(l));
    findings.push({
      id: "SOL4750",
      title: "Saga DAO-Style Multi-Call Exploit",
      severity: "high",
      description: "Batch execution without proper validation. Saga DAO lost $185K via multi-call exploit.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate each call in batch, implement atomic all-or-nothing semantics, add gas/compute limits per call."
    });
  }
  if (/AccountInfo/.test(content) && /data\.borrow/.test(content) && !/assert_eq!\s*\(\s*\w+\.owner/.test(content)) {
    const lineNum = lines.findIndex((l) => /data\.borrow/.test(l));
    findings.push({
      id: "SOL4751",
      title: "Kudelski: Missing Ownership Assertion",
      severity: "high",
      description: "Account data access without ownership assertion. Kudelski's Solana Program Security guide emphasizes this check.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add assert_eq!(account.owner, &expected_program_id) before data access."
    });
  }
  if (/invoke_signed/.test(content) && !/verify_invoke|check_seeds/.test(content)) {
    const lineNum = lines.findIndex((l) => /invoke_signed/.test(l));
    findings.push({
      id: "SOL4752",
      title: "Neodyme: Unverified invoke_signed",
      severity: "medium",
      description: "invoke_signed without explicit verification. Neodyme's common pitfalls guide warns about proper seed validation.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify all seeds used in invoke_signed match expected PDA derivation."
    });
  }
  if (/lp_token|liquidity_provider|pool_token/.test(content) && /price|value|collateral/.test(content)) {
    const lineNum = lines.findIndex((l) => /lp_token|liquidity_provider/.test(l));
    findings.push({
      id: "SOL4753",
      title: "OtterSec: LP Token Oracle Manipulation",
      severity: "critical",
      description: `LP token used for pricing/collateral. OtterSec's "$200M Bluff" report shows how LP token oracles can be manipulated.`,
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use fair pricing for LP tokens (sqrt(reserve0 * reserve1)), implement TWAP protection."
    });
  }
  if (/#\[derive\(Accounts\)\]/.test(content) && /UncheckedAccount|AccountInfo/.test(content)) {
    const lineNum = lines.findIndex((l) => /UncheckedAccount|AccountInfo/.test(l));
    findings.push({
      id: "SOL4754",
      title: "Zellic: Anchor UncheckedAccount Risk",
      severity: "high",
      description: "UncheckedAccount in Anchor derive(Accounts). Zellic's guide warns about common Anchor vulnerabilities.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add /// CHECK: documentation explaining safety, or replace with typed Account<> where possible."
    });
  }
  if (/defi|lending|borrowing|amm|dex/.test(content) && /price|oracle|rate/.test(content)) {
    const lineNum = lines.findIndex((l) => /defi|lending|borrowing/.test(l));
    findings.push({
      id: "SOL4755",
      title: "Trail of Bits: DeFi Security Pattern",
      severity: "medium",
      description: "DeFi protocol with price/oracle dependencies. Trail of Bits emphasizes robust oracle security in DeFi.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use multiple oracle sources, implement price bands, add circuit breakers for extreme moves."
    });
  }
  if (/token_account|TokenAccount/.test(content) && /authority|owner/.test(content) && !/constraint\s*=\s*\w+\.authority/.test(content)) {
    const lineNum = lines.findIndex((l) => /token_account|TokenAccount/.test(l));
    findings.push({
      id: "SOL4756",
      title: "Unchecked Token Account Authority",
      severity: "high",
      description: "Token account without authority constraint. Attacker can substitute with wrong authority.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add constraint = token_account.authority == expected_authority."
    });
  }
  if (/mint|Mint/.test(content) && /freeze_authority/.test(content) && !/freeze_authority\.is_none\(\)|freeze_authority\s*==\s*None/.test(content)) {
    const lineNum = lines.findIndex((l) => /freeze_authority/.test(l));
    findings.push({
      id: "SOL4757",
      title: "Missing Mint Freeze Authority Check",
      severity: "medium",
      description: "Mint with freeze authority can have tokens frozen. Check if freeze authority is set.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify freeze_authority is None for trustless tokens, or document the risk."
    });
  }
  if (/rent_exempt|is_rent_exempt|rent\.minimum_balance/.test(content) && !/get_minimum_balance_for_rent_exemption|Rent::get/.test(content)) {
    const lineNum = lines.findIndex((l) => /rent_exempt|is_rent_exempt/.test(l));
    findings.push({
      id: "SOL4758",
      title: "Unsafe Rent Exemption Check",
      severity: "medium",
      description: "Rent exemption check may not use current rent values. Use Rent::get() for dynamic calculation.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use Rent::get()?.minimum_balance(data_len) for accurate rent calculation."
    });
  }
  if (/amount|balance|transfer/.test(content) && /decimals|decimal/.test(content) && !/10_u64\.pow|10\.pow|decimals\.into\(\)/.test(content)) {
    const lineNum = lines.findIndex((l) => /amount|balance/.test(l) && /decimals/.test(l));
    findings.push({
      id: "SOL4759",
      title: "Missing Token Decimal Handling",
      severity: "medium",
      description: "Token amounts without proper decimal conversion. Different tokens have different decimals.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Always convert amounts using 10^decimals, handle decimal mismatch in swaps."
    });
  }
  if (/remaining_accounts|ctx\.remaining_accounts/.test(content) && !/verify|validate|check/.test(content)) {
    const lineNum = lines.findIndex((l) => /remaining_accounts/.test(l));
    findings.push({
      id: "SOL4760",
      title: "Unsafe External Account Reference",
      severity: "high",
      description: "remaining_accounts used without validation. These accounts bypass Anchor's automatic checks.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate all remaining_accounts: check owner, data format, and expected values."
    });
  }
  if (/close\s*=/.test(content) && !/close\s*=\s*\w+\.to_account_info\(\)/.test(content)) {
    const lineNum = lines.findIndex((l) => /close\s*=/.test(l));
    findings.push({
      id: "SOL4761",
      title: "Missing Close Account Destination Validation",
      severity: "medium",
      description: "Close destination not validated. Funds may be sent to wrong account on close.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Ensure close destination is validated as expected recipient."
    });
  }
  if (/system_instruction::create_account|CreateAccount/.test(content) && !/invoke_signed|seeds/.test(content)) {
    const lineNum = lines.findIndex((l) => /create_account|CreateAccount/.test(l));
    findings.push({
      id: "SOL4762",
      title: "Unsafe System Program Create Account",
      severity: "medium",
      description: "create_account without PDA derivation. Account may be created with wrong ownership.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use PDA-based account creation with invoke_signed for program-owned accounts."
    });
  }
  if (/associated_token|get_associated_token_address/.test(content) && !/verify_associated_token|check_ata/.test(content)) {
    const lineNum = lines.findIndex((l) => /associated_token|get_associated_token_address/.test(l));
    findings.push({
      id: "SOL4763",
      title: "Missing ATA Address Validation",
      severity: "high",
      description: "Associated token account used without address validation. Attacker can pass non-ATA account.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify ATA address = get_associated_token_address(wallet, mint) before use."
    });
  }
  if (/program_data|ProgramData|upgrade_authority/.test(content) && !/upgrade_authority_address|check_upgrade_authority/.test(content)) {
    const lineNum = lines.findIndex((l) => /program_data|upgrade_authority/.test(l));
    findings.push({
      id: "SOL4764",
      title: "Unsafe Program Data Authority Check",
      severity: "high",
      description: "Program data account without authority validation. Upgrade authority can modify program.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify upgrade_authority matches expected, or ensure program is immutable."
    });
  }
  if (/vote_account|VoteState|validator/.test(content) && !/check_vote_account|validate_validator/.test(content)) {
    const lineNum = lines.findIndex((l) => /vote_account|VoteState/.test(l));
    findings.push({
      id: "SOL4765",
      title: "Missing Vote Account Validation",
      severity: "medium",
      description: "Vote/validator account without proper validation. May accept fake validator accounts.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify vote account owner is vote program, validate authorized voter."
    });
  }
  if (/stake_account|StakeState|delegation/.test(content) && !/check_stake_state|validate_delegation/.test(content)) {
    const lineNum = lines.findIndex((l) => /stake_account|StakeState/.test(l));
    findings.push({
      id: "SOL4766",
      title: "Unsafe Stake Account Operations",
      severity: "medium",
      description: "Stake account operations without state validation. May operate on deactivated or locked stake.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Check stake state (Inactive/Activating/Active/Deactivating) before operations."
    });
  }
  if (/nonce_account|durable_nonce|advance_nonce/.test(content) && !/verify_nonce|check_nonce_state/.test(content)) {
    const lineNum = lines.findIndex((l) => /nonce_account|durable_nonce/.test(l));
    findings.push({
      id: "SOL4767",
      title: "Missing Nonce Account Validation",
      severity: "medium",
      description: "Durable nonce used without proper validation. May allow transaction replay.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate nonce account state, verify authorized nonce authority."
    });
  }
  if (/address_lookup_table|LookupTable/.test(content) && !/verify_lookup_table|check_table_authority/.test(content)) {
    const lineNum = lines.findIndex((l) => /address_lookup_table|LookupTable/.test(l));
    findings.push({
      id: "SOL4768",
      title: "Unsafe Lookup Table Operations",
      severity: "low",
      description: "Address lookup table without authority validation. May accept malicious lookup tables.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify lookup table authority, validate table contents before use."
    });
  }
  if (/metadata|Metadata|metaplex/.test(content) && !/verify_metadata|check_metadata_account/.test(content)) {
    const lineNum = lines.findIndex((l) => /metadata|Metadata|metaplex/.test(l));
    findings.push({
      id: "SOL4769",
      title: "Missing Metadata Account Validation",
      severity: "medium",
      description: "NFT metadata account without proper validation. May accept spoofed metadata.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify metadata PDA derivation, check metadata program ownership."
    });
  }
  if (/master_edition|MasterEdition|edition/.test(content) && !/verify_edition|check_master_edition/.test(content)) {
    const lineNum = lines.findIndex((l) => /master_edition|MasterEdition/.test(l));
    findings.push({
      id: "SOL4770",
      title: "Unsafe Master Edition Check",
      severity: "medium",
      description: "NFT master edition without proper validation. Edition account may be spoofed.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify master edition PDA, check max_supply and edition number."
    });
  }
  if (/instructions_sysvar|Instructions::load|get_instruction/.test(content) && !/verify_instruction|check_instruction_data/.test(content)) {
    const lineNum = lines.findIndex((l) => /instructions_sysvar|Instructions::load/.test(l));
    findings.push({
      id: "SOL4771",
      title: "Missing Instruction Sysvar Validation",
      severity: "high",
      description: "Instruction introspection without proper validation. May be exploited for flash loan detection bypass.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate instruction sysvar data, check for unexpected instruction patterns."
    });
  }
  if (/Clock::get|clock_sysvar|unix_timestamp/.test(content) && /deadline|expiry|timeout/.test(content)) {
    const lineNum = lines.findIndex((l) => /Clock::get|unix_timestamp/.test(l));
    findings.push({
      id: "SOL4772",
      title: "Unsafe Clock Sysvar for Deadlines",
      severity: "medium",
      description: "Using clock sysvar for time-sensitive deadlines. Slot time can drift from real time.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Allow buffer for clock drift, use slot-based deadlines where possible."
    });
  }
  if (/slot_hashes|SlotHashes|recent_blockhash/.test(content) && !/verify_blockhash|check_slot_hash/.test(content)) {
    const lineNum = lines.findIndex((l) => /slot_hashes|SlotHashes/.test(l));
    findings.push({
      id: "SOL4773",
      title: "Missing Slot Hashes Validation",
      severity: "low",
      description: "Slot hashes sysvar used without validation. May accept stale or invalid hashes.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify slot hash freshness, validate hash against expected slot."
    });
  }
  if (/epoch_schedule|EpochSchedule|get_epoch/.test(content) && /reward|distribution|unstake/.test(content)) {
    const lineNum = lines.findIndex((l) => /epoch_schedule|EpochSchedule/.test(l));
    findings.push({
      id: "SOL4774",
      title: "Unsafe Epoch Schedule Usage",
      severity: "low",
      description: "Epoch schedule used for reward/staking logic. Epoch boundaries can affect calculations.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Account for epoch boundaries in reward calculations, handle edge cases."
    });
  }
  if (/fees_sysvar|Fees|lamports_per_signature/.test(content) && !/check_fees|verify_fee/.test(content)) {
    const lineNum = lines.findIndex((l) => /fees_sysvar|Fees/.test(l));
    findings.push({
      id: "SOL4775",
      title: "Missing Fees Sysvar Check",
      severity: "low",
      description: "Fees sysvar used without validation. Fee calculations may be inaccurate.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use current fee sysvar, account for fee changes in transaction planning."
    });
  }
  if (/approve|token::approve|ApproveChecked/.test(content) && !/revoke|reset_approval/.test(content)) {
    const lineNum = lines.findIndex((l) => /approve|token::approve/.test(l));
    findings.push({
      id: "SOL4776",
      title: "Unsafe SPL Token Approve Pattern",
      severity: "medium",
      description: "Token approval without revocation mechanism. Unlimited approvals can be exploited.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Revoke approvals after use, use minimum necessary approval amounts."
    });
  }
  if (/delegate|delegated_amount/.test(content) && !/check_delegate|verify_delegate/.test(content)) {
    const lineNum = lines.findIndex((l) => /delegate|delegated_amount/.test(l));
    findings.push({
      id: "SOL4777",
      title: "Missing Token Delegate Check",
      severity: "medium",
      description: "Token delegate operations without validation. May allow unauthorized transfers.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify delegate matches expected, check delegated_amount before transfer."
    });
  }
  if (/set_authority|SetAuthority/.test(content) && !/verify_old_authority|check_authority_change/.test(content)) {
    const lineNum = lines.findIndex((l) => /set_authority|SetAuthority/.test(l));
    findings.push({
      id: "SOL4778",
      title: "Unsafe Set Authority Operation",
      severity: "high",
      description: "Authority change without proper validation. Authority may be transferred to attacker.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Require signer from current authority, validate new authority address."
    });
  }
  if (/sync_native|SyncNative|wrapped_sol/.test(content) && !/verify_sync|check_native_balance/.test(content)) {
    const lineNum = lines.findIndex((l) => /sync_native|SyncNative/.test(l));
    findings.push({
      id: "SOL4779",
      title: "Missing Sync Native Check",
      severity: "low",
      description: "Wrapped SOL sync without validation. Balance may not reflect actual lamports.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Call sync_native before reading wrapped SOL balance, verify lamports match."
    });
  }
  if (/initialize_account|InitializeAccount/.test(content) && !/verify_uninitialized|check_account_state/.test(content)) {
    const lineNum = lines.findIndex((l) => /initialize_account|InitializeAccount/.test(l));
    findings.push({
      id: "SOL4780",
      title: "Unsafe Initialize Account Operation",
      severity: "medium",
      description: "Account initialization without uninitialized check. May reinitialize existing account.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify account is not already initialized before initialization."
    });
  }
  if (/swap|exchange|trade/.test(content) && /amount_in|amount_out/.test(content) && !/min_amount_out|max_slippage|slippage_tolerance/.test(content)) {
    const lineNum = lines.findIndex((l) => /swap|exchange/.test(l));
    findings.push({
      id: "SOL4781",
      title: "Missing Slippage Protection",
      severity: "high",
      description: "Swap operation without slippage protection. Vulnerable to sandwich attacks.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add min_amount_out parameter, implement slippage tolerance checks."
    });
  }
  if (/add_liquidity|provide_liquidity|deposit_lp/.test(content) && !/min_lp_tokens|proportional_check/.test(content)) {
    const lineNum = lines.findIndex((l) => /add_liquidity|provide_liquidity/.test(l));
    findings.push({
      id: "SOL4782",
      title: "Unsafe Liquidity Provision",
      severity: "high",
      description: "Liquidity provision without minimum LP token check. May receive fewer LP tokens than expected.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add minimum LP token requirement, verify proportional token amounts."
    });
  }
  if (/liquidate|liquidation/.test(content) && !/health_factor|collateral_ratio|is_liquidatable/.test(content)) {
    const lineNum = lines.findIndex((l) => /liquidate|liquidation/.test(l));
    findings.push({
      id: "SOL4783",
      title: "Missing Liquidation Health Check",
      severity: "critical",
      description: "Liquidation without health factor verification. May allow improper liquidations.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify position is actually underwater before liquidation, check health factor."
    });
  }
  if (/borrow|take_loan/.test(content) && !/utilization_rate|max_borrow|available_liquidity/.test(content)) {
    const lineNum = lines.findIndex((l) => /borrow|take_loan/.test(l));
    findings.push({
      id: "SOL4784",
      title: "Unsafe Borrow Operation",
      severity: "high",
      description: "Borrow operation without utilization check. May exceed pool capacity.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Check utilization rate, verify available liquidity before borrow."
    });
  }
  if (/borrow|lend|interest/.test(content) && !/accrue_interest|update_interest|compound/.test(content)) {
    const lineNum = lines.findIndex((l) => /borrow|lend|interest/.test(l));
    findings.push({
      id: "SOL4785",
      title: "Missing Interest Accrual",
      severity: "medium",
      description: "Lending operation without interest accrual. Interest calculations may be stale.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Accrue interest before any borrow/repay/liquidate operation."
    });
  }
  if (/release_collateral|withdraw_collateral|unlock/.test(content) && !/check_debt|verify_no_borrow/.test(content)) {
    const lineNum = lines.findIndex((l) => /release_collateral|withdraw_collateral/.test(l));
    findings.push({
      id: "SOL4786",
      title: "Unsafe Collateral Release",
      severity: "critical",
      description: "Collateral release without debt check. May release collateral while debt exists.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify no outstanding debt before collateral release, check health factor."
    });
  }
  if (/claim_reward|distribute_reward|harvest/.test(content) && !/reward_earned|pending_reward|calculate_reward/.test(content)) {
    const lineNum = lines.findIndex((l) => /claim_reward|distribute_reward/.test(l));
    findings.push({
      id: "SOL4787",
      title: "Missing Reward Distribution Check",
      severity: "medium",
      description: "Reward claim without earned calculation. May over-distribute rewards.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Calculate earned rewards before distribution, track last claim time."
    });
  }
  if (/pool_ratio|reserve_ratio|k_value/.test(content) && !/checked_div|saturating_div/.test(content)) {
    const lineNum = lines.findIndex((l) => /pool_ratio|reserve_ratio/.test(l));
    findings.push({
      id: "SOL4788",
      title: "Unsafe Pool Ratio Calculation",
      severity: "high",
      description: "Pool ratio calculation without overflow protection. Division by zero or overflow possible.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Use checked arithmetic, handle division by zero, validate input amounts."
    });
  }
  if (/fee|protocol_fee|trading_fee/.test(content) && !/accrue_fee|track_fee|fee_account/.test(content)) {
    const lineNum = lines.findIndex((l) => /fee|protocol_fee/.test(l));
    findings.push({
      id: "SOL4789",
      title: "Missing Fee Accounting",
      severity: "medium",
      description: "Fee collection without proper accounting. Fees may be lost or misattributed.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Track all fees in dedicated accounts, emit events for fee collection."
    });
  }
  if (/price_impact|swap_impact|slippage_impact/.test(content) && !/max_price_impact|impact_threshold/.test(content)) {
    const lineNum = lines.findIndex((l) => /price_impact|swap_impact/.test(l));
    findings.push({
      id: "SOL4790",
      title: "Unsafe Price Impact Calculation",
      severity: "medium",
      description: "Price impact calculation without maximum check. Large trades may have excessive impact.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement maximum price impact threshold, reject trades exceeding limit."
    });
  }
  if (/pub\s+fn\s+\w+/.test(content) && /transfer|swap|borrow|liquidate/.test(content) && !/is_paused|check_paused|when_not_paused/.test(content)) {
    const lineNum = lines.findIndex((l) => /transfer|swap|borrow|liquidate/.test(l));
    findings.push({
      id: "SOL4791",
      title: "Missing Emergency Pause Mechanism",
      severity: "high",
      description: "Critical function without pause check. Cannot halt operations during emergency.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add pause state check to all critical functions, implement pause/unpause authority."
    });
  }
  if (/migrate|migration|upgrade_state/.test(content) && !/version_check|migration_complete/.test(content)) {
    const lineNum = lines.findIndex((l) => /migrate|migration/.test(l));
    findings.push({
      id: "SOL4792",
      title: "Unsafe Migration Function",
      severity: "high",
      description: "State migration without version tracking. May allow repeated migration.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Track migration version, prevent re-migration, validate migration authority."
    });
  }
  if (/transfer|swap|borrow|liquidate|deposit|withdraw/.test(content) && !/emit!|msg!|log|event/.test(content)) {
    const lineNum = lines.findIndex((l) => /transfer|swap|borrow|liquidate/.test(l));
    findings.push({
      id: "SOL4793",
      title: "Missing Event Emission",
      severity: "low",
      description: "Critical operation without event emission. Difficult to track on-chain activity.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Emit events for all state-changing operations, include relevant parameters."
    });
  }
  if (/callback|on_complete|hook/.test(content) && !/verify_callback_origin|check_callback_authority/.test(content)) {
    const lineNum = lines.findIndex((l) => /callback|on_complete|hook/.test(l));
    findings.push({
      id: "SOL4794",
      title: "Unsafe Callback Handler",
      severity: "high",
      description: "Callback handler without origin validation. Attacker may trigger with malicious data.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify callback origin program, validate callback data format and values."
    });
  }
  if (/invoke|cpi|cross_program/.test(content) && /balance|amount|state/.test(content) && !/reentrancy_guard|is_reentered|lock/.test(content)) {
    const lineNum = lines.findIndex((l) => /invoke|cpi/.test(l));
    findings.push({
      id: "SOL4795",
      title: "Missing Reentrancy Guard",
      severity: "high",
      description: "CPI call without reentrancy protection. State may be manipulated during call.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Add reentrancy guard state, follow checks-effects-interactions pattern."
    });
  }
  if (/update_config|set_config|change_parameter/.test(content) && !/timelock|delay|pending_config/.test(content)) {
    const lineNum = lines.findIndex((l) => /update_config|set_config/.test(l));
    findings.push({
      id: "SOL4796",
      title: "Unsafe Config Update",
      severity: "medium",
      description: "Configuration update without timelock. Immediate changes may catch users off-guard.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement timelock for config changes, emit events before changes take effect."
    });
  }
  if (/mint_to|MintTo|create_token/.test(content) && !/max_supply|cap|total_supply/.test(content)) {
    const lineNum = lines.findIndex((l) => /mint_to|MintTo/.test(l));
    findings.push({
      id: "SOL4797",
      title: "Missing Max Supply Check",
      severity: "high",
      description: "Token minting without supply cap check. May allow unlimited minting.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Implement and enforce max supply, track total supply on each mint."
    });
  }
  if (/burn|Burn|destroy/.test(content) && !/verify_burner|check_burn_authority/.test(content)) {
    const lineNum = lines.findIndex((l) => /burn|Burn|destroy/.test(l));
    findings.push({
      id: "SOL4798",
      title: "Unsafe Burn Operation",
      severity: "medium",
      description: "Token burn without proper authority check. May allow unauthorized burning.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Verify burn authority matches token account owner or delegate."
    });
  }
  if (/deadline|expiry|expires_at/.test(content) && !/Clock::get|current_time|now/.test(content)) {
    const lineNum = lines.findIndex((l) => /deadline|expiry|expires_at/.test(l));
    findings.push({
      id: "SOL4799",
      title: "Missing Deadline Validation",
      severity: "medium",
      description: "Deadline check without current time comparison. Operations may execute after expiry.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Compare deadline against Clock::get()?.unix_timestamp, reject expired operations."
    });
  }
  if (/order_book|bid|ask|limit_order|market_order/.test(content) && !/validate_order|check_order_price/.test(content)) {
    const lineNum = lines.findIndex((l) => /order_book|bid|ask/.test(l));
    findings.push({
      id: "SOL4800",
      title: "Unsafe Order Book Operation",
      severity: "high",
      description: "Order book operation without price validation. May accept manipulative orders.",
      location: { file: input.path, line: lineNum + 1 },
      recommendation: "Validate order prices against oracle, implement price bands, check order sizes."
    });
  }
  return findings;
}

// src/patterns/solana-batched-patterns-88.ts
var BATCH_88_PATTERNS = [
  // Helius Verified Incident Patterns (38 Incidents Analysis)
  {
    id: "SOL4801",
    name: "Solend Auth Bypass - UpdateReserveConfig Flaw",
    severity: "critical",
    pattern: /update.*reserve.*config|UpdateReserveConfig(?![\s\S]{0,150}authority\s*==|[\s\S]{0,150}has_one\s*=\s*lending_market)/i,
    description: "Based on Solend Aug 2021 exploit. Attacker bypassed admin checks by creating their own lending market and passing it as account. Put $2M at risk.",
    recommendation: "Verify lending_market authority matches expected admin. Use has_one constraint on lending_market with admin authority."
  },
  {
    id: "SOL4802",
    name: "Liquidation Threshold Manipulation",
    severity: "critical",
    pattern: /liquidation.*threshold|liquidation_threshold(?![\s\S]{0,100}require!|[\s\S]{0,100}min_threshold|[\s\S]{0,100}MINIMUM_)/i,
    description: "Solend exploit allowed attacker to lower liquidation threshold, making all borrows liquidatable. Combined with inflated bonus = profit.",
    recommendation: "Add minimum liquidation threshold constant. Implement circuit breakers for parameter changes."
  },
  {
    id: "SOL4803",
    name: "Liquidation Bonus Inflation",
    severity: "critical",
    pattern: /liquidation.*bonus|liquidation_bonus(?![\s\S]{0,100}MAX_BONUS|[\s\S]{0,100}cap|[\s\S]{0,100}maximum)/i,
    description: "Attackers can inflate liquidation bonuses to profit from forced liquidations. Solend exploit attempted 100%+ bonuses.",
    recommendation: "Cap liquidation bonus to reasonable maximum (e.g., 15%). Add timelock for bonus changes."
  },
  {
    id: "SOL4804",
    name: "Wormhole Guardian Signature Forgery",
    severity: "critical",
    pattern: /guardian.*signature|verify.*guardian(?![\s\S]{0,100}valid_signature|[\s\S]{0,100}SignatureSet|[\s\S]{0,100}quorum)/i,
    description: "Wormhole $326M exploit. Signature verification flaw allowed forging valid signatures without Guardian validation.",
    recommendation: "Implement robust signature verification with complete input validation. Verify all Guardian signatures in quorum."
  },
  {
    id: "SOL4805",
    name: "Bridge wETH Mint Without Collateral",
    severity: "critical",
    pattern: /mint.*wrapped|wrapped.*mint|wETH|wSOL(?![\s\S]{0,150}collateral_check|[\s\S]{0,150}deposit_verified)/i,
    description: "Wormhole allowed minting 120,000 wETH without depositing equivalent ETH collateral. Cross-chain bridges must verify deposits.",
    recommendation: "Verify deposit on source chain before minting on destination. Use atomic swaps or verified message proofs."
  },
  {
    id: "SOL4806",
    name: "Cashio Saber Arrow Mint Field Missing",
    severity: "critical",
    pattern: /saber.*arrow|arrow.*account|lp.*token.*mint(?![\s\S]{0,100}mint\s*==|[\s\S]{0,100}validate_mint)/i,
    description: "Cashio $52.8M exploit. Missing validation of mint field in saber_swap.arrow account enabled fake LP token collateral.",
    recommendation: "Always validate mint addresses in LP token accounts. Verify LP token comes from whitelisted pool."
  },
  {
    id: "SOL4807",
    name: "Infinite Mint Glitch Pattern",
    severity: "critical",
    pattern: /mint.*amount|amount.*mint(?![\s\S]{0,100}max_supply|[\s\S]{0,100}supply_cap|[\s\S]{0,100}total_supply\s*<)/i,
    description: "Cashio infinite mint glitch allowed minting 2 billion CASH tokens with worthless collateral.",
    recommendation: "Implement supply caps and minting rate limits. Validate collateral value before any minting."
  },
  {
    id: "SOL4808",
    name: "Root of Trust Chain Broken",
    severity: "critical",
    pattern: /collateral.*account|backing.*token(?![\s\S]{0,100}verify_chain|[\s\S]{0,100}root_of_trust|[\s\S]{0,100}whitelist)/i,
    description: "Cashio broke root of trust chain. Attacker used fake accounts with worthless collateral due to missing chain verification.",
    recommendation: "Establish and verify complete root of trust chain. Whitelist all acceptable collateral tokens/pools."
  },
  {
    id: "SOL4809",
    name: "Crema CLMM Fake Tick Account",
    severity: "critical",
    pattern: /tick.*account|tick_array(?![\s\S]{0,100}owner\s*==|[\s\S]{0,100}seeds.*pool|[\s\S]{0,100}has_one)/i,
    description: "Crema $8.8M exploit. Attacker created fake tick account bypassing owner verification, manipulated fee data.",
    recommendation: "Verify tick account ownership and PDA derivation. Tick accounts must be derived from pool seeds."
  },
  {
    id: "SOL4810",
    name: "CLMM Transaction Fee Data Manipulation",
    severity: "critical",
    pattern: /fee.*owed|fee.*data|accumulated.*fee(?![\s\S]{0,100}verify_calculation|[\s\S]{0,100}total_fees\s*<=)/i,
    description: "Crema exploit manipulated transaction fee data to claim excessive fees. Flash loan amplified the attack.",
    recommendation: "Verify fee calculations match actual trades. Implement fee claim limits per position."
  },
  // Audius Governance Exploit Patterns
  {
    id: "SOL4811",
    name: "Audius Malicious Proposal Execution",
    severity: "critical",
    pattern: /proposal.*execute|execute.*proposal(?![\s\S]{0,100}validate_proposal|[\s\S]{0,100}timelock|[\s\S]{0,100}quorum_reached)/i,
    description: "Audius $6.1M exploit. Attacker submitted and executed malicious proposals bypassing validation, reconfigured treasury.",
    recommendation: "Implement proposal validation, timelocks, and minimum quorum requirements before execution."
  },
  {
    id: "SOL4812",
    name: "Treasury Permission Reconfiguration",
    severity: "critical",
    pattern: /treasury.*permission|treasury.*config|reconfigure.*treasury(?![\s\S]{0,100}multisig|[\s\S]{0,100}timelock)/i,
    description: "Audius attacker reconfigured treasury permissions via governance, transferred 18.5M AUDIO tokens.",
    recommendation: "Use multisig with timelock for treasury configuration. Implement emergency pause for suspicious changes."
  },
  // Nirvana Finance Flash Loan Bonding Curve
  {
    id: "SOL4813",
    name: "Nirvana Bonding Curve Flash Loan Attack",
    severity: "critical",
    pattern: /bonding.*curve.*price|price.*bonding(?![\s\S]{0,100}flash_loan_guard|[\s\S]{0,100}price_cap|[\s\S]{0,100}rate_limit)/i,
    description: "Nirvana $3.5M exploit. Flash loan + bonding curve manipulation = minting tokens at inflated rate, draining stablecoins.",
    recommendation: "Add flash loan protection to bonding operations. Implement price movement caps and rate limits."
  },
  {
    id: "SOL4814",
    name: "Rising Floor Price Mechanism Bypass",
    severity: "high",
    pattern: /floor.*price|rising.*floor|price.*floor(?![\s\S]{0,100}verify_reserve|[\s\S]{0,100}backing_ratio)/i,
    description: "Nirvana's rising floor mechanism was bypassed. Price mechanisms need reserve backing verification.",
    recommendation: "Verify reserve backing matches floor price claims. Use external oracles as secondary check."
  },
  // Slope Wallet Private Key Leak
  {
    id: "SOL4815",
    name: "Slope Wallet Mnemonic Logging",
    severity: "critical",
    pattern: /log.*mnemonic|mnemonic.*log|seed_phrase.*log|log.*seed|console.*private/i,
    description: "Slope Wallet $8M loss. Mnemonics logged to centralized Sentry server, later exploited to drain wallets.",
    recommendation: "NEVER log mnemonics, private keys, or seed phrases. Audit all logging code paths."
  },
  {
    id: "SOL4816",
    name: "Centralized Telemetry Key Exposure",
    severity: "critical",
    pattern: /sentry|telemetry|analytics(?![\s\S]{0,50}exclude.*key|[\s\S]{0,50}filter.*secret)/i,
    description: "Slope sent sensitive wallet data to Sentry telemetry. Centralized logging of user data = security risk.",
    recommendation: "Filter all sensitive data from telemetry. Use local-only logging for wallet operations."
  },
  // OptiFi Lockup Bug
  {
    id: "SOL4817",
    name: "OptiFi Accidental Program Close",
    severity: "critical",
    pattern: /program.*close|close.*program|shutdown.*market(?![\s\S]{0,100}require_empty|[\s\S]{0,100}zero_balance)/i,
    description: "OptiFi $661K locked forever. Admin accidentally called close on program with active user deposits.",
    recommendation: "Require zero balances/no active positions before program/market closure. Add confirmation steps."
  },
  {
    id: "SOL4818",
    name: "Irreversible Protocol Shutdown",
    severity: "high",
    pattern: /shutdown|terminate|close_program(?![\s\S]{0,100}migration_path|[\s\S]{0,100}recovery)/i,
    description: "OptiFi shutdown was irreversible, locking $661K user funds permanently. Programs need migration paths.",
    recommendation: "Implement migration/recovery mechanisms. Never permanently lock user funds without escape hatch."
  },
  // Mango Markets Oracle Manipulation ($116M)
  {
    id: "SOL4819",
    name: "Mango MNGO Perp Price Manipulation",
    severity: "critical",
    pattern: /perp.*price|perpetual.*oracle(?![\s\S]{0,100}twap|[\s\S]{0,100}time_weighted|[\s\S]{0,100}window)/i,
    description: "Mango $116M exploit. Attacker manipulated MNGO perp price using thin liquidity, used unrealized gains as collateral.",
    recommendation: "Use TWAP for collateral valuation. Implement price deviation checks and liquidity-based limits."
  },
  {
    id: "SOL4820",
    name: "Unrealized PnL as Collateral",
    severity: "critical",
    pattern: /unrealized.*pnl|unrealized.*profit|pnl.*collateral(?![\s\S]{0,100}time_delay|[\s\S]{0,100}settlement)/i,
    description: "Mango allowed unrealized PnL as collateral for borrowing. Attacker borrowed against inflated unrealized gains.",
    recommendation: "Require settlement/time delay before unrealized PnL can be used as collateral. Limit PnL-backed borrowing."
  },
  {
    id: "SOL4821",
    name: "Thin Liquidity Oracle Manipulation",
    severity: "critical",
    pattern: /thin.*liquidity|low.*liquidity.*price(?![\s\S]{0,100}minimum_liquidity|[\s\S]{0,100}volume_check)/i,
    description: "Mango MNGO-PERP had thin liquidity, making price easy to manipulate. $116M exploit used this.",
    recommendation: "Implement minimum liquidity requirements for oracle price validity. Use multiple sources."
  },
  // UXD Protocol Mango Dependency
  {
    id: "SOL4822",
    name: "UXD Cascading Protocol Dependency",
    severity: "high",
    pattern: /mango.*integration|external.*protocol(?![\s\S]{0,100}risk_limit|[\s\S]{0,100}fallback)/i,
    description: "UXD lost $20M due to Mango exploit cascade. Protocol dependency on compromised external protocol.",
    recommendation: "Implement exposure limits to external protocols. Have fallback mechanisms for protocol failures."
  },
  // Tulip Protocol Leveraged Yield
  {
    id: "SOL4823",
    name: "Tulip Leveraged Yield Vulnerability",
    severity: "high",
    pattern: /leveraged.*yield|yield.*leverage(?![\s\S]{0,100}max_leverage|[\s\S]{0,100}collateral_ratio)/i,
    description: "Tulip v1 leveraged yield impacted by Mango exploit. Levered positions amplify protocol dependency risks.",
    recommendation: "Cap maximum leverage. Implement circuit breakers for external protocol failures."
  },
  // Raydium Admin Key Compromise ($4.4M)
  {
    id: "SOL4824",
    name: "Raydium Admin Private Key Compromise",
    severity: "critical",
    pattern: /admin.*key|pool_authority.*key(?![\s\S]{0,100}multisig|[\s\S]{0,100}hardware_wallet)/i,
    description: "Raydium $4.4M loss from admin key compromise. Single admin key = single point of failure.",
    recommendation: "Use multisig for all admin operations. Store admin keys in hardware wallets with air gap."
  },
  {
    id: "SOL4825",
    name: "Pool Fee Withdrawal Without Multisig",
    severity: "critical",
    pattern: /withdraw.*fee|fee.*withdrawal|pool.*fee(?![\s\S]{0,100}multisig|[\s\S]{0,100}timelock|[\s\S]{0,100}governance)/i,
    description: "Raydium attacker withdrew accumulated pool fees using compromised admin key. No multisig protection.",
    recommendation: "Require multisig + timelock for all pool fee withdrawals. Implement withdrawal limits."
  },
  // Cypher Protocol Insider Theft
  {
    id: "SOL4826",
    name: "Cypher Insider Access Abuse",
    severity: "critical",
    pattern: /insider.*access|employee.*withdraw|team.*authority(?![\s\S]{0,100}audit_log|[\s\S]{0,100}separation_of_duties)/i,
    description: "Cypher $1.04M initial + $317K later stolen by insider. Former employee Barrett Hoak had retained access.",
    recommendation: "Implement access revocation procedures. Require multisig for all admin actions. Audit all access."
  },
  {
    id: "SOL4827",
    name: "Post-Exploit Access Retention",
    severity: "critical",
    pattern: /retained.*access|legacy.*key|old.*admin(?![\s\S]{0,100}key_rotation|[\s\S]{0,100}revoke)/i,
    description: "Cypher insider retained access after initial exploit, stealing additional $317K in 2024.",
    recommendation: "Rotate all keys after any security incident. Audit and revoke all non-essential access."
  },
  // SVT Token Fake Approval
  {
    id: "SOL4828",
    name: "SVT Fake Approval Permission Exploit",
    severity: "critical",
    pattern: /fake.*approval|approval.*exploit|token.*approve(?![\s\S]{0,100}verify_source|[\s\S]{0,100}user_initiated)/i,
    description: "SVT Token $265K loss via fake approval. CertiK alert detected. Users unknowingly approved malicious drainer.",
    recommendation: "Verify approval source is legitimate. Implement approval amount limits and expiry."
  },
  // io.net GPU Sybil Attack
  {
    id: "SOL4829",
    name: "DePIN GPU Sybil Attack",
    severity: "high",
    pattern: /gpu.*node|node.*verification|sybil.*detection(?![\s\S]{0,100}proof_of_work|[\s\S]{0,100}stake_requirement)/i,
    description: "io.net faced Sybil attack via fake GPU nodes for airdrop farming. DePIN platforms need robust node verification.",
    recommendation: "Implement proof-of-work challenges for node verification. Require stake for node registration."
  },
  // Synthetify DAO Treasury Raid
  {
    id: "SOL4830",
    name: "DAO Treasury Unauthorized Transfer",
    severity: "critical",
    pattern: /dao.*treasury.*transfer|treasury.*withdraw(?![\s\S]{0,100}proposal_approved|[\s\S]{0,100}timelock|[\s\S]{0,100}multisig)/i,
    description: "Synthetify DAO treasury exploit via unauthorized transfer. Governance + treasury security critical.",
    recommendation: "Require approved proposal + timelock + multisig for treasury transfers. Implement rate limits."
  },
  // Aurory NFT Gaming Exploit
  {
    id: "SOL4831",
    name: "Gaming NFT Reward Manipulation",
    severity: "high",
    pattern: /game.*reward|nft.*reward|play.*to.*earn(?![\s\S]{0,100}verify_gameplay|[\s\S]{0,100}anti_cheat)/i,
    description: "Aurory gaming exploit manipulated NFT rewards. Gaming protocols need robust anti-cheat and verification.",
    recommendation: "Implement server-side gameplay verification. Add anti-cheat mechanisms and reward rate limits."
  },
  // Thunder Terminal MongoDB Flaw
  {
    id: "SOL4832",
    name: "MongoDB Session Token Extraction",
    severity: "critical",
    pattern: /mongodb|session.*token|nosql(?![\s\S]{0,100}sanitize|[\s\S]{0,100}encrypt.*token)/i,
    description: "Thunder Terminal $240K loss. Attacker exploited MongoDB flaw to extract session tokens and drain wallets.",
    recommendation: "Encrypt all session tokens at rest. Implement database access controls and injection prevention."
  },
  {
    id: "SOL4833",
    name: "Third-Party Service Database Compromise",
    severity: "critical",
    pattern: /third.*party.*db|external.*database|service.*integration(?![\s\S]{0,100}encryption|[\s\S]{0,100}isolated)/i,
    description: "Thunder Terminal's MongoDB was third-party service. Database security critical for trading bots.",
    recommendation: "Encrypt sensitive data in external databases. Use database isolation and access logging."
  },
  // Saga DAO MEV Exploit
  {
    id: "SOL4834",
    name: "NFT DAO MEV Sandwich Attack",
    severity: "high",
    pattern: /nft.*auction|auction.*bid|dao.*nft(?![\s\S]{0,100}commit_reveal|[\s\S]{0,100}private_mempool)/i,
    description: "Saga DAO NFT auction manipulated via MEV. Public bids frontrun by searchers.",
    recommendation: "Use commit-reveal schemes for auctions. Implement private mempools or auction mechanisms."
  },
  // Solareum Honeypot Contract
  {
    id: "SOL4835",
    name: "Solareum Honeypot Contract Pattern",
    severity: "critical",
    pattern: /withdraw.*disabled|sell.*blocked|honeypot(?![\s\S]{0,100}legitimate|[\s\S]{0,100}audit)/i,
    description: "Solareum $500K loss. Token contract was honeypot - users could buy but not sell.",
    recommendation: "Audit token contracts for withdrawal restrictions. Use verified contract templates."
  },
  // Pump.fun Employee Exploit
  {
    id: "SOL4836",
    name: "Pump.fun Bonding Curve Employee Abuse",
    severity: "critical",
    pattern: /bonding.*curve.*access|employee.*bonding(?![\s\S]{0,100}no_privileged_access|[\s\S]{0,100}audit)/i,
    description: "Pump.fun $1.9M via former employee with privileged access to bonding curve contracts.",
    recommendation: "Remove all privileged employee access to live contracts. Use permissionless designs."
  },
  {
    id: "SOL4837",
    name: "Employee Privilege Escalation",
    severity: "critical",
    pattern: /employee.*access|staff.*privilege|team.*key(?![\s\S]{0,100}revoke_on_departure|[\s\S]{0,100}least_privilege)/i,
    description: "Pump.fun employee had excessive access. Insider threat from former team members is real.",
    recommendation: "Implement least-privilege principle. Revoke all access immediately upon departure."
  },
  // Banana Gun Bot Compromise
  {
    id: "SOL4838",
    name: "Telegram Bot Oracle Injection",
    severity: "critical",
    pattern: /telegram.*bot.*oracle|bot.*price.*feed(?![\s\S]{0,100}verify_source|[\s\S]{0,100}signed_data)/i,
    description: "Banana Gun $1.4M loss. Trading bot's price oracle was compromised, executing at manipulated prices.",
    recommendation: "Verify oracle data signatures. Use multiple price sources with deviation checks."
  },
  {
    id: "SOL4839",
    name: "Trading Bot API Key Exposure",
    severity: "critical",
    pattern: /api.*key.*bot|bot.*credential|trading.*bot.*key(?![\s\S]{0,100}encrypted|[\s\S]{0,100}hsm)/i,
    description: "Trading bots hold user funds. API key compromise = total loss. Banana Gun refunded users.",
    recommendation: "Store API keys in HSM/encrypted storage. Implement IP whitelisting and withdrawal limits."
  },
  // DEXX Private Key Leak ($30M)
  {
    id: "SOL4840",
    name: "DEXX Centralized Key Storage",
    severity: "critical",
    pattern: /centralized.*key|key.*storage|private_key.*server(?![\s\S]{0,100}hsm|[\s\S]{0,100}mpc|[\s\S]{0,100}tee)/i,
    description: "DEXX $30M loss. Private keys stored on centralized server were leaked. Largest 2024 Solana loss.",
    recommendation: "Use MPC or HSM for key management. Never store plain private keys on servers."
  },
  {
    id: "SOL4841",
    name: "Non-Custodial Claims With Custodial Reality",
    severity: "critical",
    pattern: /non.*custodial|self.*custody(?![\s\S]{0,100}verify_client_side|[\s\S]{0,100}no_server_keys)/i,
    description: "DEXX claimed non-custodial but stored keys server-side. Verify custody claims match implementation.",
    recommendation: "Audit custody model. True non-custodial means keys NEVER touch servers."
  },
  // NoOnes P2P Bridge Exploit
  {
    id: "SOL4842",
    name: "NoOnes Bridge Validation Flaw",
    severity: "critical",
    pattern: /p2p.*bridge|bridge.*validation(?![\s\S]{0,100}proof_verification|[\s\S]{0,100}merkle_root)/i,
    description: "NoOnes $8.5M loss from P2P bridge exploit. ZachXBT alert helped detection.",
    recommendation: "Implement robust cross-chain proof verification. Use merkle proofs for transaction validation."
  },
  // Loopscale RateX Bug ($5.8M)
  {
    id: "SOL4843",
    name: "Loopscale RateX Collateral Bug",
    severity: "critical",
    pattern: /rate.*collateral|collateral.*rate(?![\s\S]{0,100}verify_rate|[\s\S]{0,100}bound_check)/i,
    description: "Loopscale $5.8M loss via RateX-based collateral bug. All funds recovered via negotiation.",
    recommendation: "Verify rate calculations have bounds. Implement collateral validation with multiple checks."
  },
  // Parcl Front-End Supply Chain
  {
    id: "SOL4844",
    name: "Parcl Frontend CDN Compromise",
    severity: "critical",
    pattern: /cdn.*script|frontend.*inject|javascript.*cdn(?![\s\S]{0,100}sri|[\s\S]{0,100}integrity_check)/i,
    description: "Parcl frontend compromised via malicious script injection. Supply chain attack on CDN.",
    recommendation: "Use Subresource Integrity (SRI) for all external scripts. Self-host critical dependencies."
  },
  // Web3.js Supply Chain ($160K)
  {
    id: "SOL4845",
    name: "Web3.js NPM Package Backdoor",
    severity: "critical",
    pattern: /@solana\/web3\.js|solana.*web3(?![\s\S]{0,50}pinned_version|[\s\S]{0,50}lock_file)/i,
    description: "Web3.js $160K loss via NPM backdoor. Compromised versions 1.95.6-1.95.7 contained key drainer.",
    recommendation: "Pin exact dependency versions. Use lockfiles. Audit dependency updates. Use npm audit."
  },
  {
    id: "SOL4846",
    name: "NPM Package Key Exfiltration",
    severity: "critical",
    pattern: /npm.*install|package.*json(?![\s\S]{0,100}audit|[\s\S]{0,100}verified_checksum)/i,
    description: "Web3.js backdoor exfiltrated private keys via postinstall script. Supply chain attacks are real.",
    recommendation: "Run npm audit before install. Review postinstall scripts. Use package-lock.json."
  },
  // Grape Protocol Network-Level
  {
    id: "SOL4847",
    name: "Network Spam Attack 17-Hour Outage",
    severity: "critical",
    pattern: /spam.*attack|transaction.*flood|ddos.*network(?![\s\S]{0,100}rate_limit|[\s\S]{0,100}spam_filter)/i,
    description: "Grape Protocol spam attack caused 17-hour Solana outage Sep 2021. Network-level vulnerability.",
    recommendation: "Implement transaction rate limits and spam filtering at protocol level."
  },
  // Candy Machine NFT Minting
  {
    id: "SOL4848",
    name: "NFT Minting Bot Congestion",
    severity: "high",
    pattern: /mint.*bot|nft.*bot|mass.*mint(?![\s\S]{0,100}captcha|[\s\S]{0,100}rate_limit)/i,
    description: "Candy Machine NFT minting caused network congestion. Bot activity overwhelmed validators.",
    recommendation: "Implement minting rate limits. Use captcha or proof-of-humanity for NFT mints."
  },
  // Jito DDoS Attack
  {
    id: "SOL4849",
    name: "Jito Mempool DDoS",
    severity: "high",
    pattern: /jito.*mempool|bundle.*spam|mev.*ddos(?![\s\S]{0,100}stake_required|[\s\S]{0,100}reputation)/i,
    description: "Jito faced DDoS via bundle spam Feb 2025. MEV infrastructure is attack target.",
    recommendation: "Require stake for bundle submission. Implement reputation-based rate limiting."
  },
  // Phantom Wallet DDoS
  {
    id: "SOL4850",
    name: "Wallet RPC Endpoint DDoS",
    severity: "high",
    pattern: /rpc.*endpoint|wallet.*rpc(?![\s\S]{0,100}load_balancer|[\s\S]{0,100}fallback_rpc)/i,
    description: "Phantom wallet faced DDoS on RPC endpoints Mar 2025. Wallet infrastructure needs resilience.",
    recommendation: "Use multiple RPC providers with automatic failover. Implement request caching."
  },
  // Solana Core Protocol Vulnerabilities
  {
    id: "SOL4851",
    name: "Turbine Data Propagation Bug",
    severity: "critical",
    pattern: /turbine|data.*propagation|shred(?![\s\S]{0,100}verify_shred|[\s\S]{0,100}erasure_coding)/i,
    description: "Solana Turbine bug 2022 caused network instability. Data propagation layer is critical.",
    recommendation: "Implement robust shred verification. Use erasure coding for data recovery."
  },
  {
    id: "SOL4852",
    name: "Durable Nonce Replay Vulnerability",
    severity: "critical",
    pattern: /durable.*nonce|nonce.*replay(?![\s\S]{0,100}advance_nonce|[\s\S]{0,100}unique_nonce)/i,
    description: "Solana durable nonce bug allowed potential transaction replay. Fixed in 2022.",
    recommendation: "Always advance nonce after use. Verify nonce state before transaction execution."
  },
  {
    id: "SOL4853",
    name: "Duplicate Block Production",
    severity: "critical",
    pattern: /duplicate.*block|block.*production(?![\s\S]{0,100}leader_verification|[\s\S]{0,100}slot_unique)/i,
    description: "Duplicate block bug 2023 could cause chain forks. Validator consensus critical.",
    recommendation: "Verify leader schedule before block production. Implement fork detection."
  },
  {
    id: "SOL4854",
    name: "JIT Cache Execution Bug",
    severity: "critical",
    pattern: /jit.*cache|cache.*execution|bpf.*jit(?![\s\S]{0,100}cache_invalidation|[\s\S]{0,100}verify_compiled)/i,
    description: "JIT cache bug 2024 caused 5-hour outage. Compiled program caching needs validation.",
    recommendation: "Implement cache invalidation checks. Verify compiled code matches source."
  },
  {
    id: "SOL4855",
    name: "ELF Address Alignment Vulnerability",
    severity: "critical",
    pattern: /elf.*alignment|address.*alignment|memory.*align(?![\s\S]{0,100}verify_alignment|[\s\S]{0,100}aligned\()/i,
    description: "ELF address alignment bug 2024 could cause program crashes. Memory safety critical.",
    recommendation: "Verify ELF section alignment. Use #[repr(align)] for critical structures."
  },
  // Cope Roulette Reverting Transaction Exploit
  {
    id: "SOL4856",
    name: "Cope Roulette Revert Exploit Pattern",
    severity: "critical",
    pattern: /revert.*check|simulation.*detect|simulate.*revert(?![\s\S]{0,100}random_seed|[\s\S]{0,100}commitment)/i,
    description: "Cope Roulette exploit: simulate transaction, revert if unfavorable, retry until win. Solsec PoC.",
    recommendation: "Use commit-reveal schemes for randomness. Make outcome independent of simulation."
  },
  {
    id: "SOL4857",
    name: "Predictable Random Outcome",
    severity: "critical",
    pattern: /random.*outcome|gambling.*random(?![\s\S]{0,100}vrf|[\s\S]{0,100}commit_reveal|[\s\S]{0,100}external_entropy)/i,
    description: "Gambling/lottery contracts vulnerable if outcome can be predicted before commitment.",
    recommendation: "Use VRF (Verifiable Random Function) or commit-reveal for unpredictable outcomes."
  },
  // Port Finance Rounding Attack
  {
    id: "SOL4858",
    name: "Port Finance $2.6B Rounding Attack",
    severity: "critical",
    pattern: /rounding.*error|rounding.*attack|interest.*rounding(?![\s\S]{0,100}floor_only|[\s\S]{0,100}round_down)/i,
    description: "Port Finance rounding bug put $2.6B at risk. Neodyme disclosure. Small rounding errors compound.",
    recommendation: "Always round in protocol's favor (floor for rewards, ceil for debts). Use high precision."
  },
  {
    id: "SOL4859",
    name: "Lending Interest Calculation Precision",
    severity: "high",
    pattern: /interest.*calculation|calculate.*interest(?![\s\S]{0,100}high_precision|[\s\S]{0,100}u128|[\s\S]{0,100}decimal)/i,
    description: "Interest calculations need high precision to prevent exploitation via many small transactions.",
    recommendation: "Use u128/u256 for intermediate calculations. Implement minimum amounts."
  },
  // Jet Protocol Break Bug
  {
    id: "SOL4860",
    name: "Jet Protocol Break Statement Bug",
    severity: "critical",
    pattern: /break[\s]*;|early.*return(?![\s\S]{0,100}validate_state|[\s\S]{0,100}post_condition)/i,
    description: "Jet Protocol bug: misplaced break statement allowed full treasury withdrawal. Jayne disclosure.",
    recommendation: "Review all break/return statements. Ensure state validation after early exits."
  },
  {
    id: "SOL4861",
    name: "Unintended Loop Exit Vulnerability",
    severity: "high",
    pattern: /for\s*\([\s\S]{0,50}break|while[\s\S]{0,50}break(?![\s\S]{0,30}after_check)/,
    description: "Unintended break in loops can skip critical validation. Jet Protocol exploit pattern.",
    recommendation: "Validate loop completion. Ensure all iterations execute critical checks."
  },
  // Schrodinger NFT + Incinerator Attack Chain
  {
    id: "SOL4862",
    name: "Exploit Chaining Pattern",
    severity: "critical",
    pattern: /chain.*exploit|combined.*attack|sequential.*vulnerability(?![\s\S]{0,100}defense_in_depth)/i,
    description: "Schrodinger NFT: small exploits chained into major attack. samczsun explains exploit chaining.",
    recommendation: "Implement defense-in-depth. Each layer should independently prevent exploitation."
  },
  {
    id: "SOL4863",
    name: "NFT Incinerator Contract Abuse",
    severity: "high",
    pattern: /incinerator|burn.*nft|nft.*burn(?![\s\S]{0,100}verify_owner|[\s\S]{0,100}authentic_mint)/i,
    description: "Incinerator contracts can be abused to claim rewards for burning fake NFTs.",
    recommendation: "Verify NFT mint authority and collection before accepting burns."
  },
  // Solend Malicious Lending Market
  {
    id: "SOL4864",
    name: "Fake Lending Market Creation",
    severity: "critical",
    pattern: /create.*market|new.*lending.*market(?![\s\S]{0,100}authorized|[\s\S]{0,100}whitelist)/i,
    description: "Rooter disclosed: anyone could create lending market in Solend, bypassing intended access controls.",
    recommendation: "Restrict market creation to authorized accounts. Validate all market parameters."
  },
  // SPL Token Approve Revocation
  {
    id: "SOL4865",
    name: "SPL Token Approval Not Revoked",
    severity: "high",
    pattern: /approve.*token|token.*approval(?![\s\S]{0,100}revoke|[\s\S]{0,100}expiry|[\s\S]{0,100}limited)/i,
    description: "Hana's tool: users forget to revoke token approvals, leaving funds at risk.",
    recommendation: "Prompt users to revoke approvals. Implement approval expiry or limited amounts."
  },
  // OtterSec LP Token Oracle Manipulation
  {
    id: "SOL4866",
    name: "LP Token Fair Pricing Bypass",
    severity: "critical",
    pattern: /lp.*token.*price|lp.*oracle(?![\s\S]{0,100}fair_price|[\s\S]{0,100}reserve_ratio)/i,
    description: "OtterSec $200M bluff: LP token oracle manipulation via AMM price movement.",
    recommendation: "Use fair pricing formulas for LP tokens. Calculate from reserves, not spot price."
  },
  {
    id: "SOL4867",
    name: "AMM Price to Oracle Manipulation",
    severity: "critical",
    pattern: /amm.*price|spot.*price.*oracle(?![\s\S]{0,100}twap|[\s\S]{0,100}manipulation_check)/i,
    description: "Moving AMM price to manipulate oracle, then exploit lending protocol. OtterSec research.",
    recommendation: "Never use spot AMM prices for oracle. Use TWAP with long enough window."
  },
  // Drift Oracle Guardrails
  {
    id: "SOL4868",
    name: "Missing Oracle Guardrails",
    severity: "high",
    pattern: /oracle.*price[\s\S]{0,50}(?!guardrail|guard|valid|stale|confidence)/i,
    description: "Drift implements oracle guardrails. Protocols should have price deviation limits.",
    recommendation: "Implement Drift-style guardrails: price bands, staleness checks, confidence intervals."
  },
  // Neodyme Lending Vulnerability $2.6B
  {
    id: "SOL4869",
    name: "SPL Lending Rounding Vulnerability",
    severity: "critical",
    pattern: /spl.*lending|lending.*rounding(?![\s\S]{0,100}floor|[\s\S]{0,100}minimum_amount)/i,
    description: "Neodyme found: innocent rounding error in SPL lending put $2.6B at risk.",
    recommendation: "Use floor for interest calculations. Implement minimum deposit/withdraw amounts."
  },
  // BlockSec rBPF Integer Overflow
  {
    id: "SOL4870",
    name: "rBPF Virtual Machine Overflow",
    severity: "critical",
    pattern: /rbpf|bpf.*vm|vm.*integer(?![\s\S]{0,100}bounds_check|[\s\S]{0,100}checked_)/i,
    description: "BlockSec found integer overflow in Solana rBPF VM. Core infrastructure vulnerability.",
    recommendation: "Use checked arithmetic in VM implementations. Audit all low-level code."
  },
  // Sec3 Arithmetic Overflow/Underflow
  {
    id: "SOL4871",
    name: "Unchecked Math Operations",
    severity: "high",
    pattern: /\+\s*\d+|\-\s*\d+|\*\s*\d+(?![\s\S]{0,30}checked_|[\s\S]{0,30}saturating_)/,
    description: "Sec3: Don't use +, -, /, * directly. Always use checked operations.",
    recommendation: "Use checked_add, checked_sub, checked_mul, checked_div, or saturating variants."
  },
  // Armani Sealevel Attack Patterns
  {
    id: "SOL4872",
    name: "Sealevel Missing Owner Check",
    severity: "critical",
    pattern: /AccountInfo[\s\S]{0,100}(?!owner\s*==|key\s*==|has_one)/,
    description: "Armani Sealevel Attacks: Missing owner check allows passing malicious accounts.",
    recommendation: "Always check account.owner == expected_program before trusting account data."
  },
  {
    id: "SOL4873",
    name: "Sealevel Missing Signer Check",
    severity: "critical",
    pattern: /authority[\s\S]{0,50}AccountInfo(?![\s\S]{0,30}is_signer|[\s\S]{0,30}Signer)/i,
    description: "Armani: Authority accounts must verify is_signer to prevent unauthorized actions.",
    recommendation: "Use Signer<> type in Anchor or verify is_signer manually in native."
  },
  {
    id: "SOL4874",
    name: "Sealevel Account Data Confusion",
    severity: "critical",
    pattern: /deserialize|try_from_slice(?![\s\S]{0,50}discriminator|[\s\S]{0,50}account_type)/i,
    description: "Armani: Deserialization without type checking allows account confusion attacks.",
    recommendation: "Verify 8-byte discriminator before deserializing. Use Anchor #[account] types."
  },
  {
    id: "SOL4875",
    name: "Sealevel Initialization Check Missing",
    severity: "critical",
    pattern: /init[\s\S]{0,30}=[\s\S]{0,30}(false|0)(?![\s\S]{0,50}require!|[\s\S]{0,50}assert)/,
    description: "Armani: Missing initialization check allows reinitializing accounts with attacker data.",
    recommendation: "Check is_initialized before any account modification. Use init constraint."
  },
  // Advanced 2026 Patterns
  {
    id: "SOL4876",
    name: "AI Agent Wallet Security",
    severity: "critical",
    pattern: /ai.*agent|agent.*wallet|autonomous.*transaction(?![\s\S]{0,100}spending_limit|[\s\S]{0,100}approval)/i,
    description: "2026: AI agents need spending limits and human approval for large transactions.",
    recommendation: "Implement spending limits, transaction whitelists, and human-in-the-loop for high-value ops."
  },
  {
    id: "SOL4877",
    name: "Token-2022 Transfer Hook Reentrancy",
    severity: "critical",
    pattern: /transfer.*hook|TransferHook(?![\s\S]{0,100}reentrancy_guard|[\s\S]{0,100}nonreentrant)/i,
    description: "Token-2022 transfer hooks can enable reentrancy. Guard against recursive calls.",
    recommendation: "Implement reentrancy guard in transfer hooks. Update state before external calls."
  },
  {
    id: "SOL4878",
    name: "Token-2022 Confidential Transfer Validation",
    severity: "critical",
    pattern: /confidential.*transfer|encrypted.*amount(?![\s\S]{0,100}verify_proof|[\s\S]{0,100}range_proof)/i,
    description: "Confidential transfers need proper zero-knowledge proof validation.",
    recommendation: "Always verify ZK proofs for confidential transfers. Validate range proofs."
  },
  {
    id: "SOL4879",
    name: "Permanent Delegate Abuse",
    severity: "high",
    pattern: /permanent.*delegate|PermanentDelegate(?![\s\S]{0,100}user_consent|[\s\S]{0,100}warning)/i,
    description: "Token-2022 permanent delegate can burn/transfer without approval. High risk extension.",
    recommendation: "Warn users about permanent delegates. Consider disallowing for high-value tokens."
  },
  {
    id: "SOL4880",
    name: "Compressed NFT Proof Manipulation",
    severity: "critical",
    pattern: /merkle.*proof|cnft.*proof(?![\s\S]{0,100}verify_root|[\s\S]{0,100}concurrent_merkle)/i,
    description: "Compressed NFT proofs must be verified against current merkle root.",
    recommendation: "Always verify proof against on-chain merkle root. Handle concurrent modifications."
  },
  // Validator Concentration Risks
  {
    id: "SOL4881",
    name: "Validator Stake Concentration",
    severity: "high",
    pattern: /validator.*stake|stake.*concentration(?![\s\S]{0,100}decentralization|[\s\S]{0,100}diverse)/i,
    description: "High stake concentration in few validators = centralization risk. Affects security.",
    recommendation: "Encourage stake distribution. Monitor Nakamoto coefficient for protocol health."
  },
  {
    id: "SOL4882",
    name: "Geographic Validator Concentration",
    severity: "medium",
    pattern: /validator.*location|geographic.*concentration(?![\s\S]{0,100}diverse|[\s\S]{0,100}distributed)/i,
    description: "Validators concentrated in single jurisdiction = regulatory and infrastructure risk.",
    recommendation: "Encourage geographic diversity. Avoid single-point-of-failure locations."
  },
  // LUT (Lookup Table) Security
  {
    id: "SOL4883",
    name: "Address Lookup Table Spoofing",
    severity: "high",
    pattern: /lookup.*table|address.*lut(?![\s\S]{0,100}verify_authority|[\s\S]{0,100}trusted_table)/i,
    description: "Malicious lookup tables can redirect to attacker accounts. Verify LUT authority.",
    recommendation: "Only use LUTs from trusted sources. Verify table authority before using."
  },
  // DePIN Security
  {
    id: "SOL4884",
    name: "DePIN Node Verification Bypass",
    severity: "high",
    pattern: /node.*verification|depin.*node(?![\s\S]{0,100}proof_of_work|[\s\S]{0,100}hardware_attestation)/i,
    description: "DePIN protocols vulnerable to fake nodes (io.net Sybil). Need hardware attestation.",
    recommendation: "Implement hardware attestation, proof-of-work challenges, or stake requirements."
  },
  {
    id: "SOL4885",
    name: "DePIN Reward Manipulation",
    severity: "high",
    pattern: /depin.*reward|compute.*reward(?![\s\S]{0,100}verify_work|[\s\S]{0,100}proof_of_compute)/i,
    description: "DePIN rewards can be farmed with fake work. Verify actual computation/storage.",
    recommendation: "Implement verifiable computation proofs. Random sampling of work quality."
  },
  // Blink Actions Security
  {
    id: "SOL4886",
    name: "Blink Action URL Injection",
    severity: "critical",
    pattern: /blink.*action|action.*url(?![\s\S]{0,100}sanitize|[\s\S]{0,100}whitelist)/i,
    description: "Blink actions can embed malicious transactions. Verify action URLs.",
    recommendation: "Whitelist allowed action domains. Show clear transaction preview before signing."
  },
  {
    id: "SOL4887",
    name: "Social Media Blink Phishing",
    severity: "high",
    pattern: /twitter.*blink|social.*action(?![\s\S]{0,100}verified_creator|[\s\S]{0,100}trusted_source)/i,
    description: "Malicious blinks embedded in social media can steal funds.",
    recommendation: "Only interact with blinks from verified creators. Check destination before signing."
  },
  // Priority Fee Manipulation
  {
    id: "SOL4888",
    name: "Priority Fee Front-running",
    severity: "medium",
    pattern: /priority.*fee|compute.*unit.*price(?![\s\S]{0,100}dynamic_fee|[\s\S]{0,100}private_mempool)/i,
    description: "Priority fees visible in mempool enable front-running. Use private mempools.",
    recommendation: "Use Jito or private transaction submission. Implement slippage protection."
  },
  // Cross-Margin Liquidation
  {
    id: "SOL4889",
    name: "Cross-Margin Cascade Liquidation",
    severity: "critical",
    pattern: /cross.*margin|portfolio.*margin(?![\s\S]{0,100}isolated_mode|[\s\S]{0,100}position_limit)/i,
    description: "Cross-margin can cause cascade liquidations. One position loss affects all.",
    recommendation: "Offer isolated margin mode. Implement position size limits per asset."
  },
  // Restaking Security
  {
    id: "SOL4890",
    name: "Restaking Slashing Risk",
    severity: "high",
    pattern: /restaking|restake|liquid.*staking(?![\s\S]{0,100}slashing_insurance|[\s\S]{0,100}risk_disclosure)/i,
    description: "Restaking compounds slashing risk. One slash can affect multiple protocols.",
    recommendation: "Disclose restaking risks. Implement slashing insurance or caps."
  },
  // Intent-Based Architecture
  {
    id: "SOL4891",
    name: "Intent Solver Manipulation",
    severity: "critical",
    pattern: /intent.*solver|solve.*intent(?![\s\S]{0,100}verify_execution|[\s\S]{0,100}user_signature)/i,
    description: "Intent-based systems rely on solvers. Malicious solvers can exploit intents.",
    recommendation: "Verify solver execution matches intent. Require user signature on final transaction."
  },
  // Real-Time Oracle Security
  {
    id: "SOL4892",
    name: "Pyth Pull Oracle Stale Data",
    severity: "high",
    pattern: /pyth.*price|pull.*oracle(?![\s\S]{0,100}publishTime|[\s\S]{0,100}staleness_check)/i,
    description: "Pyth pull oracles can return stale data if not refreshed. Check publishTime.",
    recommendation: "Always check Pyth publishTime. Reject prices older than acceptable threshold."
  },
  {
    id: "SOL4893",
    name: "Switchboard On-Demand Latency",
    severity: "medium",
    pattern: /switchboard.*oracle|on_demand.*oracle(?![\s\S]{0,100}latency_check|[\s\S]{0,100}freshness)/i,
    description: "On-demand oracles have latency. High-frequency operations need fresher data.",
    recommendation: "Use appropriate oracle for use case. Check data freshness for time-sensitive ops."
  },
  // Session Key Security
  {
    id: "SOL4894",
    name: "Session Key Over-Permission",
    severity: "high",
    pattern: /session.*key|session.*token(?![\s\S]{0,100}scope_limit|[\s\S]{0,100}expiry)/i,
    description: "Session keys with too many permissions = security risk. Thunder Terminal exploit.",
    recommendation: "Limit session key scope to minimum required. Add short expiry times."
  },
  {
    id: "SOL4895",
    name: "Glow Wallet Session Key Abuse",
    severity: "high",
    pattern: /glow.*session|wallet.*session(?![\s\S]{0,100}user_approval|[\s\S]{0,100}transaction_limit)/i,
    description: "Session keys in wallets need transaction limits and user approval for sensitive ops.",
    recommendation: "Require user confirmation for session key creation. Limit transaction value/count."
  },
  // Governance Timing Attacks
  {
    id: "SOL4896",
    name: "Governance Proposal Flash Attack",
    severity: "critical",
    pattern: /proposal.*vote|governance.*vote(?![\s\S]{0,100}lock_period|[\s\S]{0,100}voting_delay)/i,
    description: "Flash loan to borrow governance tokens, vote, return. Audius pattern.",
    recommendation: "Implement voting power snapshot at proposal creation. Add voting delay period."
  },
  {
    id: "SOL4897",
    name: "Governance Quorum Manipulation",
    severity: "critical",
    pattern: /quorum.*check|governance.*quorum(?![\s\S]{0,100}snapshot_block|[\s\S]{0,100}time_lock)/i,
    description: "Quorum can be gamed by waiting for low participation. Add minimum thresholds.",
    recommendation: "Use relative quorum (% of total supply). Implement minimum participation threshold."
  },
  // Multisig Security
  {
    id: "SOL4898",
    name: "Squads Multisig Configuration",
    severity: "high",
    pattern: /squads|multisig(?![\s\S]{0,100}threshold_check|[\s\S]{0,100}member_verify)/i,
    description: "Multisig configurations must be verified. Low threshold = centralization risk.",
    recommendation: "Set appropriate threshold (e.g., 3/5). Verify all signers are independent parties."
  },
  {
    id: "SOL4899",
    name: "Multisig Member Key Compromise",
    severity: "critical",
    pattern: /multisig.*member|signer.*key(?![\s\S]{0,100}hardware_wallet|[\s\S]{0,100}mpc)/i,
    description: "Single multisig member key compromise reduces security. Raydium lost $4.4M this way.",
    recommendation: "Require hardware wallets for multisig members. Implement MPC where possible."
  },
  {
    id: "SOL4900",
    name: "Emergency Response Timelock Bypass",
    severity: "critical",
    pattern: /emergency.*bypass|timelock.*override(?![\s\S]{0,100}guardian|[\s\S]{0,100}security_council)/i,
    description: "Emergency bypasses of timelocks need strict governance. Audius-style attacks.",
    recommendation: "Emergency actions require security council approval. Log and alert on all bypasses."
  }
];
function checkBatch88Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_88_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}

// src/patterns/solana-batched-patterns-89.ts
var BATCH_89_PATTERNS = [
  // Zellic "Vulnerabilities You'll Write With Anchor" Patterns
  {
    id: "SOL4901",
    name: "Zellic - Missing Account Discriminator Check",
    severity: "critical",
    pattern: /try_from_slice|from_account_info(?![\s\S]{0,50}discriminator|[\s\S]{0,50}DISCRIMINATOR)/i,
    description: "Zellic: Anchor adds 8-byte discriminator but manual deserialization may skip it. Type confusion attack.",
    recommendation: "Always verify 8-byte discriminator matches expected account type before deserializing."
  },
  {
    id: "SOL4902",
    name: "Zellic - init_if_needed Race Condition",
    severity: "critical",
    pattern: /init_if_needed(?![\s\S]{0,100}mutex|[\s\S]{0,100}atomic)/i,
    description: "Zellic: init_if_needed can cause race conditions. Multiple transactions can initialize with different data.",
    recommendation: "Avoid init_if_needed in production. Use separate init instruction with proper checks."
  },
  {
    id: "SOL4903",
    name: "Zellic - Account Reinitialization via init_if_needed",
    severity: "critical",
    pattern: /init_if_needed[\s\S]{0,100}data/i,
    description: "Zellic: init_if_needed doesn't prevent reinit if account exists but is empty.",
    recommendation: "Check is_initialized flag before using account data. Prefer explicit init instruction."
  },
  {
    id: "SOL4904",
    name: "Zellic - Anchor Context Remaining Accounts",
    severity: "high",
    pattern: /remaining_accounts|ctx\.remaining_accounts(?![\s\S]{0,100}verify|[\s\S]{0,100}validate)/i,
    description: "Zellic: remaining_accounts bypass Anchor's type checks. Attackers can pass arbitrary accounts.",
    recommendation: "Validate all remaining_accounts manually: check owner, program_id, data type."
  },
  {
    id: "SOL4905",
    name: "Zellic - Seeds Constraint Without Bump",
    severity: "high",
    pattern: /seeds\s*=[\s\S]{0,50}(?!bump)/i,
    description: "Zellic: Seeds constraint without bump allows non-canonical PDA. Attacker can create spoofed accounts.",
    recommendation: 'Always include bump in seeds constraint: seeds = [b"prefix"], bump = account.bump'
  },
  {
    id: "SOL4906",
    name: "Zellic - Hardcoded Bump Seed",
    severity: "high",
    pattern: /bump\s*=\s*\d+|bump\s*=\s*255/i,
    description: "Zellic: Hardcoded bump seeds are dangerous. Only canonical bump (highest valid) should be used.",
    recommendation: "Store and use the canonical bump from find_program_address, not hardcoded values."
  },
  {
    id: "SOL4907",
    name: "Zellic - Missing has_one Constraint",
    severity: "critical",
    pattern: /authority[\s\S]{0,30}AccountInfo(?![\s\S]{0,50}has_one|[\s\S]{0,50}constraint)/i,
    description: "Zellic: Authority accounts without has_one constraint allow passing any account.",
    recommendation: "Add has_one = authority constraint to verify account relationship."
  },
  {
    id: "SOL4908",
    name: "Zellic - Constraint Ordering Issue",
    severity: "medium",
    pattern: /mut[\s\S]{0,20}close(?![\s\S]{0,30}=[\s\S]{0,10}destination)/i,
    description: "Zellic: Close constraint should specify destination. Funds may go to unexpected account.",
    recommendation: "Always specify close = destination_account to control where lamports go."
  },
  {
    id: "SOL4909",
    name: "Zellic - Signer Type vs is_signer Check",
    severity: "critical",
    pattern: /AccountInfo[\s\S]{0,30}authority(?![\s\S]{0,50}Signer|[\s\S]{0,50}is_signer)/i,
    description: "Zellic: Using AccountInfo instead of Signer<> for authority doesn't verify signature.",
    recommendation: "Use Signer<'info> type for authority accounts or manually check is_signer."
  },
  {
    id: "SOL4910",
    name: "Zellic - UncheckedAccount Without Safety Check",
    severity: "critical",
    pattern: /UncheckedAccount|AccountInfo(?![\s\S]{0,30}\/\/\/\s*CHECK|[\s\S]{0,30}#\[account\()/i,
    description: "Zellic: UncheckedAccount requires manual validation. Anchor requires /// CHECK comment.",
    recommendation: "Add /// CHECK: <reason> comment and implement manual validation for unchecked accounts."
  },
  // Cantina Security Guide Patterns
  {
    id: "SOL4911",
    name: "Cantina - 48M CU Compute Limit Exceeded",
    severity: "high",
    pattern: /compute|ComputeBudget(?![\s\S]{0,100}request_units|[\s\S]{0,100}limit_check)/i,
    description: "Cantina: Exceeding 48M CU limit causes transaction failure. Can be exploited to disrupt dApps.",
    recommendation: "Monitor compute usage. Split large operations. Add compute budget checks."
  },
  {
    id: "SOL4912",
    name: "Cantina - Heap Memory Exhaustion",
    severity: "high",
    pattern: /Vec::with_capacity|vec!\[[\s\S]{0,10}\d{5,}|alloc/i,
    description: "Cantina: Solana programs have 32KB heap limit. Large allocations cause OOM.",
    recommendation: "Minimize heap allocations. Use stack where possible. Check allocation sizes."
  },
  {
    id: "SOL4913",
    name: "Cantina - Stack Overflow in Recursion",
    severity: "high",
    pattern: /fn\s+\w+[\s\S]{0,50}->[\s\S]{0,100}self\.\w+\(|recursion|recursive/i,
    description: "Cantina: Deep recursion exhausts 4KB stack. Use iteration instead.",
    recommendation: "Convert recursive algorithms to iterative. Limit recursion depth."
  },
  {
    id: "SOL4914",
    name: "Cantina - Outdated Dependency Vulnerability",
    severity: "high",
    pattern: /Cargo\.toml|dependencies|version\s*=\s*"0\./i,
    description: "Cantina: Using outdated dependencies is common security risk. Web3.js backdoor example.",
    recommendation: "Keep dependencies updated. Run cargo audit. Pin exact versions in Cargo.lock."
  },
  {
    id: "SOL4915",
    name: "Cantina - Account Data Size Manipulation",
    severity: "high",
    pattern: /realloc|data_len|data\.len\(\)(?![\s\S]{0,50}require!|[\s\S]{0,50}assert)/i,
    description: "Cantina: Account data size can be manipulated. Validate expected size before use.",
    recommendation: "Check data.len() matches expected struct size. Reject accounts with wrong size."
  },
  {
    id: "SOL4916",
    name: "Cantina - CPI Depth Limit Exceeded",
    severity: "high",
    pattern: /invoke|invoke_signed(?![\s\S]{0,100}depth_check)/i,
    description: "Cantina: CPI has 4-level depth limit. Deep call chains fail unexpectedly.",
    recommendation: "Track CPI depth. Design programs to minimize nesting. Max 4 levels of invoke."
  },
  {
    id: "SOL4917",
    name: "Cantina - Return Data Size Limit",
    severity: "medium",
    pattern: /set_return_data|return_data(?![\s\S]{0,50}truncate|[\s\S]{0,50}len\s*<)/i,
    description: "Cantina: Return data limited to 1024 bytes. Large returns silently truncate.",
    recommendation: "Keep return data under 1024 bytes. Use account storage for larger data."
  },
  {
    id: "SOL4918",
    name: "Cantina - Transaction Size Limit",
    severity: "medium",
    pattern: /transaction|tx(?![\s\S]{0,100}size_check|[\s\S]{0,100}1232)/i,
    description: "Cantina: Transaction size limited to 1232 bytes. Use versioned transactions and LUTs.",
    recommendation: "Optimize instruction data. Use Address Lookup Tables for many accounts."
  },
  {
    id: "SOL4919",
    name: "Cantina - Sysvars via Account Instead of Get",
    severity: "medium",
    pattern: /Clock::get|Rent::get(?![\s\S]{0,10}\(\))/i,
    description: "Cantina: Prefer Sysvar::get() over passing sysvar account. Saves account space.",
    recommendation: "Use Clock::get()?, Rent::get()? instead of sysvar account parameters."
  },
  {
    id: "SOL4920",
    name: "Cantina - Log Instruction Spam",
    severity: "low",
    pattern: /msg!\([\s\S]{0,100}\)|sol_log|emit!/i,
    description: "Cantina: Excessive logging increases compute cost and can leak information.",
    recommendation: "Minimize production logging. Remove debug logs. Don't log sensitive data."
  },
  // Advanced DeFi Attack Patterns
  {
    id: "SOL4921",
    name: "JIT Liquidity Attack",
    severity: "critical",
    pattern: /add.*liquidity[\s\S]{0,100}remove.*liquidity|jit.*liquidity/i,
    description: "JIT liquidity: Add liquidity before swap, earn fees, remove after. MEV attack on AMMs.",
    recommendation: "Implement LP lockup period. Use time-weighted fee distribution."
  },
  {
    id: "SOL4922",
    name: "Sandwich Attack on Swaps",
    severity: "critical",
    pattern: /swap(?![\s\S]{0,100}slippage|[\s\S]{0,100}min_output|[\s\S]{0,100}deadline)/i,
    description: "Sandwich attacks: Front-run swap to inflate price, back-run to profit. User loses to slippage.",
    recommendation: "Implement slippage protection. Use deadline parameter. Consider private submission."
  },
  {
    id: "SOL4923",
    name: "Atomic Arbitrage Profit Extraction",
    severity: "high",
    pattern: /arbitrage|price.*difference(?![\s\S]{0,100}atomic_check)/i,
    description: "Atomic arbitrage extracts value from price discrepancies. Impacts protocol efficiency.",
    recommendation: "Use oracles with manipulation resistance. Implement trading fees to reduce arb profit."
  },
  {
    id: "SOL4924",
    name: "Interest Rate Manipulation",
    severity: "critical",
    pattern: /interest.*rate|utilization.*rate(?![\s\S]{0,100}cap|[\s\S]{0,100}max_rate)/i,
    description: "Interest rates can be manipulated by strategic borrows/repays. Rate caps needed.",
    recommendation: "Implement interest rate caps. Use gradual rate adjustments. Add utilization smoothing."
  },
  {
    id: "SOL4925",
    name: "Bad Debt Socialization",
    severity: "critical",
    pattern: /bad.*debt|underwater.*position(?![\s\S]{0,100}insurance|[\s\S]{0,100}backstop)/i,
    description: "Underwater positions create bad debt. Socializing to LPs is unfair without insurance.",
    recommendation: "Build insurance fund from fees. Implement partial liquidations. Add backstop mechanisms."
  },
  {
    id: "SOL4926",
    name: "Yield Aggregator Vault Strategy Manipulation",
    severity: "high",
    pattern: /vault.*strategy|strategy.*yield(?![\s\S]{0,100}verified_strategy|[\s\S]{0,100}whitelist)/i,
    description: "Malicious strategies in yield aggregators can drain vault funds.",
    recommendation: "Whitelist approved strategies. Implement strategy timelock. Audit all strategies."
  },
  {
    id: "SOL4927",
    name: "Vault Share Inflation Attack",
    severity: "critical",
    pattern: /vault.*share|share.*mint(?![\s\S]{0,100}minimum_shares|[\s\S]{0,100}initial_deposit)/i,
    description: "First depositor can inflate share price, stealing from subsequent depositors.",
    recommendation: "Require minimum initial deposit. Implement virtual shares or dead shares."
  },
  {
    id: "SOL4928",
    name: "Donation Attack on Vaults",
    severity: "critical",
    pattern: /vault.*balance|assets.*per.*share(?![\s\S]{0,100}exclude_donation)/i,
    description: "Donating assets to vault inflates share price, causing rounding issues.",
    recommendation: "Track deposited vs total assets. Use internal accounting immune to donations."
  },
  {
    id: "SOL4929",
    name: "Lending Protocol Utilization Manipulation",
    severity: "high",
    pattern: /utilization|borrow.*available(?![\s\S]{0,100}minimum_liquidity)/i,
    description: "Manipulating utilization to 100% prevents withdrawals. Liquidity crisis attack.",
    recommendation: "Reserve minimum liquidity. Implement dynamic interest rates that spike at high utilization."
  },
  {
    id: "SOL4930",
    name: "Collateral Factor Manipulation",
    severity: "critical",
    pattern: /collateral.*factor|ltv(?![\s\S]{0,100}oracle|[\s\S]{0,100}time_weighted)/i,
    description: "Collateral factors based on spot prices can be manipulated. Use oracle-based valuation.",
    recommendation: "Use time-weighted oracle prices. Implement per-asset caps. Add liquidation buffer."
  },
  // Protocol-Specific Attack Patterns
  {
    id: "SOL4931",
    name: "Orca Whirlpool Tick Boundary Issue",
    severity: "high",
    pattern: /tick.*boundary|tick_lower|tick_upper(?![\s\S]{0,100}tick_spacing)/i,
    description: "CLMM tick boundaries must align with tick spacing. Misalignment causes unexpected behavior.",
    recommendation: "Verify ticks are divisible by tick_spacing. Use SDK helpers for tick calculations."
  },
  {
    id: "SOL4932",
    name: "Raydium CLMM Position NFT Validation",
    severity: "high",
    pattern: /position.*nft|nft.*position(?![\s\S]{0,100}owner_check|[\s\S]{0,100}mint_check)/i,
    description: "CLMM positions represented as NFTs. Must verify NFT ownership and mint.",
    recommendation: "Verify position NFT owner matches expected. Validate NFT mint authority."
  },
  {
    id: "SOL4933",
    name: "Marinade Stake Account Validation",
    severity: "high",
    pattern: /stake.*account|stake_deposit(?![\s\S]{0,100}validator_check|[\s\S]{0,100}state_check)/i,
    description: "Stake accounts must be validated before accepting in liquid staking protocols.",
    recommendation: "Verify stake account state, validator, and activation epoch."
  },
  {
    id: "SOL4934",
    name: "Jupiter Aggregator Route Validation",
    severity: "high",
    pattern: /route|swap.*route(?![\s\S]{0,100}slippage|[\s\S]{0,100}intermediate_check)/i,
    description: "Swap routes through aggregators can be manipulated. Validate intermediate steps.",
    recommendation: "Set strict slippage on each hop. Use versioned routes with price impact limits."
  },
  {
    id: "SOL4935",
    name: "Pyth Price Account Ownership",
    severity: "critical",
    pattern: /pyth.*price|price.*feed(?![\s\S]{0,100}owner\s*==|[\s\S]{0,100}PYTH_PROGRAM)/i,
    description: "Fake Pyth price accounts can be created. Always verify owner is Pyth program.",
    recommendation: "Check price_account.owner == PYTH_PROGRAM_ID before using price data."
  },
  {
    id: "SOL4936",
    name: "Switchboard Aggregator Validation",
    severity: "high",
    pattern: /switchboard|aggregator(?![\s\S]{0,100}authority_check|[\s\S]{0,100}job_check)/i,
    description: "Switchboard aggregators must be validated. Check authority and job configuration.",
    recommendation: "Verify aggregator authority and queue. Check minimum oracles and job count."
  },
  {
    id: "SOL4937",
    name: "Metaplex Metadata Account Spoofing",
    severity: "high",
    pattern: /metadata.*account|token_metadata(?![\s\S]{0,100}owner\s*==|[\s\S]{0,100}METADATA_PROGRAM)/i,
    description: "Metadata accounts can be spoofed if owner not verified. Fake NFT metadata attacks.",
    recommendation: "Verify metadata.owner == TOKEN_METADATA_PROGRAM_ID. Validate PDA derivation."
  },
  {
    id: "SOL4938",
    name: "Bubblegum cNFT Creator Verification",
    severity: "high",
    pattern: /cnft|compressed.*nft(?![\s\S]{0,100}creator_verified|[\s\S]{0,100}collection_verified)/i,
    description: "Compressed NFTs need creator verification. Anyone can set unverified creators.",
    recommendation: "Check creator.verified == true. Verify collection membership on-chain."
  },
  {
    id: "SOL4939",
    name: "SPL Governance Realm Configuration",
    severity: "high",
    pattern: /realm|governance.*config(?![\s\S]{0,100}community_mint|[\s\S]{0,100}council_mint)/i,
    description: "SPL Governance realms need proper mint configuration. Misconfig allows takeover.",
    recommendation: "Verify realm community_mint and council_mint. Set appropriate voting thresholds."
  },
  {
    id: "SOL4940",
    name: "Squads v4 Multisig Time Lock",
    severity: "high",
    pattern: /squads|multisig.*time(?![\s\S]{0,100}time_lock|[\s\S]{0,100}execution_delay)/i,
    description: "Squads v4 supports timelocks. High-value operations should have delays.",
    recommendation: "Enable timelock for treasury operations. Set appropriate execution delay."
  },
  // 2026 Emerging Attack Vectors
  {
    id: "SOL4941",
    name: "AI Agent Autonomous Trading Exploit",
    severity: "critical",
    pattern: /autonomous.*trade|ai.*execute(?![\s\S]{0,100}human_approval|[\s\S]{0,100}limit_check)/i,
    description: "2026: AI agents with autonomous trading can be exploited via adversarial inputs.",
    recommendation: "Implement trading limits. Require human approval above thresholds. Add circuit breakers."
  },
  {
    id: "SOL4942",
    name: "LLM Prompt Injection in dApps",
    severity: "critical",
    pattern: /llm|gpt|claude(?![\s\S]{0,100}sanitize|[\s\S]{0,100}filter_input)/i,
    description: "2026: dApps using LLMs vulnerable to prompt injection. Malicious inputs can bypass controls.",
    recommendation: "Sanitize all LLM inputs. Implement output validation. Use structured data extraction."
  },
  {
    id: "SOL4943",
    name: "Cross-Chain Message Replay",
    severity: "critical",
    pattern: /cross.*chain.*message|bridge.*message(?![\s\S]{0,100}nonce|[\s\S]{0,100}sequence)/i,
    description: "Cross-chain messages without nonces can be replayed. Double-spend across chains.",
    recommendation: "Include unique nonce/sequence in all cross-chain messages. Track processed messages."
  },
  {
    id: "SOL4944",
    name: "Intent-Based Settlement Manipulation",
    severity: "critical",
    pattern: /intent.*settle|settlement.*order(?![\s\S]{0,100}verify_price|[\s\S]{0,100}user_check)/i,
    description: "2026: Intent-based protocols vulnerable to solver manipulation during settlement.",
    recommendation: "Verify settlement matches intent parameters. Implement solver reputation."
  },
  {
    id: "SOL4945",
    name: "Zero-Knowledge Proof Verification Bypass",
    severity: "critical",
    pattern: /zk.*proof|zero.*knowledge(?![\s\S]{0,100}verify_proof|[\s\S]{0,100}groth16)/i,
    description: "2026: ZK proofs in Solana programs need proper verification. Invalid proofs = exploit.",
    recommendation: "Use battle-tested ZK verification libraries. Verify all proof parameters."
  },
  {
    id: "SOL4946",
    name: "FHE (Fully Homomorphic Encryption) Misuse",
    severity: "critical",
    pattern: /fhe|homomorphic(?![\s\S]{0,100}parameter_check|[\s\S]{0,100}noise_budget)/i,
    description: "2026: FHE implementations can leak information if parameters misconfigured.",
    recommendation: "Use standard FHE parameters. Monitor noise budget. Implement proper key management."
  },
  {
    id: "SOL4947",
    name: "Rollup Sequencer Centralization",
    severity: "high",
    pattern: /sequencer|rollup(?![\s\S]{0,100}decentralized|[\s\S]{0,100}force_inclusion)/i,
    description: "2026: Centralized sequencers can censor transactions. Need force-inclusion mechanism.",
    recommendation: "Implement escape hatch for L1 transaction inclusion. Decentralize sequencer set."
  },
  {
    id: "SOL4948",
    name: "Data Availability Layer Attack",
    severity: "critical",
    pattern: /data.*availability|da.*layer(?![\s\S]{0,100}verify_commitment|[\s\S]{0,100}erasure_coding)/i,
    description: "2026: DA layers can withhold data, causing liveness failures. Need verification.",
    recommendation: "Use data availability sampling. Implement erasure coding for data recovery."
  },
  {
    id: "SOL4949",
    name: "Modular Stack Integration Risk",
    severity: "high",
    pattern: /modular|layer.*integration(?![\s\S]{0,100}verify_each|[\s\S]{0,100}trust_assumption)/i,
    description: "2026: Modular blockchain stacks have integration risks. Trust assumptions compound.",
    recommendation: "Verify each layer independently. Document and audit trust assumptions."
  },
  {
    id: "SOL4950",
    name: "Cross-Rollup Bridge Exploit",
    severity: "critical",
    pattern: /cross.*rollup|rollup.*bridge(?![\s\S]{0,100}finality|[\s\S]{0,100}fraud_proof)/i,
    description: "2026: Cross-rollup bridges need finality guarantees. Reorgs can cause double-spend.",
    recommendation: "Wait for L1 finality before confirming cross-rollup transfers. Implement fraud proofs."
  },
  // Token-2022 Advanced Patterns
  {
    id: "SOL4951",
    name: "Token-2022 Transfer Fee Bypass",
    severity: "critical",
    pattern: /transfer_fee|TransferFee(?![\s\S]{0,100}collect_fee|[\s\S]{0,100}verify_fee)/i,
    description: "Token-2022 transfer fees can be bypassed via CPI or wrapping. Ensure fee collection.",
    recommendation: "Verify fees collected on all transfer paths. Handle wrapped token transfers."
  },
  {
    id: "SOL4952",
    name: "Token-2022 Interest Bearing Manipulation",
    severity: "high",
    pattern: /interest.*bearing|InterestBearingConfig(?![\s\S]{0,100}rate_limit|[\s\S]{0,100}authority_check)/i,
    description: "Interest-bearing tokens need rate limits. Excessive rates can drain liquidity.",
    recommendation: "Cap interest rates. Verify authority before rate changes. Add timelock."
  },
  {
    id: "SOL4953",
    name: "Token-2022 Non-Transferable Bypass",
    severity: "high",
    pattern: /non_transferable|NonTransferable(?![\s\S]{0,100}enforce|[\s\S]{0,100}cpi_check)/i,
    description: "Non-transferable tokens can potentially be burned and re-minted. Check authority.",
    recommendation: "Verify mint/burn authority is restricted. Check for bypass via CPI."
  },
  {
    id: "SOL4954",
    name: "Token-2022 Metadata Extension Spoofing",
    severity: "medium",
    pattern: /token.*metadata|metadata.*pointer(?![\s\S]{0,100}verify_authority)/i,
    description: "Token-2022 metadata can be updated by authority. Verify before trusting.",
    recommendation: "Pin expected metadata. Verify update_authority before trusting metadata."
  },
  {
    id: "SOL4955",
    name: "Token-2022 Group/Member Token Validation",
    severity: "high",
    pattern: /group.*member|token.*group(?![\s\S]{0,100}verify_membership|[\s\S]{0,100}group_authority)/i,
    description: "Token groups can be exploited if membership not validated. Fake group attacks.",
    recommendation: "Verify token group membership on-chain. Check group authority."
  },
  // MEV and Transaction Ordering
  {
    id: "SOL4956",
    name: "Bundle Inclusion Guarantee Missing",
    severity: "high",
    pattern: /jito.*bundle|bundle.*tip(?![\s\S]{0,100}all_or_nothing|[\s\S]{0,100}atomic)/i,
    description: "Jito bundles need atomic execution. Partial inclusion can be exploited.",
    recommendation: "Use Jito bundle with all-or-nothing execution. Set appropriate tip."
  },
  {
    id: "SOL4957",
    name: "Mempool Observation Attack",
    severity: "high",
    pattern: /mempool|pending.*transaction(?![\s\S]{0,100}private_mempool|[\s\S]{0,100}encrypted)/i,
    description: "Public mempool transactions can be front-run. Use private submission.",
    recommendation: "Use Jito block engine or other private mempool solutions."
  },
  {
    id: "SOL4958",
    name: "Time-Bandit Attack on Reorgs",
    severity: "critical",
    pattern: /reorg|reorganization(?![\s\S]{0,100}finality|[\s\S]{0,100}confirmation)/i,
    description: "Profitable reorgs can reverse finalized transactions. Wait for sufficient confirmations.",
    recommendation: "Wait for finality (~32 slots). Implement reorg detection and alerts."
  },
  {
    id: "SOL4959",
    name: "Leader Schedule Manipulation",
    severity: "high",
    pattern: /leader.*schedule|slot.*leader(?![\s\S]{0,100}verify_schedule)/i,
    description: "Leader schedule is predictable. Attackers can time attacks for specific leaders.",
    recommendation: "Monitor for targeted attacks on specific slots. Implement rate limiting."
  },
  {
    id: "SOL4960",
    name: "Block Stuffing Attack",
    severity: "high",
    pattern: /block.*stuff|fill.*block(?![\s\S]{0,100}rate_limit|[\s\S]{0,100}priority_check)/i,
    description: "Attackers can stuff blocks with transactions, delaying legitimate users.",
    recommendation: "Use priority fees. Implement transaction prioritization mechanisms."
  },
  // Account Model Security
  {
    id: "SOL4961",
    name: "Account Lamport Manipulation",
    severity: "high",
    pattern: /lamports|try_borrow_mut_lamports(?![\s\S]{0,100}checked_sub|[\s\S]{0,100}checked_add)/i,
    description: "Lamport manipulations need checked arithmetic. Overflow can mint lamports.",
    recommendation: "Use checked arithmetic for all lamport operations."
  },
  {
    id: "SOL4962",
    name: "Account Data Alias Vulnerability",
    severity: "critical",
    pattern: /borrow_mut|RefMut(?![\s\S]{0,100}drop|[\s\S]{0,100}single_borrow)/i,
    description: "Multiple mutable borrows of same account data can cause aliasing issues.",
    recommendation: "Ensure only one mutable borrow at a time. Drop borrows before re-borrowing."
  },
  {
    id: "SOL4963",
    name: "Zero Account Detection Bypass",
    severity: "high",
    pattern: /zero.*account|empty.*account(?![\s\S]{0,100}lamport_check|[\s\S]{0,100}data_len)/i,
    description: "Zero-lamport accounts can be garbage collected. Check before use.",
    recommendation: "Verify account has lamports and data before using. Handle GC'd accounts."
  },
  {
    id: "SOL4964",
    name: "Account Size Reallocation Race",
    severity: "high",
    pattern: /realloc|AccountInfo.*realloc(?![\s\S]{0,100}single_transaction|[\s\S]{0,100}atomic)/i,
    description: "Reallocation in one instruction, access in another can cause race conditions.",
    recommendation: "Complete reallocation and usage in same instruction. Verify size after realloc."
  },
  {
    id: "SOL4965",
    name: "Rent Exemption Edge Case",
    severity: "medium",
    pattern: /rent_exempt|minimum_balance(?![\s\S]{0,100}plus_data|[\s\S]{0,100}account_size)/i,
    description: "Rent exemption calculation must include all account data. Edge cases exist.",
    recommendation: "Calculate rent exemption with actual data size. Account for potential reallocs."
  },
  // Error Handling Patterns
  {
    id: "SOL4966",
    name: "Silent Error Swallowing",
    severity: "high",
    pattern: /ok\(\)|unwrap_or_default|if let Err\(_\)/i,
    description: "Swallowing errors silently can hide security issues. Propagate or handle explicitly.",
    recommendation: "Propagate errors with ?. Log errors before handling. Never silently ignore."
  },
  {
    id: "SOL4967",
    name: "Panic in Production Code",
    severity: "high",
    pattern: /panic!|unreachable!|todo!|unimplemented!/i,
    description: "Panics cause transaction failures and can be triggered by attackers.",
    recommendation: "Replace panics with proper error handling. Use Result instead of panic."
  },
  {
    id: "SOL4968",
    name: "Error Message Information Leak",
    severity: "medium",
    pattern: /error![\s\S]{0,50}(key|secret|password|token)/i,
    description: "Error messages can leak sensitive information in transaction logs.",
    recommendation: "Use generic error messages. Don't include sensitive data in errors."
  },
  {
    id: "SOL4969",
    name: "Missing Error Code Uniqueness",
    severity: "low",
    pattern: /#\[error_code\][\s\S]{0,200}(?!#\[msg)/,
    description: "Anchor error codes should have unique messages for debugging.",
    recommendation: 'Add #[msg("...")] to all error variants for clear debugging.'
  },
  {
    id: "SOL4970",
    name: "Assertion Instead of Error",
    severity: "medium",
    pattern: /assert!|assert_eq!(?![\s\S]{0,20}test)/i,
    description: "Assertions panic on failure. Use require! or return Err for graceful handling.",
    recommendation: "Replace assert! with require! in Anchor. Use proper error types in native."
  },
  // Cryptographic Security
  {
    id: "SOL4971",
    name: "Weak Randomness Source",
    severity: "critical",
    pattern: /random|rand(?![\s\S]{0,50}vrf|[\s\S]{0,50}switchboard|[\s\S]{0,50}chainlink)/i,
    description: "On-chain randomness is predictable. Use VRF or external randomness.",
    recommendation: "Use Switchboard VRF or similar. Never use clock/slot for randomness."
  },
  {
    id: "SOL4972",
    name: "ED25519 Signature Malleability",
    severity: "high",
    pattern: /ed25519|verify_signature(?![\s\S]{0,100}canonical|[\s\S]{0,100}low_s)/i,
    description: "ED25519 signatures can have multiple valid forms. Enforce canonical form.",
    recommendation: "Verify signature is in canonical form. Use standard verification libraries."
  },
  {
    id: "SOL4973",
    name: "Hash Collision Vulnerability",
    severity: "critical",
    pattern: /hash(?![\s\S]{0,50}sha256|[\s\S]{0,50}keccak|[\s\S]{0,50}blake)/i,
    description: "Custom hash functions may be collision-prone. Use standard cryptographic hashes.",
    recommendation: "Use SHA256, Keccak, or Blake3. Avoid custom hash implementations."
  },
  {
    id: "SOL4974",
    name: "Merkle Tree Second Preimage Attack",
    severity: "critical",
    pattern: /merkle.*leaf|leaf.*hash(?![\s\S]{0,100}prefix|[\s\S]{0,100}domain_sep)/i,
    description: "Merkle trees without leaf prefixes vulnerable to second preimage attack.",
    recommendation: "Add domain separator/prefix to leaf hashes. Use 0x00 for leaves, 0x01 for nodes."
  },
  {
    id: "SOL4975",
    name: "ECDSA Recovery ID Manipulation",
    severity: "high",
    pattern: /recovery_id|ecrecover(?![\s\S]{0,100}verify_recovery)/i,
    description: "ECDSA recovery IDs can be manipulated. Verify recovered address matches expected.",
    recommendation: "Always verify recovered address. Don't trust recovery without address check."
  },
  // Serialization Security
  {
    id: "SOL4976",
    name: "Borsh Deserialization Overflow",
    severity: "critical",
    pattern: /borsh.*deserialize|try_from_slice(?![\s\S]{0,100}size_check|[\s\S]{0,100}length_limit)/i,
    description: "Borsh deserialization can read past buffer bounds. Validate data length.",
    recommendation: "Check data length before deserializing. Use try_from_slice, not from_slice."
  },
  {
    id: "SOL4977",
    name: "Variable Length Field Manipulation",
    severity: "high",
    pattern: /Vec<|String|Option<Vec(?![\s\S]{0,100}max_len|[\s\S]{0,100}bounded)/i,
    description: "Variable length fields in accounts can be manipulated to exceed expected size.",
    recommendation: "Bound variable length fields with max sizes. Validate on deserialization."
  },
  {
    id: "SOL4978",
    name: "Account Padding Exploitation",
    severity: "medium",
    pattern: /repr\(C\)|padding(?![\s\S]{0,100}zeroed|[\s\S]{0,100}initialized)/i,
    description: "Padding bytes in repr(C) structs can contain uninitialized data.",
    recommendation: "Initialize all struct fields including padding. Use #[repr(packed)] if needed."
  },
  {
    id: "SOL4979",
    name: "Cross-Program Serialization Mismatch",
    severity: "high",
    pattern: /cpi[\s\S]{0,50}serialize|invoke[\s\S]{0,50}data(?![\s\S]{0,100}verify_format)/i,
    description: "Different programs may use different serialization. Verify format compatibility.",
    recommendation: "Use standard Anchor/Borsh serialization. Document and verify data formats."
  },
  {
    id: "SOL4980",
    name: "Instruction Data Length Manipulation",
    severity: "high",
    pattern: /instruction.*data|data\[[\s\S]{0,20}\.\.(?![\s\S]{0,30}len\s*<|[\s\S]{0,30}len\s*==)/,
    description: "Instruction data length can be manipulated. Validate expected length.",
    recommendation: "Check instruction data length matches expected. Reject unexpected sizes."
  },
  // State Machine Security
  {
    id: "SOL4981",
    name: "Invalid State Transition",
    severity: "critical",
    pattern: /state.*transition|status.*change(?![\s\S]{0,100}valid_transition|[\s\S]{0,100}state_machine)/i,
    description: "State machines without transition validation allow invalid state changes.",
    recommendation: "Define valid state transitions. Reject invalid transitions with errors."
  },
  {
    id: "SOL4982",
    name: "Race Condition in State Update",
    severity: "high",
    pattern: /state.*update|update.*state(?![\s\S]{0,100}atomic|[\s\S]{0,100}single_instruction)/i,
    description: "Non-atomic state updates can cause race conditions across transactions.",
    recommendation: "Complete state updates atomically within single instruction."
  },
  {
    id: "SOL4983",
    name: "Missing State Initialization Check",
    severity: "critical",
    pattern: /state.*enum|Status[\s\S]{0,50}(?!Uninitialized|NotInitialized)/i,
    description: "State enums should include Uninitialized variant to detect uninitialized accounts.",
    recommendation: "Add Uninitialized variant to state enums. Check state before operations."
  },
  {
    id: "SOL4984",
    name: "Final State Reversibility",
    severity: "high",
    pattern: /final.*state|completed|closed(?![\s\S]{0,100}irreversible|[\s\S]{0,100}no_modify)/i,
    description: "Final states should be irreversible. Completed/closed accounts shouldn't change.",
    recommendation: "Mark final states as immutable. Reject any modifications after finalization."
  },
  {
    id: "SOL4985",
    name: "Concurrent State Modification",
    severity: "high",
    pattern: /concurrent|parallel.*update(?![\s\S]{0,100}lock|[\s\S]{0,100}mutex)/i,
    description: "Concurrent modifications to same state can cause inconsistencies.",
    recommendation: "Use version numbers or locks for concurrent access. Implement optimistic locking."
  },
  // Access Control Patterns
  {
    id: "SOL4986",
    name: "Privilege Escalation via Delegation",
    severity: "critical",
    pattern: /delegate|delegation(?![\s\S]{0,100}scope_limit|[\s\S]{0,100}privilege_check)/i,
    description: "Delegation without scope limits allows privilege escalation.",
    recommendation: "Limit delegated permissions. Implement scope restrictions on delegations."
  },
  {
    id: "SOL4987",
    name: "Role Assignment Without Verification",
    severity: "critical",
    pattern: /role.*assign|assign.*role(?![\s\S]{0,100}authority_check|[\s\S]{0,100}multisig)/i,
    description: "Role assignments need proper authority verification. Single point of failure.",
    recommendation: "Require multisig or DAO approval for role assignments."
  },
  {
    id: "SOL4988",
    name: "Emergency Admin Backdoor",
    severity: "critical",
    pattern: /emergency.*admin|admin.*override(?![\s\S]{0,100}timelock|[\s\S]{0,100}multisig)/i,
    description: "Emergency admin powers without controls can be abused.",
    recommendation: "Emergency powers require multisig + timelock. Log all emergency actions."
  },
  {
    id: "SOL4989",
    name: "Authority Transfer Without Acceptance",
    severity: "high",
    pattern: /transfer.*authority|set.*authority(?![\s\S]{0,100}accept|[\s\S]{0,100}two_step)/i,
    description: "Direct authority transfer can send to wrong address. Use two-step transfer.",
    recommendation: "Implement two-step authority transfer: propose then accept."
  },
  {
    id: "SOL4990",
    name: "Missing Permission Revocation",
    severity: "high",
    pattern: /permission|access(?![\s\S]{0,100}revoke|[\s\S]{0,100}remove)/i,
    description: "Permissions granted should be revocable. Forgotten access = security risk.",
    recommendation: "Implement revocation for all permissions. Audit access periodically."
  },
  // Economic Security
  {
    id: "SOL4991",
    name: "Token Emission Without Cap",
    severity: "critical",
    pattern: /mint.*token|token.*emission(?![\s\S]{0,100}max_supply|[\s\S]{0,100}cap)/i,
    description: "Uncapped token emission leads to inflation. Implement hard supply cap.",
    recommendation: "Set maximum supply. Implement emission schedule. Monitor total supply."
  },
  {
    id: "SOL4992",
    name: "Fee Accumulation Exploitation",
    severity: "high",
    pattern: /fee.*accumulate|accumulated.*fee(?![\s\S]{0,100}claim_limit|[\s\S]{0,100}distribution)/i,
    description: "Accumulated fees can be exploited if claim mechanism is flawed.",
    recommendation: "Implement fair fee distribution. Add claim rate limits."
  },
  {
    id: "SOL4993",
    name: "Reward Distribution Front-running",
    severity: "high",
    pattern: /reward.*distribution|distribute.*reward(?![\s\S]{0,100}snapshot|[\s\S]{0,100}merkle)/i,
    description: "Reward distributions can be front-run. Deposit before, claim after.",
    recommendation: "Use snapshots for reward eligibility. Implement claiming delays."
  },
  {
    id: "SOL4994",
    name: "Treasury Drain via Governance",
    severity: "critical",
    pattern: /treasury.*withdraw|governance.*treasury(?![\s\S]{0,100}timelock|[\s\S]{0,100}limit)/i,
    description: "Governance can drain treasury if no safeguards. Synthetify DAO pattern.",
    recommendation: "Implement withdrawal limits. Require timelock + multisig for large amounts."
  },
  {
    id: "SOL4995",
    name: "Airdrop Farming Detection",
    severity: "medium",
    pattern: /airdrop|claim.*token(?![\s\S]{0,100}sybil_check|[\s\S]{0,100}eligibility)/i,
    description: "Airdrops can be farmed via Sybil accounts. Implement eligibility checks.",
    recommendation: "Use on-chain activity history. Implement Sybil resistance mechanisms."
  },
  // Testing and Audit Patterns
  {
    id: "SOL4996",
    name: "Missing Fuzz Testing",
    severity: "medium",
    pattern: /#\[test\](?![\s\S]{0,500}fuzz|[\s\S]{0,500}proptest)/i,
    description: "Unit tests may miss edge cases. Fuzz testing finds unexpected inputs.",
    recommendation: "Implement fuzz testing with cargo-fuzz or proptest. Test edge cases."
  },
  {
    id: "SOL4997",
    name: "No Integration Tests",
    severity: "medium",
    pattern: /mod tests(?![\s\S]{0,500}integration|[\s\S]{0,500}BanksClient)/i,
    description: "Unit tests don't catch CPI or account interaction issues. Need integration tests.",
    recommendation: "Write integration tests with BanksClient or Anchor testing framework."
  },
  {
    id: "SOL4998",
    name: "Unaudited Code Path",
    severity: "high",
    pattern: /\/\/\s*TODO|\/\/\s*FIXME|\/\/\s*HACK(?![\s\S]{0,30}audit)/i,
    description: "TODO/FIXME comments indicate incomplete code. Should be resolved before deploy.",
    recommendation: "Resolve all TODOs before deployment. Mark audit exclusions explicitly."
  },
  {
    id: "SOL4999",
    name: "Missing Audit Trail",
    severity: "medium",
    pattern: /authority.*change|config.*update(?![\s\S]{0,100}emit!|[\s\S]{0,100}event)/i,
    description: "Critical operations should emit events for audit trail.",
    recommendation: "Emit events for all state-changing operations. Include relevant parameters."
  },
  {
    id: "SOL5000",
    name: "Incomplete Documentation",
    severity: "low",
    pattern: /pub\s+fn\s+\w+(?![\s\S]{0,30}\/\/\/|[\s\S]{0,30}#\[doc)/,
    description: "Public functions without documentation increase audit difficulty.",
    recommendation: "Document all public functions. Explain security considerations."
  }
];
function checkBatch89Patterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) return findings;
  const lines = content.split("\n");
  for (const pattern of BATCH_89_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  return findings;
}

// src/patterns/index.ts
var CORE_PATTERNS = [
  {
    id: "SOL001",
    name: "Missing Owner Check",
    severity: "critical",
    pattern: /AccountInfo[\s\S]{0,200}(?![\s\S]{0,100}owner\s*==)(?![\s\S]{0,100}has_one)/,
    description: "Account ownership is not verified. Anyone could pass a malicious account.",
    recommendation: "Add owner validation: require!(account.owner == expected_program, ErrorCode::InvalidOwner);"
  },
  {
    id: "SOL002",
    name: "Missing Signer Check",
    severity: "critical",
    pattern: /\/\/\/\s*CHECK:|AccountInfo.*(?!.*Signer|.*is_signer|.*#\[account\(.*signer)/,
    description: "Authority account lacks signer verification.",
    recommendation: "Add signer constraint: #[account(signer)] or verify is_signer manually."
  },
  {
    id: "SOL003",
    name: "Integer Overflow",
    severity: "high",
    pattern: /\b\w+\s*[-+*]\s*\w+(?!.*checked_|.*saturating_|.*wrapping_)/,
    description: "Arithmetic operation without overflow protection.",
    recommendation: "Use checked_add(), checked_sub(), or checked_mul()."
  },
  {
    id: "SOL004",
    name: "PDA Validation Gap",
    severity: "high",
    pattern: /find_program_address|create_program_address(?![\s\S]{0,50}bump|[\s\S]{0,50}seeds)/,
    description: "PDA derivation without bump seed storage.",
    recommendation: "Store and verify the canonical bump seed."
  },
  {
    id: "SOL005",
    name: "Authority Bypass",
    severity: "critical",
    pattern: /authority|admin|owner.*AccountInfo(?!.*constraint|.*has_one)/i,
    description: "Sensitive authority account without proper constraints.",
    recommendation: "Add has_one constraint: #[account(has_one = authority)]"
  },
  {
    id: "SOL006",
    name: "Missing Init Check",
    severity: "critical",
    pattern: /init\s*=\s*false|is_initialized\s*=\s*false(?![\s\S]{0,100}require!|[\s\S]{0,100}assert)/,
    description: "Account can be reinitialized, potentially resetting state.",
    recommendation: "Check is_initialized before modifying account state."
  },
  {
    id: "SOL007",
    name: "CPI Vulnerability",
    severity: "high",
    pattern: /invoke(?:_signed)?(?![\s\S]{0,100}program_id\s*==)/,
    description: "Cross-program invocation without verifying target program.",
    recommendation: "Verify program_id matches expected value before CPI."
  },
  {
    id: "SOL008",
    name: "Rounding Error",
    severity: "medium",
    pattern: /\/\s*\d+(?![\s\S]{0,50}checked_div|[\s\S]{0,50}\.ceil\(|[\s\S]{0,50}\.floor\()/,
    description: "Division without proper rounding handling.",
    recommendation: "Use explicit rounding (ceil/floor) for financial calculations."
  },
  {
    id: "SOL009",
    name: "Account Confusion",
    severity: "high",
    pattern: /#\[account\][\s\S]{0,200}(?![\s\S]{0,100}discriminator)/,
    description: "Account struct may be confused with other types.",
    recommendation: "Verify account discriminator before deserializing."
  },
  {
    id: "SOL010",
    name: "Account Closing Vulnerability",
    severity: "critical",
    pattern: /close\s*=|try_borrow_mut_lamports[\s\S]{0,50}=\s*0(?![\s\S]{0,50}realloc|[\s\S]{0,50}zero)/,
    description: "Account closure without proper cleanup could allow revival.",
    recommendation: "Zero out account data before closing."
  },
  {
    id: "SOL011",
    name: "Reentrancy Risk",
    severity: "high",
    pattern: /invoke(?:_signed)?[\s\S]{0,200}(?:balance|lamports|amount)\s*[+-=]/,
    description: "State modification after CPI call could enable reentrancy.",
    recommendation: "Update state before making external calls."
  },
  {
    id: "SOL012",
    name: "Arbitrary CPI",
    severity: "critical",
    pattern: /invoke[\s\S]{0,50}program_id(?![\s\S]{0,50}==|[\s\S]{0,50}require!)/,
    description: "CPI to arbitrary program without validation.",
    recommendation: "Hardcode expected program IDs or validate against allowlist."
  },
  {
    id: "SOL013",
    name: "Duplicate Mutable",
    severity: "high",
    pattern: /#\[account\(mut\)\][\s\S]*?#\[account\(mut\)\]/,
    description: "Multiple mutable references to same account type.",
    recommendation: "Add constraints to ensure accounts are different."
  },
  {
    id: "SOL014",
    name: "Missing Rent Check",
    severity: "medium",
    pattern: /lamports[\s\S]{0,100}(?!rent_exempt|minimum_balance)/,
    description: "Account may not be rent-exempt.",
    recommendation: "Verify account has minimum rent-exempt balance."
  },
  {
    id: "SOL015",
    name: "Type Cosplay",
    severity: "critical",
    pattern: /#\[account\][\s\S]{0,100}pub\s+struct(?![\s\S]{0,100}discriminator)/,
    description: "Account struct could be confused with other types.",
    recommendation: "Add unique discriminator or use Anchor."
  },
  {
    id: "SOL016",
    name: "Bump Seed Issue",
    severity: "high",
    pattern: /bump(?![\s\S]{0,50}canonical|[\s\S]{0,50}find_program_address)/,
    description: "Non-canonical bump seed could allow account spoofing.",
    recommendation: "Always use canonical bump from find_program_address."
  },
  {
    id: "SOL017",
    name: "Freeze Authority",
    severity: "medium",
    pattern: /freeze_authority|FreezeAccount(?![\s\S]{0,100}check|[\s\S]{0,100}verify)/,
    description: "Freeze authority operations without validation.",
    recommendation: "Verify freeze authority before operations."
  },
  {
    id: "SOL018",
    name: "Oracle Manipulation",
    severity: "high",
    pattern: /price|oracle|feed(?![\s\S]{0,100}staleness|[\s\S]{0,100}confidence|[\s\S]{0,100}twap)/i,
    description: "Oracle data without staleness or confidence checks.",
    recommendation: "Check staleness, confidence, use TWAP for critical ops."
  },
  {
    id: "SOL019",
    name: "Flash Loan Risk",
    severity: "critical",
    pattern: /flash_loan|flashloan|instant_loan(?![\s\S]{0,200}repay|[\s\S]{0,200}callback)/i,
    description: "Flash loan implementation without repayment verification.",
    recommendation: "Verify loan is repaid in same transaction."
  },
  {
    id: "SOL020",
    name: "Unsafe Math",
    severity: "high",
    pattern: /as\s+u\d+|as\s+i\d+(?![\s\S]{0,30}try_into|[\s\S]{0,30}checked)/,
    description: "Unsafe type casting could cause overflow.",
    recommendation: "Use try_into() for safe casting."
  },
  {
    id: "SOL021",
    name: "Sysvar Manipulation",
    severity: "critical",
    pattern: /sysvar::clock|sysvar::rent(?![\s\S]{0,50}from_account_info)/,
    description: "Sysvar accessed without proper validation.",
    recommendation: "Use from_account_info() to validate sysvars."
  },
  {
    id: "SOL022",
    name: "Upgrade Authority",
    severity: "medium",
    pattern: /upgrade_authority|set_authority(?![\s\S]{0,100}multisig|[\s\S]{0,100}timelock)/i,
    description: "Program upgrade without proper controls.",
    recommendation: "Use multisig or timelock for upgrade authority."
  },
  {
    id: "SOL023",
    name: "Token Validation",
    severity: "high",
    pattern: /token_account|TokenAccount(?![\s\S]{0,100}mint\s*==|[\s\S]{0,100}owner\s*==)/i,
    description: "Token account without mint/owner validation.",
    recommendation: "Verify token account mint and owner."
  },
  {
    id: "SOL024",
    name: "Cross-Program State",
    severity: "high",
    pattern: /invoke[\s\S]{0,100}state[\s\S]{0,100}(?![\s\S]{0,50}refresh|[\s\S]{0,50}reload)/,
    description: "Cross-program call without state refresh.",
    recommendation: "Refresh state after cross-program calls."
  },
  {
    id: "SOL025",
    name: "Lamport Balance",
    severity: "high",
    pattern: /lamports[\s\S]{0,50}(?:sub|add)(?![\s\S]{0,30}checked)/,
    description: "Unsafe lamport arithmetic.",
    recommendation: "Use checked arithmetic for lamport operations."
  },
  // Continue with more patterns...
  {
    id: "SOL026",
    name: "Seeded Account",
    severity: "medium",
    pattern: /create_account_with_seed(?![\s\S]{0,100}verify)/,
    description: "Seeded account creation without verification.",
    recommendation: "Verify seeds match expected values."
  },
  {
    id: "SOL027",
    name: "Unsafe Unwrap",
    severity: "medium",
    pattern: /\.unwrap\(\)|\.expect\(/,
    description: "Using unwrap() can cause panic.",
    recommendation: "Use ? operator or match for error handling."
  },
  {
    id: "SOL028",
    name: "Missing Events",
    severity: "low",
    pattern: /transfer|mint|burn(?![\s\S]{0,200}emit!|[\s\S]{0,200}log|[\s\S]{0,200}msg!)/i,
    description: "State-changing operation without event emission.",
    recommendation: "Emit events for important state changes."
  },
  {
    id: "SOL029",
    name: "Signature Bypass",
    severity: "critical",
    pattern: /verify_signature|ed25519(?![\s\S]{0,50}require!|[\s\S]{0,50}assert!)/i,
    description: "Signature verification without proper validation.",
    recommendation: "Always verify signatures and revert on failure."
  },
  {
    id: "SOL030",
    name: "Anchor Macro Misuse",
    severity: "medium",
    pattern: /#\[account\([\s\S]{0,50}init[\s\S]{0,50}(?!payer|space)/,
    description: "Account init without payer or space.",
    recommendation: "Specify payer and space for init accounts."
  },
  // High-value exploit patterns
  {
    id: "SOL031",
    name: "Mango Oracle Attack ($116M)",
    severity: "critical",
    pattern: /price[\s\S]{0,100}(?:perp|spot|mark)(?![\s\S]{0,100}twap|[\s\S]{0,100}window)/i,
    description: "Price manipulation without TWAP protection.",
    recommendation: "Use TWAP or multiple oracle sources."
  },
  {
    id: "SOL032",
    name: "Wormhole Guardian ($326M)",
    severity: "critical",
    pattern: /guardian|verify_signatures(?![\s\S]{0,100}quorum|[\s\S]{0,100}threshold)/i,
    description: "Guardian validation without quorum check.",
    recommendation: "Verify guardian quorum threshold."
  },
  {
    id: "SOL033",
    name: "Cashio Root-of-Trust ($52M)",
    severity: "critical",
    pattern: /collateral|backing(?![\s\S]{0,100}verify_mint|[\s\S]{0,100}whitelist)/i,
    description: "Collateral validation without mint verification.",
    recommendation: "Verify collateral mint is whitelisted."
  },
  {
    id: "SOL034",
    name: "Crema CLMM Spoofing ($8.8M)",
    severity: "critical",
    pattern: /tick|position(?![\s\S]{0,100}owner_check|[\s\S]{0,100}verify_ownership)/i,
    description: "Tick/position without ownership verification.",
    recommendation: "Verify tick account ownership."
  },
  {
    id: "SOL035",
    name: "Slope Wallet Leak ($8M)",
    severity: "critical",
    pattern: /private_key|secret_key|mnemonic(?![\s\S]{0,50}encrypt)/i,
    description: "Potential private key exposure.",
    recommendation: "Never log or expose private keys."
  },
  {
    id: "SOL036",
    name: "Nirvana Bonding ($3.5M)",
    severity: "critical",
    pattern: /bonding_curve|mint_price(?![\s\S]{0,100}flash_loan_protection)/i,
    description: "Bonding curve vulnerable to flash loan.",
    recommendation: "Add flash loan protection to bonding operations."
  },
  {
    id: "SOL037",
    name: "Raydium Pool Drain ($4.4M)",
    severity: "critical",
    pattern: /pool_authority|withdraw[\s\S]{0,100}admin(?![\s\S]{0,100}multisig)/i,
    description: "Pool admin without multisig protection.",
    recommendation: "Use multisig for pool admin operations."
  },
  {
    id: "SOL038",
    name: "Pump.fun Insider ($1.9M)",
    severity: "high",
    pattern: /launch|bonding[\s\S]{0,100}early(?![\s\S]{0,100}lock|[\s\S]{0,100}delay)/i,
    description: "Launch mechanism vulnerable to insider trading.",
    recommendation: "Add launch delay or lock period."
  },
  {
    id: "SOL039",
    name: "Hardcoded Secret",
    severity: "critical",
    pattern: /secret|private_key|password|api_key[\s\S]{0,20}=[\s\S]{0,10}["'][a-zA-Z0-9]{16,}["']/i,
    description: "Hardcoded secret detected.",
    recommendation: "Never store secrets in code."
  },
  {
    id: "SOL040",
    name: "CPI Guard Bypass",
    severity: "high",
    pattern: /cpi_guard|approve_checked(?![\s\S]{0,100}verify)/i,
    description: "CPI guard operations without verification.",
    recommendation: "Verify CPI guard state before operations."
  }
];
var ADDITIONAL_PATTERNS = [
  {
    id: "SOL041",
    name: "Governance Attack",
    severity: "critical",
    pattern: /governance|proposal|vote(?![\s\S]{0,100}timelock|[\s\S]{0,100}delay)/i,
    description: "Governance without timelock protection.",
    recommendation: "Add timelock to governance operations."
  },
  {
    id: "SOL042",
    name: "NFT Royalty Bypass",
    severity: "high",
    pattern: /royalt|creator_fee(?![\s\S]{0,100}enforce|[\s\S]{0,100}verify)/i,
    description: "NFT royalties can be bypassed.",
    recommendation: "Use enforced royalties (Metaplex pNFT)."
  },
  {
    id: "SOL043",
    name: "Staking Vulnerability",
    severity: "high",
    pattern: /stake|unstake(?![\s\S]{0,100}cooldown|[\s\S]{0,100}lock_period)/i,
    description: "Staking without cooldown period.",
    recommendation: "Add cooldown for unstaking."
  },
  {
    id: "SOL044",
    name: "AMM Invariant",
    severity: "critical",
    pattern: /swap|exchange(?![\s\S]{0,100}k_value|[\s\S]{0,100}invariant)/i,
    description: "AMM swap without invariant check.",
    recommendation: "Verify AMM invariant after swaps."
  },
  {
    id: "SOL045",
    name: "Lending Liquidation",
    severity: "critical",
    pattern: /liquidat|health_factor(?![\s\S]{0,100}threshold|[\s\S]{0,100}minimum)/i,
    description: "Liquidation without proper threshold.",
    recommendation: "Set appropriate liquidation thresholds."
  },
  {
    id: "SOL046",
    name: "Bridge Security",
    severity: "critical",
    pattern: /bridge|cross_chain(?![\s\S]{0,100}finality|[\s\S]{0,100}confirmation)/i,
    description: "Cross-chain bridge without finality check.",
    recommendation: "Wait for sufficient confirmations."
  },
  {
    id: "SOL047",
    name: "Vault Security",
    severity: "high",
    pattern: /vault|treasury(?![\s\S]{0,100}withdrawal_limit|[\s\S]{0,100}rate_limit)/i,
    description: "Vault without withdrawal limits.",
    recommendation: "Implement withdrawal rate limits."
  },
  {
    id: "SOL048",
    name: "Merkle Vulnerability",
    severity: "critical",
    pattern: /merkle|proof(?![\s\S]{0,100}verify_proof|[\s\S]{0,100}validate)/i,
    description: "Merkle proof without validation.",
    recommendation: "Verify merkle proofs properly."
  },
  {
    id: "SOL049",
    name: "Compression Issue",
    severity: "medium",
    pattern: /compress|cnft(?![\s\S]{0,100}verify_leaf|[\s\S]{0,100}proof)/i,
    description: "Compressed NFT without proof verification.",
    recommendation: "Verify compression proofs."
  },
  {
    id: "SOL050",
    name: "Program Derived",
    severity: "high",
    pattern: /invoke_signed(?![\s\S]{0,100}seeds|[\s\S]{0,100}bump)/i,
    description: "invoke_signed without proper seeds.",
    recommendation: "Use correct seeds for PDA signing."
  }
];
var ALL_PATTERNS = [...CORE_PATTERNS, ...ADDITIONAL_PATTERNS];
async function runPatterns(input) {
  const findings = [];
  const content = input.rust?.content || "";
  const fileName = input.path || input.rust?.filePath || "unknown";
  if (!content) {
    return findings;
  }
  const lines = content.split("\n");
  for (const pattern of ALL_PATTERNS) {
    try {
      const flags = pattern.pattern.flags.includes("g") ? pattern.pattern.flags : pattern.pattern.flags + "g";
      const regex = new RegExp(pattern.pattern.source, flags);
      const matches = [...content.matchAll(regex)];
      for (const match of matches) {
        const matchIndex = match.index || 0;
        let lineNum = 1;
        let charCount = 0;
        for (let i = 0; i < lines.length; i++) {
          charCount += lines[i].length + 1;
          if (charCount > matchIndex) {
            lineNum = i + 1;
            break;
          }
        }
        const startLine = Math.max(0, lineNum - 2);
        const endLine = Math.min(lines.length, lineNum + 2);
        const snippet = lines.slice(startLine, endLine).join("\n");
        findings.push({
          id: pattern.id,
          title: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          location: { file: fileName, line: lineNum },
          recommendation: pattern.recommendation,
          code: snippet.substring(0, 200)
        });
      }
    } catch (error) {
    }
  }
  try {
    findings.push(...checkSec32025BusinessLogic(input));
    findings.push(...checkSec32025InputValidation(input));
    findings.push(...checkSec32025AccessControl(input));
    findings.push(...checkSec32025DataIntegrity(input));
    findings.push(...checkSec32025DosLiveness(input));
  } catch (error) {
  }
  try {
    findings.push(...checkHelius2024DeepPatterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch53Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch54Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch55Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch56Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch57Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch58Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch59Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch60Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch61Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch62Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch63Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch64Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch65Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch66Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch67Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch68Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch69Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch70Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch71Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch72Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch73Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch74Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch75Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch76Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...scanBatch77(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch78Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch79Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch80Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch81Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch82Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch83Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch84Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch85Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch86Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch87Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch88Patterns(input));
  } catch (error) {
  }
  try {
    findings.push(...checkBatch89Patterns(input));
  } catch (error) {
  }
  const seen = /* @__PURE__ */ new Set();
  const deduped = findings.filter((f) => {
    const key = `${f.id}-${f.location.line}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
  const severityOrder = { critical: 0, high: 1, medium: 2, low: 3, info: 4 };
  deduped.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);
  return deduped;
}
function getPatternById(id) {
  const p = ALL_PATTERNS.find((p2) => p2.id === id);
  if (!p) return void 0;
  return {
    id: p.id,
    name: p.name,
    severity: p.severity,
    run: (input) => {
      const content = input.rust?.content || "";
      if (p.pattern.test(content)) {
        return [{
          id: p.id,
          title: p.name,
          severity: p.severity,
          description: p.description,
          location: { file: input.path },
          recommendation: p.recommendation
        }];
      }
      return [];
    }
  };
}
function listPatterns() {
  return ALL_PATTERNS.map((p) => ({
    id: p.id,
    name: p.name,
    severity: p.severity,
    run: () => []
    // Placeholder
  }));
}
var PATTERN_COUNT = ALL_PATTERNS.length + 6600;

// src/sdk.ts
import { existsSync, readdirSync, statSync } from "fs";
import { join, basename } from "path";
async function scan(path, options = {}) {
  const startTime = Date.now();
  const programName = basename(path);
  if (!existsSync(path)) {
    throw new Error(`Path not found: ${path}`);
  }
  function findRustFiles2(dir) {
    const files = [];
    const scanDir = (d) => {
      for (const entry of readdirSync(d, { withFileTypes: true })) {
        const full = join(d, entry.name);
        if (entry.isDirectory() && !["node_modules", "target", ".git"].includes(entry.name)) {
          scanDir(full);
        } else if (entry.name.endsWith(".rs")) {
          files.push(full);
        }
      }
    };
    scanDir(dir);
    return files;
  }
  const rustFiles = statSync(path).isDirectory() ? findRustFiles2(path) : [path];
  if (rustFiles.length === 0) {
    throw new Error("No Rust files found to scan");
  }
  const parsed = await parseRustFiles(rustFiles);
  const allFindings = [];
  if (parsed && parsed.files) {
    for (const file of parsed.files) {
      const findings = await runPatterns({
        path: file.path,
        rust: {
          files: [file],
          functions: parsed.functions.filter((f) => f.file === file.path),
          structs: parsed.structs.filter((s) => s.file === file.path),
          implBlocks: parsed.implBlocks.filter((i) => i.file === file.path),
          content: file.content
        },
        idl: null
      });
      allFindings.push(...findings);
    }
  }
  const duration = Date.now() - startTime;
  const summary = {
    critical: allFindings.filter((f) => f.severity === "critical").length,
    high: allFindings.filter((f) => f.severity === "high").length,
    medium: allFindings.filter((f) => f.severity === "medium").length,
    low: allFindings.filter((f) => f.severity === "low").length,
    info: allFindings.filter((f) => f.severity === "info").length,
    total: allFindings.length
  };
  const failOn = options.failOn || "critical";
  let passed = true;
  switch (failOn) {
    case "any":
      passed = summary.total === 0;
      break;
    case "low":
      passed = summary.critical === 0 && summary.high === 0 && summary.medium === 0 && summary.low === 0;
      break;
    case "medium":
      passed = summary.critical === 0 && summary.high === 0 && summary.medium === 0;
      break;
    case "high":
      passed = summary.critical === 0 && summary.high === 0;
      break;
    case "critical":
    default:
      passed = summary.critical === 0;
      break;
  }
  return {
    programPath: path,
    programName,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    duration,
    findings: allFindings,
    summary,
    passed
  };
}

// src/commands/check.ts
import { existsSync as existsSync2, readdirSync as readdirSync2, statSync as statSync2 } from "fs";
import { join as join2 } from "path";
async function checkCommand(path, options = {}) {
  const failOn = options.failOn || "critical";
  const quiet = options.quiet || false;
  if (!existsSync2(path)) {
    if (!quiet) console.error(`Path not found: ${path}`);
    process.exit(2);
  }
  const rustFiles = findRustFiles(path);
  if (rustFiles.length === 0) {
    if (!quiet) console.log("No Rust files found");
    process.exit(0);
  }
  const parsed = await parseRustFiles(rustFiles);
  let criticalCount = 0;
  let highCount = 0;
  let mediumCount = 0;
  let lowCount = 0;
  if (parsed && parsed.files) {
    for (const file of parsed.files) {
      const findings = await runPatterns({
        path: file.path,
        rust: {
          files: [file],
          functions: parsed.functions.filter((f) => f.file === file.path),
          structs: parsed.structs.filter((s) => s.file === file.path),
          implBlocks: parsed.implBlocks.filter((i) => i.file === file.path),
          content: file.content
        },
        idl: null
      });
      for (const f of findings) {
        if (f.severity === "critical") criticalCount++;
        else if (f.severity === "high") highCount++;
        else if (f.severity === "medium") mediumCount++;
        else if (f.severity === "low") lowCount++;
      }
    }
  }
  let failed = false;
  switch (failOn) {
    case "any":
      failed = criticalCount + highCount + mediumCount + lowCount > 0;
      break;
    case "low":
      failed = criticalCount + highCount + mediumCount + lowCount > 0;
      break;
    case "medium":
      failed = criticalCount + highCount + mediumCount > 0;
      break;
    case "high":
      failed = criticalCount + highCount > 0;
      break;
    case "critical":
    default:
      failed = criticalCount > 0;
      break;
  }
  if (!quiet) {
    const total = criticalCount + highCount + mediumCount + lowCount;
    if (failed) {
      console.log(`FAIL: ${total} issue(s) found (${criticalCount} critical, ${highCount} high)`);
    } else {
      console.log(`PASS: ${total} issue(s), none at ${failOn} level or above`);
    }
  }
  process.exit(failed ? 1 : 0);
}
function findRustFiles(path) {
  if (statSync2(path).isFile()) {
    return path.endsWith(".rs") ? [path] : [];
  }
  const files = [];
  function scan2(dir) {
    for (const entry of readdirSync2(dir, { withFileTypes: true })) {
      const full = join2(dir, entry.name);
      if (entry.isDirectory() && !["node_modules", "target", ".git"].includes(entry.name)) {
        scan2(full);
      } else if (entry.name.endsWith(".rs")) {
        files.push(full);
      }
    }
  }
  scan2(path);
  return files;
}

// src/swarm/orchestrator.ts
import { execSync } from "child_process";
import { readFileSync as readFileSync3, existsSync as existsSync3, writeFileSync, mkdirSync } from "fs";
import { join as join3, basename as basename2 } from "path";

// src/swarm/agents.ts
var BASE_SECURITY_CONTEXT = `You are a security auditor specializing in Solana and Anchor programs.

## Solana Security Context
- Solana uses a single-threaded runtime - no traditional reentrancy
- BUT cross-program invocations (CPIs) can cause reentrancy-like bugs
- All accounts must be validated: ownership, signer, PDA derivation
- Integer arithmetic can overflow/underflow silently in release builds
- Oracles can be manipulated via flash loans or low liquidity

## Output Format
Return findings as JSON array:
\`\`\`json
[
  {
    "id": "SWARM-001",
    "severity": "critical|high|medium|low|info",
    "title": "Brief title",
    "description": "Detailed explanation",
    "location": {"file": "path", "line": 123},
    "code": "relevant code snippet",
    "suggestion": "How to fix",
    "references": ["link1", "link2"]
  }
]
\`\`\`

Focus ONLY on your specialty. Be thorough but precise - no false positives.`;
var SpecialistAgent = class {
  config;
  constructor(config) {
    this.config = config;
  }
  /**
   * Generate the full prompt for analyzing code
   */
  getAnalysisPrompt(code, filePath) {
    return `${this.config.systemPrompt}

## File to Analyze
Path: ${filePath}

\`\`\`rust
${code}
\`\`\`

Analyze this code for ${this.config.name.toLowerCase()} vulnerabilities.
Return your findings as a JSON array. If no issues found, return empty array: []`;
  }
  /**
   * Parse agent response into structured findings
   */
  parseResponse(response) {
    const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/) || response.match(/\[\s*\{[\s\S]*\}\s*\]/);
    if (!jsonMatch) {
      try {
        const direct = JSON.parse(response);
        if (Array.isArray(direct)) return direct;
      } catch {
        return [];
      }
      return [];
    }
    try {
      const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  }
};
function createAgent(config) {
  return new SpecialistAgent({
    ...config,
    systemPrompt: `${BASE_SECURITY_CONTEXT}

${config.systemPrompt}`
  });
}

// src/swarm/specialists.ts
var REENTRANCY_SPECIALIST = {
  id: "reentrancy",
  name: "Reentrancy & CPI Specialist",
  description: "Detects cross-program invocation state bugs and reentrancy-like patterns",
  patterns: [
    "cross-program-reentrancy",
    "cpi-check",
    "cpi-guard",
    "cpi-return-data",
    "cross-program-invocation-check",
    "cross-program-state"
  ],
  systemPrompt: `## Your Specialty: Reentrancy & Cross-Program Invocation (CPI) Bugs

You are an expert in Solana's CPI mechanics and the unique reentrancy-like bugs
that can occur despite the single-threaded runtime.

### Key Vulnerability Patterns

1. **State Changes After CPI** (CRITICAL)
   - State modified after invoke()/invoke_signed()
   - Pattern: CPI \u2192 state change (should be: state change \u2192 CPI)
   - Fix: Apply checks-effects-interactions pattern

2. **CPI Return Data Manipulation**
   - External program can return malicious data
   - Unchecked return values from CPI calls
   
3. **Account State Assumptions After CPI**
   - Reading account data that CPI might have modified
   - Assuming balances unchanged after transfer CPI

4. **Missing CPI Guard**
   - Anchor's #[account(cpi_guard)] attribute not used
   - Allows unexpected CPIs to modify accounts

5. **Recursive CPI Attacks**
   - Callback loops through intermediary programs
   - Stack depth exploitation

### What to Look For

\`\`\`rust
// DANGEROUS: State change after CPI
invoke(&ix, &accounts)?;
account.balance = new_balance;  // Should be BEFORE invoke

// DANGEROUS: Reading account after CPI
invoke(&transfer_ix, &accounts)?;
let balance = token_account.amount;  // May have changed!

// SAFE: Checks-Effects-Interactions
account.balance = new_balance;  // Effect first
invoke(&ix, &accounts)?;         // Interaction last
\`\`\`

Report ONLY CPI/reentrancy related issues. Be precise about the attack vector.`
};
var ACCESS_CONTROL_SPECIALIST = {
  id: "access-control",
  name: "Access Control Specialist",
  description: "Detects permission, ownership, and authority validation bugs",
  patterns: [
    "access-control",
    "account-ownership",
    "authority-scope",
    "authority-transfer",
    "admin-authentication-bypass",
    "privilege-escalation",
    "program-signer"
  ],
  systemPrompt: `## Your Specialty: Access Control & Authorization Bugs

You are an expert in Solana account ownership, signer requirements, and
authorization patterns in Anchor programs.

### Key Vulnerability Patterns

1. **Missing Owner Check** (CRITICAL)
   - Account not validated to be owned by expected program
   - Attacker can pass arbitrary account with crafted data
   
2. **Missing Signer Requirement** (CRITICAL)  
   - Privileged function without signer validation
   - #[account(signer)] or Signer<'info> missing
   
3. **Authority Not Verified**
   - Admin/owner field exists but never checked
   - has_one constraint missing
   
4. **Improper PDA Validation**
   - Seeds not properly validated in constraints
   - Bump not stored or checked
   
5. **Authority Transfer Without Protection**
   - Single-step authority transfer (should be two-step)
   - No timelock on sensitive operations

### What to Look For

\`\`\`rust
// DANGEROUS: No owner check
pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {
    // Who owns vault_account? Not checked!
    let vault = &ctx.accounts.vault_account;
    
// DANGEROUS: Missing signer
pub admin: AccountInfo<'info>,  // Should be Signer<'info>

// DANGEROUS: Authority stored but not checked
#[account]
pub struct Config {
    pub admin: Pubkey,  // Never used in constraints!
}

// SAFE: Proper constraints
#[account(
    has_one = admin,
    constraint = admin.key() == config.admin
)]
\`\`\`

Report ONLY access control related issues. Focus on authorization gaps.`
};
var ARITHMETIC_SPECIALIST = {
  id: "arithmetic",
  name: "Arithmetic & Math Specialist",
  description: "Detects overflow, underflow, precision loss, and unsafe calculations",
  patterns: [
    "unsafe-math",
    "checked-math-required",
    "checked-math-validation",
    "arithmetic-precision",
    "calculation-precision",
    "division-before-multiplication",
    "integer-truncation",
    "rounding",
    "rounding-direction-attack"
  ],
  systemPrompt: `## Your Specialty: Arithmetic Vulnerabilities

You are an expert in integer math vulnerabilities in Solana programs.
Rust's release builds do NOT panic on overflow - they wrap silently!

### Key Vulnerability Patterns

1. **Integer Overflow/Underflow** (CRITICAL)
   - Using +, -, * without checked_ or saturating_
   - u64 overflow wraps to 0 in release mode
   
2. **Division by Zero**
   - Missing zero check before division
   - checked_div not used
   
3. **Precision Loss** (HIGH)
   - Division before multiplication
   - (a / 100) * b loses precision vs (a * b) / 100
   
4. **Lossy Type Casts**
   - Casting u128 to u64 without bounds check
   - "as" casts truncate silently
   
5. **Rounding Direction Attacks**
   - Consistent rounding in attacker's favor
   - Fee calculations that round down

### What to Look For

\`\`\`rust
// DANGEROUS: Can overflow
let total = amount + fee;
let shares = deposit * total_shares / total_supply;

// DANGEROUS: Division by zero
let price = amount / supply;  // supply could be 0!

// DANGEROUS: Precision loss
let fee = amount / 10000 * rate;  // Wrong order!

// DANGEROUS: Truncation
let small: u32 = big_u64 as u32;  // Silently truncates!

// SAFE: Checked arithmetic
let total = amount.checked_add(fee).ok_or(ErrorCode::Overflow)?;
let price = amount.checked_div(supply).ok_or(ErrorCode::DivByZero)?;
\`\`\`

Report ONLY arithmetic vulnerabilities. Include the exact calculation that's unsafe.`
};
var ORACLE_SPECIALIST = {
  id: "oracle",
  name: "Oracle Security Specialist",
  description: "Detects oracle manipulation, staleness, and price feed vulnerabilities",
  patterns: [
    "oracle-manipulation",
    "oracle-safety",
    "oracle-twap-manipulation",
    "pyth-integration",
    "price-oracle-twap",
    "drift-oracle-guardrails",
    "mango-oracle-exploit"
  ],
  systemPrompt: `## Your Specialty: Oracle Security

You are an expert in price oracle integration and manipulation attacks
targeting Solana DeFi protocols.

### Key Vulnerability Patterns

1. **Missing Staleness Check** (CRITICAL)
   - Using price without checking last_update_time
   - Stale prices enable arbitrage attacks
   
2. **Single-Point Price** (HIGH)
   - No TWAP, just spot price
   - Susceptible to flash loan manipulation
   
3. **Missing Confidence Interval** (Pyth)
   - Not checking conf field from Pyth
   - Wide confidence = unreliable price
   
4. **Oracle Account Not Validated**
   - Not verifying oracle is official Pyth/Switchboard
   - Attacker can pass fake oracle account
   
5. **Decimal Handling**
   - Not accounting for oracle's price exponent
   - Mixing decimals incorrectly

### What to Look For

\`\`\`rust
// DANGEROUS: No staleness check
let price = pyth_account.price;  // Could be hours old!

// DANGEROUS: No confidence check
let price = feed.get_price_unchecked();  // May be very uncertain

// DANGEROUS: No oracle validation
pub price_feed: AccountInfo<'info>,  // Could be any account!

// SAFE: Full validation
let price_data = price_feed.get_price_no_older_than(
    &Clock::get()?,
    MAX_STALENESS_SECONDS
)?;
require!(
    price_data.conf < MAX_CONFIDENCE,
    ErrorCode::PriceUncertain
);
\`\`\`

Report ONLY oracle-related vulnerabilities. Focus on manipulation vectors.`
};
var COMPREHENSIVE_SPECIALIST = {
  id: "comprehensive",
  name: "Comprehensive Security Auditor",
  description: "Full-spectrum security analysis covering all vulnerability categories",
  patterns: ["*"],
  systemPrompt: `## Your Role: Comprehensive Security Auditor

You are a senior Solana security auditor performing a full-spectrum analysis.
Cover ALL vulnerability categories:

1. **Access Control**: Ownership, signers, authorities, PDAs
2. **Arithmetic**: Overflow, underflow, precision, division by zero
3. **CPI/Reentrancy**: State changes after CPIs, callback attacks
4. **Oracles**: Staleness, manipulation, validation
5. **Account Validation**: Discriminators, data matching, initialization
6. **Token Security**: Mint authority, freeze, approvals, decimals
7. **Logic Bugs**: Edge cases, off-by-one, state transitions

Prioritize by severity:
- CRITICAL: Direct fund theft, complete privilege bypass
- HIGH: Significant fund loss, major DoS, auth bypass
- MEDIUM: Limited loss, protocol manipulation, minor DoS
- LOW: Best practice violations, optimization issues
- INFO: Style, documentation, maintainability

Be thorough but avoid false positives. Each finding must have a clear attack path.`
};
var ALL_SPECIALISTS = [
  REENTRANCY_SPECIALIST,
  ACCESS_CONTROL_SPECIALIST,
  ARITHMETIC_SPECIALIST,
  ORACLE_SPECIALIST
];
function getSpecialist(id) {
  const specialist = ALL_SPECIALISTS.find((s) => s.id === id);
  if (specialist) return specialist;
  if (id === "comprehensive") return COMPREHENSIVE_SPECIALIST;
  throw new Error(`Unknown specialist: ${id}`);
}

// src/swarm/synthesizer.ts
async function synthesizeFindings(findings, code, filePath) {
  const deduplicated = deduplicateFindings(findings);
  const crossReferences = findCrossReferences(deduplicated);
  const byFile = groupByFile(deduplicated);
  const bySeverity = groupBySeverity(deduplicated);
  const byAgent = groupByAgent(deduplicated);
  const summary = generateSummary(deduplicated, crossReferences);
  return {
    originalCount: findings.length,
    deduplicatedCount: deduplicated.length,
    deduplicatedFindings: deduplicated,
    byFile,
    bySeverity,
    byAgent,
    summary,
    crossReferences
  };
}
function deduplicateFindings(findings) {
  const seen = /* @__PURE__ */ new Map();
  for (const finding of findings) {
    const fingerprint = createFingerprint(finding);
    if (seen.has(fingerprint)) {
      const existing = seen.get(fingerprint);
      mergeFinding(existing, finding);
    } else {
      seen.set(fingerprint, { ...finding });
    }
  }
  return Array.from(seen.values());
}
function createFingerprint(finding) {
  const parts = [
    finding.location.file,
    finding.location.line?.toString() || "unknown",
    finding.severity,
    // Normalize title for comparison
    normalizeTitle(finding.title)
  ];
  return parts.join("::");
}
function normalizeTitle(title) {
  return title.toLowerCase().replace(/[^a-z0-9]/g, "").slice(0, 50);
}
function mergeFinding(existing, incoming) {
  const severityOrder = ["critical", "high", "medium", "low", "info"];
  if (severityOrder.indexOf(incoming.severity) < severityOrder.indexOf(existing.severity)) {
    existing.severity = incoming.severity;
  }
  if (incoming.description && !existing.description.includes(incoming.description) && incoming.description.length > existing.description.length) {
    existing.description = incoming.description;
  }
  if (incoming.suggestion && !existing.suggestion?.includes(incoming.suggestion)) {
    existing.suggestion = existing.suggestion ? `${existing.suggestion}

Alternative: ${incoming.suggestion}` : incoming.suggestion;
  }
  if (incoming.agent && existing.agent !== incoming.agent) {
    existing.foundBy = existing.foundBy || [existing.agent];
    if (!existing.foundBy.includes(incoming.agent)) {
      existing.foundBy.push(incoming.agent);
    }
  }
}
function findCrossReferences(findings) {
  const crossRefs = [];
  const byLocation = /* @__PURE__ */ new Map();
  for (const f of findings) {
    const loc = `${f.location.file}:${f.location.line || 0}`;
    if (!byLocation.has(loc)) byLocation.set(loc, []);
    byLocation.get(loc).push(f);
  }
  for (const [loc, group] of byLocation) {
    if (group.length > 1) {
      crossRefs.push({
        findingIds: group.map((f) => f.id),
        relationship: "related",
        description: `Multiple issues at ${loc}`
      });
    }
  }
  const severityOrder = ["critical", "high", "medium", "low", "info"];
  const criticalHighFindings = findings.filter(
    (f) => ["critical", "high"].includes(f.severity)
  );
  for (const critical of criticalHighFindings) {
    const related = findings.filter(
      (f) => f !== critical && f.location.file === critical.location.file && Math.abs((f.location.line || 0) - (critical.location.line || 0)) < 20
    );
    if (related.length > 0) {
      crossRefs.push({
        findingIds: [critical.id, ...related.map((r) => r.id)],
        relationship: "cascading",
        description: `Issues near critical finding "${critical.title}"`
      });
    }
  }
  return crossRefs;
}
function groupByFile(findings) {
  const groups = {};
  for (const f of findings) {
    const file = f.location.file;
    if (!groups[file]) groups[file] = [];
    groups[file].push(f);
  }
  return groups;
}
function groupBySeverity(findings) {
  const groups = {
    critical: [],
    high: [],
    medium: [],
    low: [],
    info: []
  };
  for (const f of findings) {
    groups[f.severity].push(f);
  }
  return groups;
}
function groupByAgent(findings) {
  const groups = {};
  for (const f of findings) {
    const agent = f.agent || "unknown";
    if (!groups[agent]) groups[agent] = [];
    groups[agent].push(f);
  }
  return groups;
}
function generateSummary(findings, crossRefs) {
  const severity = {
    critical: findings.filter((f) => f.severity === "critical").length,
    high: findings.filter((f) => f.severity === "high").length,
    medium: findings.filter((f) => f.severity === "medium").length,
    low: findings.filter((f) => f.severity === "low").length,
    info: findings.filter((f) => f.severity === "info").length
  };
  const topRisks = [];
  const criticalFindings = findings.filter((f) => f.severity === "critical");
  const highFindings = findings.filter((f) => f.severity === "high");
  if (criticalFindings.length > 0) {
    topRisks.push(...criticalFindings.slice(0, 3).map((f) => f.title));
  }
  if (topRisks.length < 3 && highFindings.length > 0) {
    topRisks.push(...highFindings.slice(0, 3 - topRisks.length).map((f) => f.title));
  }
  const recommendations = [];
  if (severity.critical > 0) {
    recommendations.push("URGENT: Address all critical vulnerabilities before deployment");
  }
  if (severity.high > 0) {
    recommendations.push("Fix high-severity issues in the next release");
  }
  const hasAccessControl = findings.some(
    (f) => f.agent === "access-control" || f.title.toLowerCase().includes("access")
  );
  if (hasAccessControl) {
    recommendations.push("Conduct thorough access control review");
  }
  const hasArithmetic = findings.some(
    (f) => f.agent === "arithmetic" || f.title.toLowerCase().includes("overflow")
  );
  if (hasArithmetic) {
    recommendations.push("Implement checked arithmetic throughout codebase");
  }
  if (crossRefs.some((r) => r.relationship === "cascading")) {
    recommendations.push("Investigate cascading vulnerability chains");
  }
  if (recommendations.length === 0) {
    recommendations.push("Continue monitoring for emerging vulnerability patterns");
  }
  return {
    ...severity,
    total: findings.length,
    topRisks,
    recommendations
  };
}
function formatSynthesisAsMarkdown(result) {
  const lines = [];
  lines.push("# SolGuard Multi-Agent Security Audit Report\n");
  lines.push(`Generated: ${(/* @__PURE__ */ new Date()).toISOString()}
`);
  lines.push("## Executive Summary\n");
  lines.push(`| Severity | Count |`);
  lines.push(`|----------|-------|`);
  lines.push(`| Critical | ${result.summary.critical} |`);
  lines.push(`| High | ${result.summary.high} |`);
  lines.push(`| Medium | ${result.summary.medium} |`);
  lines.push(`| Low | ${result.summary.low} |`);
  lines.push(`| Info | ${result.summary.info} |`);
  lines.push(`| **Total** | **${result.summary.total}** |`);
  lines.push("");
  if (result.summary.topRisks.length > 0) {
    lines.push("### Top Risks\n");
    for (const risk of result.summary.topRisks) {
      lines.push(`- ${risk}`);
    }
    lines.push("");
  }
  if (result.summary.recommendations.length > 0) {
    lines.push("### Recommendations\n");
    for (const rec of result.summary.recommendations) {
      lines.push(`- ${rec}`);
    }
    lines.push("");
  }
  lines.push("## Findings\n");
  for (const severity of ["critical", "high", "medium", "low", "info"]) {
    const findings = result.bySeverity[severity];
    if (findings.length === 0) continue;
    lines.push(`### ${severity.charAt(0).toUpperCase() + severity.slice(1)} (${findings.length})
`);
    for (const f of findings) {
      lines.push(`#### ${f.id}: ${f.title}
`);
      lines.push(`- **Location**: ${f.location.file}:${f.location.line || "?"}`);
      lines.push(`- **Agent**: ${f.agent || "unknown"}`);
      lines.push(`- **Description**: ${f.description}`);
      if (f.code) {
        lines.push("\n```rust");
        lines.push(f.code);
        lines.push("```\n");
      }
      if (f.suggestion) {
        lines.push(`- **Suggestion**: ${f.suggestion}`);
      }
      lines.push("");
    }
  }
  if (result.crossReferences.length > 0) {
    lines.push("## Related Findings\n");
    for (const ref of result.crossReferences) {
      lines.push(`- **${ref.relationship}**: ${ref.description}`);
      lines.push(`  - Findings: ${ref.findingIds.join(", ")}`);
    }
  }
  return lines.join("\n");
}

// src/swarm/orchestrator.ts
function isAgentTeamsAvailable() {
  const envEnabled = process.env.CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS === "1";
  const insideClaudeCode = !!process.env.CLAUDE_CODE_AGENT_ID;
  return envEnabled || insideClaudeCode;
}
function isClaudeCliAvailable() {
  try {
    execSync("claude --version", { stdio: "pipe" });
    return true;
  } catch {
    return false;
  }
}
function isApiAvailable() {
  return !!process.env.ANTHROPIC_API_KEY;
}
function detectMode(config) {
  if (config.mode !== "auto") {
    return config.mode;
  }
  if (isAgentTeamsAvailable()) return "agent-teams";
  if (isApiAvailable()) return "api";
  if (isClaudeCliAvailable()) return "subprocess";
  throw new Error(
    "No Claude execution method available. Enable one of:\n  1. Set CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1 for Agent Teams\n  2. Set ANTHROPIC_API_KEY for direct API calls\n  3. Install Claude CLI for subprocess mode"
  );
}
var SwarmOrchestrator = class {
  config;
  agents;
  constructor(config) {
    this.config = {
      mode: config.mode || "auto",
      specialists: config.specialists || ALL_SPECIALISTS.map((s) => s.id),
      model: config.model || "claude-sonnet-4-20250514",
      maxParallel: config.maxParallel || 4,
      timeout: config.timeout || 12e4,
      // 2 minutes
      teamName: config.teamName || `solguard-audit-${Date.now()}`,
      useSynthesis: config.useSynthesis ?? true,
      outputDir: config.outputDir || "./solguard-reports",
      verbose: config.verbose || false
    };
    this.agents = this.config.specialists.map(
      (id) => createAgent(getSpecialist(id))
    );
  }
  /**
   * Run the swarm audit on a file or directory
   */
  async audit(targetPath) {
    const startTime = Date.now();
    const errors = [];
    let mode;
    try {
      mode = detectMode(this.config);
    } catch (e) {
      return {
        success: false,
        mode: "none",
        duration: 0,
        findings: [],
        agentResults: [],
        errors: [e.message]
      };
    }
    this.log(`Starting swarm audit in ${mode} mode`);
    this.log(`Target: ${targetPath}`);
    this.log(`Specialists: ${this.agents.map((a) => a.config.name).join(", ")}`);
    const code = this.readCode(targetPath);
    if (!code) {
      return {
        success: false,
        mode,
        duration: Date.now() - startTime,
        findings: [],
        agentResults: [],
        errors: [`Failed to read code from: ${targetPath}`]
      };
    }
    let agentResults;
    switch (mode) {
      case "agent-teams":
        agentResults = await this.runWithAgentTeams(code, targetPath);
        break;
      case "api":
        agentResults = await this.runWithApi(code, targetPath);
        break;
      case "subprocess":
        agentResults = await this.runWithSubprocess(code, targetPath);
        break;
    }
    const allFindings = agentResults.flatMap((r) => r.findings);
    let synthesis;
    if (this.config.useSynthesis && allFindings.length > 0) {
      try {
        synthesis = await synthesizeFindings(allFindings, code, targetPath);
      } catch (e) {
        errors.push(`Synthesis failed: ${e.message}`);
      }
    }
    for (const result of agentResults) {
      if (result.error) {
        errors.push(`${result.agentName}: ${result.error}`);
      }
    }
    const duration = Date.now() - startTime;
    this.log(`Audit complete in ${duration}ms. Found ${allFindings.length} issues.`);
    if (this.config.outputDir) {
      this.saveReport({
        targetPath,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        mode,
        duration,
        findings: allFindings,
        agentResults,
        synthesis
      });
    }
    return {
      success: errors.length === 0,
      mode,
      duration,
      findings: synthesis?.deduplicatedFindings || allFindings,
      agentResults,
      synthesis,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Read code from file or directory
   */
  readCode(targetPath) {
    try {
      if (!existsSync3(targetPath)) {
        return null;
      }
      const content = readFileSync3(targetPath, "utf-8");
      return content;
    } catch {
      return null;
    }
  }
  /**
   * Run with Claude Code Agent Teams (TeammateTool)
   * 
   * This generates instructions for the TeammateTool - in practice,
   * this would be called from within Claude Code with access to the tool.
   */
  async runWithAgentTeams(code, filePath) {
    this.log("Agent Teams mode: Generating team configuration...");
    const teamConfig = this.generateTeamConfig(code, filePath);
    this.log("Team config generated. In live usage, spawn via TeammateTool.");
    if (isApiAvailable()) {
      this.log("Falling back to API mode for execution...");
      return this.runWithApi(code, filePath);
    }
    return this.agents.map((agent) => ({
      agentId: agent.config.id,
      agentName: agent.config.name,
      success: false,
      findings: [],
      duration: 0,
      error: "Agent Teams mode requires running inside Claude Code. See team config in output."
    }));
  }
  /**
   * Generate Team configuration for Agent Teams mode
   */
  generateTeamConfig(code, filePath) {
    return {
      teamName: this.config.teamName,
      description: `Security audit of ${basename2(filePath)}`,
      teammates: this.agents.map((agent) => ({
        name: agent.config.id,
        type: "security-specialist",
        prompt: agent.getAnalysisPrompt(code, filePath),
        model: this.config.model,
        runInBackground: true
      })),
      // TeammateTool operations needed:
      operations: [
        { operation: "spawnTeam", team_name: this.config.teamName },
        ...this.agents.map((agent) => ({
          operation: "Task",
          team_name: this.config.teamName,
          name: agent.config.id,
          prompt: agent.getAnalysisPrompt(code, filePath),
          run_in_background: true
        }))
      ]
    };
  }
  /**
   * Run with direct Claude API calls
   */
  async runWithApi(code, filePath) {
    this.log("Running with Claude API...");
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error("ANTHROPIC_API_KEY not set");
    }
    const results = [];
    const chunks = this.chunkArray(this.agents, this.config.maxParallel);
    for (const chunk of chunks) {
      const chunkResults = await Promise.all(
        chunk.map((agent) => this.callApiForAgent(agent, code, filePath, apiKey))
      );
      results.push(...chunkResults);
    }
    return results;
  }
  /**
   * Call Claude API for a single agent
   */
  async callApiForAgent(agent, code, filePath, apiKey) {
    const startTime = Date.now();
    const prompt = agent.getAnalysisPrompt(code, filePath);
    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": apiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify({
          model: this.config.model,
          max_tokens: 4096,
          messages: [{ role: "user", content: prompt }]
        })
      });
      if (!response.ok) {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      const content = data.content?.[0]?.text || "";
      const findings = agent.parseResponse(content).map((f) => ({
        ...f,
        agent: agent.config.id
      }));
      return {
        agentId: agent.config.id,
        agentName: agent.config.name,
        success: true,
        findings,
        duration: Date.now() - startTime
      };
    } catch (e) {
      return {
        agentId: agent.config.id,
        agentName: agent.config.name,
        success: false,
        findings: [],
        duration: Date.now() - startTime,
        error: e.message
      };
    }
  }
  /**
   * Run with Claude CLI subprocess
   */
  async runWithSubprocess(code, filePath) {
    this.log("Running with Claude CLI subprocess...");
    const results = [];
    for (const agent of this.agents) {
      const result = await this.callCliForAgent(agent, code, filePath);
      results.push(result);
    }
    return results;
  }
  /**
   * Call Claude CLI for a single agent
   */
  callCliForAgent(agent, code, filePath) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      const prompt = agent.getAnalysisPrompt(code, filePath);
      try {
        const tempDir = join3(this.config.outputDir, ".temp");
        if (!existsSync3(tempDir)) mkdirSync(tempDir, { recursive: true });
        const promptFile = join3(tempDir, `${agent.config.id}-prompt.txt`);
        writeFileSync(promptFile, prompt);
        const result = execSync(
          `claude --print --model ${this.config.model} < "${promptFile}"`,
          {
            timeout: this.config.timeout,
            encoding: "utf-8",
            stdio: ["pipe", "pipe", "pipe"]
          }
        );
        const findings = agent.parseResponse(result).map((f) => ({
          ...f,
          agent: agent.config.id
        }));
        resolve({
          agentId: agent.config.id,
          agentName: agent.config.name,
          success: true,
          findings,
          duration: Date.now() - startTime
        });
      } catch (e) {
        resolve({
          agentId: agent.config.id,
          agentName: agent.config.name,
          success: false,
          findings: [],
          duration: Date.now() - startTime,
          error: e.message
        });
      }
    });
  }
  /**
   * Save report to output directory
   */
  saveReport(report) {
    try {
      if (!existsSync3(this.config.outputDir)) {
        mkdirSync(this.config.outputDir, { recursive: true });
      }
      const filename = `swarm-audit-${Date.now()}.json`;
      const reportPath = join3(this.config.outputDir, filename);
      writeFileSync(reportPath, JSON.stringify(report, null, 2));
      this.log(`Report saved to: ${reportPath}`);
    } catch (e) {
      this.log(`Failed to save report: ${e.message}`);
    }
  }
  /**
   * Utility: chunk array for parallel processing
   */
  chunkArray(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  /**
   * Logging utility
   */
  log(message) {
    if (this.config.verbose) {
      console.log(`[SolGuard Swarm] ${message}`);
    }
  }
};

// src/swarm/audit.ts
async function swarmAudit(options) {
  const config = {
    mode: options.mode || "auto",
    specialists: options.specialists,
    model: options.model,
    outputDir: options.outputDir,
    verbose: options.verbose,
    useSynthesis: true
  };
  const orchestrator = new SwarmOrchestrator(config);
  const result = await orchestrator.audit(options.target);
  let markdownReport;
  if (options.markdown && result.synthesis) {
    markdownReport = formatSynthesisAsMarkdown(result.synthesis);
  }
  return {
    ...result,
    markdownReport
  };
}

// src/index.ts
import chalk from "chalk";
var program = new Command();
program.name("solguard").description("AI-Powered Smart Contract Security Auditor for Solana").version("0.1.0");
program.command("audit").description("Run a full security audit on a Solana program").argument("<path>", "Path to program directory or Rust file").option("-f, --format <format>", "Output format (text|json|markdown)", "text").option("--ai", "Include AI-powered explanations").option("--fail-on <severity>", "Exit with error on severity level (critical|high|medium|low|any)", "critical").action(async (path, options) => {
  try {
    console.log(chalk.blue("\u{1F50D} SolGuard Security Audit"));
    console.log(chalk.gray(`Scanning: ${path}
`));
    const results = await scan(path, {
      format: options.format === "json" ? "json" : "object",
      ai: options.ai,
      failOn: options.failOn
    });
    if (results.findings.length === 0) {
      console.log(chalk.green("\u2705 No vulnerabilities found!"));
    } else {
      console.log(chalk.yellow(`\u26A0\uFE0F  Found ${results.findings.length} potential issues:
`));
      for (const finding of results.findings) {
        const severityColor = finding.severity === "critical" ? chalk.red : finding.severity === "high" ? chalk.yellow : finding.severity === "medium" ? chalk.cyan : chalk.gray;
        console.log(`${severityColor(`[${finding.severity.toUpperCase()}]`)} ${finding.id}: ${finding.title}`);
        console.log(chalk.gray(`  \u2514\u2500 ${finding.location.file}${finding.location.line ? `:${finding.location.line}` : ""}`));
        console.log(chalk.gray(`     ${finding.description}`));
        if (finding.suggestion) {
          console.log(chalk.green(`     \u{1F4A1} ${finding.suggestion}`));
        }
        console.log();
      }
    }
    console.log(chalk.bold("\n\u{1F4CA} Summary:"));
    console.log(`  ${chalk.red("Critical:")} ${results.summary.critical}`);
    console.log(`  ${chalk.yellow("High:")} ${results.summary.high}`);
    console.log(`  ${chalk.cyan("Medium:")} ${results.summary.medium}`);
    console.log(`  ${chalk.gray("Low:")} ${results.summary.low}`);
    console.log(`  ${chalk.blue("Total:")} ${results.summary.total}`);
    console.log(chalk.gray(`  Duration: ${results.duration}ms
`));
    if (!results.passed) {
      process.exit(1);
    }
  } catch (error) {
    console.error(chalk.red(`Error: ${error.message}`));
    process.exit(2);
  }
});
program.command("check").description("Quick security check (pass/fail)").argument("<path>", "Path to program directory").option("--fail-on <severity>", "Fail on severity level", "critical").option("-q, --quiet", "Minimal output").action(async (path, options) => {
  await checkCommand(path, {
    failOn: options.failOn,
    quiet: options.quiet
  });
});
program.command("patterns").description("List all available security patterns").option("--json", "Output as JSON").option("-s, --severity <severity>", "Filter by severity").action((options) => {
  const patterns = listPatterns();
  let filtered = patterns;
  if (options.severity) {
    filtered = patterns.filter((p) => p.severity === options.severity);
  }
  if (options.json) {
    console.log(JSON.stringify(filtered, null, 2));
  } else {
    console.log(chalk.blue(`
\u{1F6E1}\uFE0F  SolGuard Security Patterns (${filtered.length} total)
`));
    const bySeverity = {
      critical: filtered.filter((p) => p.severity === "critical"),
      high: filtered.filter((p) => p.severity === "high"),
      medium: filtered.filter((p) => p.severity === "medium"),
      low: filtered.filter((p) => p.severity === "low"),
      info: filtered.filter((p) => p.severity === "info")
    };
    console.log(chalk.red(`Critical (${bySeverity.critical.length}):`));
    bySeverity.critical.slice(0, 10).forEach((p) => console.log(`  ${p.id}: ${p.name}`));
    if (bySeverity.critical.length > 10) console.log(chalk.gray(`  ... and ${bySeverity.critical.length - 10} more`));
    console.log(chalk.yellow(`
High (${bySeverity.high.length}):`));
    bySeverity.high.slice(0, 10).forEach((p) => console.log(`  ${p.id}: ${p.name}`));
    if (bySeverity.high.length > 10) console.log(chalk.gray(`  ... and ${bySeverity.high.length - 10} more`));
    console.log(chalk.cyan(`
Medium (${bySeverity.medium.length}):`));
    bySeverity.medium.slice(0, 10).forEach((p) => console.log(`  ${p.id}: ${p.name}`));
    if (bySeverity.medium.length > 10) console.log(chalk.gray(`  ... and ${bySeverity.medium.length - 10} more`));
    console.log(chalk.gray(`
Low (${bySeverity.low.length}):`));
    bySeverity.low.slice(0, 5).forEach((p) => console.log(`  ${p.id}: ${p.name}`));
    if (bySeverity.low.length > 5) console.log(chalk.gray(`  ... and ${bySeverity.low.length - 5} more`));
  }
});
program.command("swarm").description("Run multi-agent security audit with specialized AI agents").argument("<path>", "Path to program directory or Rust file").option("--mode <mode>", "Execution mode (api|agent-teams|subprocess|auto)", "auto").option("--specialists <list>", "Comma-separated specialists (reentrancy,access-control,arithmetic,oracle)", "").option("-v, --verbose", "Verbose output").option("--markdown", "Output as markdown report").action(async (path, options) => {
  try {
    console.log(chalk.blue("\u{1F916} SolGuard Multi-Agent Security Swarm"));
    console.log(chalk.gray(`Target: ${path}`));
    console.log(chalk.gray(`Mode: ${options.mode}
`));
    const specialists = options.specialists ? options.specialists.split(",").map((s) => s.trim()) : void 0;
    const result = await swarmAudit({
      target: path,
      mode: options.mode,
      specialists,
      verbose: options.verbose,
      markdown: options.markdown
    });
    if (result.markdownReport) {
      console.log(result.markdownReport);
    } else {
      console.log(chalk.bold(`
\u2705 Swarm Audit Complete`));
      console.log(chalk.gray(`  Mode: ${result.mode}`));
      console.log(chalk.gray(`  Duration: ${result.duration}ms`));
      console.log(chalk.gray(`  Agents: ${result.agentResults.length}`));
      if (result.synthesis) {
        const s = result.synthesis.summary;
        console.log(chalk.bold("\n\u{1F4CA} Findings Summary:"));
        console.log(`  ${chalk.red("Critical:")} ${s.critical}`);
        console.log(`  ${chalk.yellow("High:")} ${s.high}`);
        console.log(`  ${chalk.cyan("Medium:")} ${s.medium}`);
        console.log(`  ${chalk.gray("Low:")} ${s.low}`);
        console.log(`  ${chalk.blue("Total:")} ${result.findings.length}`);
      }
      if (result.errors && result.errors.length > 0) {
        console.log(chalk.yellow("\n\u26A0\uFE0F  Warnings:"));
        result.errors.forEach((err) => console.log(chalk.gray(`  - ${err}`)));
      }
    }
    if (result.synthesis && result.synthesis.summary.critical > 0) {
      process.exit(1);
    }
  } catch (error) {
    console.error(chalk.red(`Error: ${error.message}`));
    if (options.verbose && error.stack) {
      console.error(chalk.gray(error.stack));
    }
    process.exit(2);
  }
});
program.command("version").description("Show version").action(() => {
  console.log("solguard v0.1.0");
  console.log("689+ security patterns");
});
program.parse();
export {
  getPatternById,
  listPatterns,
  scan
};
